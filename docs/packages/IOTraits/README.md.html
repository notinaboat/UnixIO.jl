<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Copyright Sam O'Connor." />
  <meta name="dcterms.date" content="2021-10-10" />
  <title>README</title>
  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/paper.css" />
  <link rel="stylesheet" href="../../css/skylighting-paper-theme.css" />
  <link rel="stylesheet" href="../../css/readmedocs.css" />
</head>
<body>

<header>

<table class="xrt_head">
  <tr><td>
  <b><a href="https://github.com/notinaboat/UnixIO.jl" style="white-space: pre">https://github.com/notinaboat/UnixIO.jl</a></b>
  <td width="100%" style="text-align: center">
  <b>Copyright OC Technology Pty Ltd</b>
  </td><td style="text-align: right">
  <font face="Helvetica">
  <font size="+2.5">
  <b><font color="#0080FF">oc</font><font color="#000000">tech</font></b>
  </font>
  </td></tr>
</table>
<hr style="margin-top: 0;">
<table class="xrt_head">
<tr><td><code>v0.3.2-4-gbe7cc54</code></td><td style="text-align: right">2021-10-10</td></tr>
</table>

</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#iotraits.jl" id="toc-iotraits.jl">IOTraits.jl</a>
  <ul>
  <li><a href="#background" id="toc-background">Background</a></li>
  <li><a href="#overview" id="toc-overview">Overview</a></li>
  <li><a href="#the-io-interface-model"
  id="toc-the-io-interface-model">The IO Interface Model</a>
  <ul>
  <li><a href="#io-or-stream" id="toc-io-or-stream">IO or
  Stream?</a></li>
  <li><a href="#aspects-of-the-stream-interface"
  id="toc-aspects-of-the-stream-interface">Aspects of the Stream
  interface</a></li>
  <li><a href="#atomicity-of-transfers"
  id="toc-atomicity-of-transfers">Atomicity of Transfers</a></li>
  <li><a href="#generic-code-and-dependance-on-traits"
  id="toc-generic-code-and-dependance-on-traits">Generic Code and
  Dependance on Traits</a></li>
  <li><a href="#methods-of-base-functions-for-streams"
  id="toc-methods-of-base-functions-for-streams">Methods of Base
  Functions for Streams</a></li>
  <li><a href="#stream-delegation-wrappers"
  id="toc-stream-delegation-wrappers">Stream Delegation
  Wrappers</a></li>
  </ul></li>
  <li><a href="#unfiled-notes" id="toc-unfiled-notes">Unfiled
  Notes</a></li>
  </ul></li>
  <li><a href="#transfer-direction-trait"
  id="toc-transfer-direction-trait">Transfer Direction Trait</a></li>
  <li><a href="#io-indexing-trait" id="toc-io-indexing-trait">IO
  Indexing Trait</a></li>
  <li><a href="#data-transfer-function"
  id="toc-data-transfer-function">Data Transfer Function</a>
  <ul>
  <li><a href="#transfera-b"
  id="toc-transfera-b"><code>transfer(a =&gt; b)</code></a></li>
  <li><a href="#waiting-for-the-deadline"
  id="toc-waiting-for-the-deadline">Waiting for the Deadline</a></li>
  </ul></li>
  <li><a href="#waiting-mechanism-trait"
  id="toc-waiting-mechanism-trait">Waiting Mechanism Trait</a>
  <ul>
  <li><a href="#preferred-polling-mechanism"
  id="toc-preferred-polling-mechanism">Preferred Polling
  Mechanism</a></li>
  <li><a href="#wait-by-sleeping-method"
  id="toc-wait-by-sleeping-method">Wait By Sleeping Method</a></li>
  <li><a href="#specialised-waiting-methods"
  id="toc-specialised-waiting-methods">Specialised Waiting
  Methods</a></li>
  </ul></li>
  <li><a href="#buffer-interface-traits"
  id="toc-buffer-interface-traits">Buffer Interface Traits</a></li>
  <li><a href="#total-data-size-trait"
  id="toc-total-data-size-trait">Total Data Size Trait</a></li>
  <li><a href="#transfer-size-trait"
  id="toc-transfer-size-trait">Transfer Size Trait</a></li>
  <li><a href="#data-availability-trait"
  id="toc-data-availability-trait">Data Availability Trait</a></li>
  <li><a href="#transfer-function-dispatch"
  id="toc-transfer-function-dispatch">Transfer Function Dispatch</a>
  <ul>
  <li><a href="#start-index-normalisation"
  id="toc-start-index-normalisation"><code>start</code> Index
  Normalisation</a></li>
  <li><a
  href="#application-of-the-direction-and-buffer-interface-traits"
  id="toc-application-of-the-direction-and-buffer-interface-traits">Application
  of the Direction and Buffer Interface Traits</a></li>
  <li><a href="#low-level-byte-stream-methods"
  id="toc-low-level-byte-stream-methods">Low Level Byte-Stream
  Methods</a></li>
  <li><a href="#transfer-specialisations-for-indexable-buffers"
  id="toc-transfer-specialisations-for-indexable-buffers">Transfer
  Specialisations for Indexable Buffers</a></li>
  <li><a href="#transfer-specialisations-for-iterable-buffers"
  id="toc-transfer-specialisations-for-iterable-buffers">Transfer
  Specialisations for Iterable Buffers</a></li>
  <li><a href="#transfer-specialisations-for-collection-buffers"
  id="toc-transfer-specialisations-for-collection-buffers">Transfer
  Specialisations for Collection Buffers</a></li>
  <li><a href="#transfer-specialisations-for-io-buffers"
  id="toc-transfer-specialisations-for-io-buffers">Transfer
  Specialisations for IO Buffers</a></li>
  </ul></li>
  <li><a href="#data-fragmentation-trait"
  id="toc-data-fragmentation-trait">Data Fragmentation Trait</a></li>
  <li><a href="#performance-traits"
  id="toc-performance-traits">Performance Traits</a></li>
  <li><a href="#cursor-traits-mark-seek"
  id="toc-cursor-traits-mark-seek">Cursor Traits (Mark &amp;
  Seek)</a></li>
  <li><a href="#peekable-trait" id="toc-peekable-trait">Peekable
  Trait</a></li>
  <li><a href="#timeout-stream" id="toc-timeout-stream">Timeout
  Stream</a></li>
  <li><a href="#interface-functions"
  id="toc-interface-functions">Interface Functions</a></li>
  <li><a href="#null-streams" id="toc-null-streams">Null
  Streams</a></li>
  <li><a href="#buffered-streams" id="toc-buffered-streams">Buffered
  Streams</a>
  <ul>
  <li><a href="#buffered-input" id="toc-buffered-input">Buffered
  Input</a></li>
  <li><a href="#lazy-buffered-input" id="toc-lazy-buffered-input">Lazy
  Buffered Input</a></li>
  </ul></li>
  <li><a href="#base.io-interface" id="toc-base.io-interface">Base.IO
  Interface</a>
  <ul>
  <li><a href="#function-eof" id="toc-function-eof">Function
  <code>eof</code></a></li>
  <li><a href="#function-readio-t" id="toc-function-readio-t">Function
  <code>read(io, T)</code></a></li>
  <li><a href="#function-readbytes" id="toc-function-readbytes">Function
  <code>readbytes!</code></a></li>
  <li><a href="#function-readstream"
  id="toc-function-readstream">Function
  <code>read(stream)</code></a></li>
  <li><a href="#function-readstream-n"
  id="toc-function-readstream-n">Function
  <code>read(stream, n)</code></a></li>
  <li><a href="#function-unsafe_read"
  id="toc-function-unsafe_read">Function
  <code>unsafe_read</code></a></li>
  <li><a href="#function-readavailable"
  id="toc-function-readavailable">Function
  <code>readavailable</code></a></li>
  <li><a href="#function-readline" id="toc-function-readline">Function
  <code>readline</code></a></li>
  <li><a href="#function-readuntil" id="toc-function-readuntil">Function
  <code>readuntil</code></a></li>
  </ul></li>
  <li><a href="#exports" id="toc-exports">Exports</a>
  <ul>
  <li><a href="#possibly-related-issues"
  id="toc-possibly-related-issues">Possibly Related Issues</a></li>
  <li><a href="#errors" id="toc-errors">Errors</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="iotraits.jl">IOTraits.jl</h1>
<p><a
href="https://www.juliabloggers.com/the-emergent-features-of-julialang-part-ii-traits/">Trait
types</a> for describing the capabilities and behaviour of IO
interfaces.</p>
<div class="sourceCode" id="cb1" data-startFrom="7"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 6;"><span id="cb1-7"><a href="#cb1-7"></a><span class="kw">module</span> IOTraits</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="im">using</span> <span class="bu">Preconditions</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="im">using</span> <span class="bu">Markdown</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="im">using</span> <span class="bu">Preferences</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="im">using</span> <span class="bu">Mmap</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="fu">include</span>(<span class="st">&quot;../../../src/macroutils.jl&quot;</span>)</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="im">using</span> <span class="bu">UnixIOHeaders</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="kw">const</span> C <span class="op">=</span> UnixIOHeaders</span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="fu">include</span>(<span class="st">&quot;../../../src/debug.jl&quot;</span>)</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>    <span class="pp">@db</span> <span class="kw">function</span> <span class="fu">__init__</span>()</span>
<span id="cb1-20"><a href="#cb1-20"></a>        <span class="pp">@ccall</span>(<span class="fu">jl_generating_output</span>()<span class="op">::</span><span class="dt">Cint</span>) <span class="op">==</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> <span class="cf">return</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>        <span class="fu">debug_init</span>()</span>
<span id="cb1-22"><a href="#cb1-22"></a>        <span class="pp">@db</span> <span class="fl">1</span> <span class="st">&quot;UnixIO.DEBUG_LEVEL = </span><span class="sc">$</span>DEBUG_LEVEL<span class="st">. See `src/debug.jl`.&quot;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="kw">end</span></span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="fu">include</span>(<span class="st">&quot;idoc.jl&quot;</span>)</span></code></pre></div>
<h2 id="background">Background</h2>
<p>This collection of Trait types began as a tool for resolving method
selection issues in the UnixIO.jl package.</p>
<p>Everything in Unix is a file, but there are many different types of
file, a few different types of Unix, and many ways a file handle can be
configured.</p>
<p>Selection of correct (or most efficient) methods can often be
achieved with a simple type hierarchy. However traits seem to be useful
way to deal with variations in behaviour that depend file handle
configuration and platform.</p>
<p>In general <code>libc</code>’s <code>write(2)</code> and
<code>read(2)</code> can be used to transfer data to or from any Unix
file descriptor. However, the precise behaviour of these functions
depends on many factors.</p>
<p>Will <code>read</code> block?, if not, will it return less than the
requested number of bytes? Can I query the number of bytes available to
read first? How should I wait for more bytes? If more than one line is
buffered will <code>read</code> return all of them? Will read ever
return a partial line? Will every call to <code>write(2)</code> result
in a packet being transmitted? Is it efficient to write one byte at a
time? Does <code>lseek</code> work with this file? Does
<code>FIONREAD</code> work with this file?</p>
<p>The answers depend on combinations of file type, configuration and
platform.</p>
<p>IOTraits expands on the traits from UnixIO.jl in the hope of making
them more broadly useful. However, according to the <a
href="https://en.wikipedia.org/wiki/Law_of_the_hammer">law of the
hammer</a> some of this is probably overkill. The intention is to
consider the application of Trait types to various aspects of IO and to
see where it leads.</p>
<h2 id="overview">Overview</h2>
<p>The IOTraits interface is built around the function
<code>transfer(stream, buffer)</code>. This function transfers data
between a stream and a buffer.</p>
<p>Traits are used to specify the behaviour of the stream and the
buffer.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Trait</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>TransferDirection</code></td>
<td style="text-align: left;">Which way is the transfer?<br />
(<code>In</code>, <code>Out</code> or <code>Exchange</code>).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>StreamIndexing</code></td>
<td style="text-align: left;">Is indexed stream access supported?
(e.g. <code>pread(2)</code>)<br />
(<code>NotIndexable</code>, <code>IndexableIO</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FromBufferInterface</code></td>
<td style="text-align: left;">How to get data from the buffer?<br />
(<code>FromIO</code>, <code>FromStream</code>, <code>FromPop</code>,
<code>FromTake</code>, <code>UsingIndex</code>,
<code>FromIteration</code> or <code>UsingPtr</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ToBufferInterface</code></td>
<td style="text-align: left;">How to put data into the buffer?<br />
(<code>ToIO</code>, <code>ToStream</code>, <code>ToPush</code>,
<code>ToPut</code>, <code>UsingIndex</code> or
<code>UsingPtr</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>TotalSize</code></td>
<td style="text-align: left;">How much data is available?<br />
(<code>UnknownTotalSize</code>, <code>VariableTotalSize</code>,
<code>FixedTotalSize</code>, or <code>InfiniteTotalSize</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>TransferSize</code></td>
<td style="text-align: left;">How much data can be moved in a single
transfer?<br />
(<code>UnlimitedTransferSize</code>, <code>LimitedTransferSize</code> or
<code>FixedTransferSize</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ReadFragmentation</code></td>
<td style="text-align: left;">What guarantees are made about
fragmentation?<br />
(<code>ReadsBytes</code>, <code>ReadsLines</code>,
<code>ReadsPackets</code> or <code>ReadsRequestedSize</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>CursorSupport</code></td>
<td style="text-align: left;">Are <code>mark</code> and
<code>seek</code> supported?<br />
(<code>NoCursors</code>, <code>Seekable</code> or
<code>Markable</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>WaitingMechanism</code></td>
<td style="text-align: left;">How to wait for activity?<br />
(<code>WaitBySleeping</code>, <code>WaitUsingPosixPoll</code>,
<code>WaitUsingEPoll</code>, <code>WaitUsingPidFD</code> or
<code>WaitUsingKQueue</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FIXME update summaries</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="the-io-interface-model">The IO Interface Model</h2>
<div class="sourceCode" id="cb2"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>help?<span class="op">&gt;</span> <span class="bu">Base</span>.<span class="dt">IO</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  No documentation found.</span></code></pre></div>
<p>As things stand Julia doesn’t have a well defined generic interface
for IO.</p>
<p>It isn’t possible to write a generic library that accepts
<code>&lt;: IO</code> objects because specification of the
<code>IO</code> interface is not complete and the reference
implementations are inconsistent. <span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">Issue <a
href="https://github.com/JuliaLang/julia/issues/24526">24526</a> “Review
of IO blocking behaviour” describes inconsistencies in blocking,
termination and allocation behaviour. There are both inconsistencies
between behaviour of different functions and between different methods
of the same functions.<br />
<br />
</span></span> There are also instances where <code>IO</code> behaviour
is well defined but function naming isn’t ideal, or default behaviour
can be surprising.<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote">e.g. <code>eof(io) -&gt; Bool</code> looks like a
simple query function but it actually blocks to wait for data.<br />
<br />
</span></span></p>
<h3 id="io-or-stream">IO or Stream?</h3>
<p>The Julia IO interface is built around the abstract type
<code>Base.IO</code>. The <code>IO</code> interface specifications refer
to <code>IO</code> objects as “stream” in some places and “io” in
others<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="sidenote">Examples from function signatures:
<code>close(stream)</code>, <code>bytesavailable(io)</code>,
<code>readavailable(stream)</code>, <code>isreadable(io)</code>,
<code>read(io::IO, String)</code>, <code>eof(stream)</code>.<br />
Examples from function descriptions: “The IO stream”, “the specified IO
object” “the given I/O stream”, “the stream <code>io</code>”, “the
stream or file”.<br />
(Also note: <code>Base.IOStream</code> is a concrete subtype of
<code>IO</code> that implements local file system IO. References to
“stream” and “IO stream” in existing <code>IO</code> interface
specifications are not related to <code>Base.IOStream</code>.)<br />
<br />
</span></span>.</p>
<p>The IOTraits interface defines <code>IOTraits.Stream</code> and uses
the word “stream” to refer to instances of this type. To avoid
ambiguity: instances of <code>IO</code> are referred to as “a
<code>Base.IO</code> object”.</p>
<p>The <code>Stream</code> type models byte-streams. Many common
operations involve transferring data to and from byte streams.
e.g. writing data to a local file; receiving data from a network server;
or typing commands into a terminal.</p>
<p>Note that <code>IOTraits.Stream</code> is not a subtype of
<code>Base.IO</code>.<span
class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span
class="sidenote">Similarities and differences between the
<code>Base.IO</code> model and the <code>IOTraits.Stream</code> model
can be seen by reading the <code>IOTraits.BaseIO</code> implementations
of the <code>Base.IO</code> functions below.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb3" data-startFrom="175"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 174;"><span id="cb3-175"><a href="#cb3-175"></a><span class="kw">abstract type</span> Stream <span class="kw">end</span></span></code></pre></div>
<p>The constructor <code>BaseIO(::Stream) -&gt; Base.IO</code> creates a
Base.IO compatible wrapper around a stream.</p>
<div class="sourceCode" id="cb4" data-startFrom="181"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 180;"><span id="cb4-181"><a href="#cb4-181"></a><span class="kw">struct</span> BaseIO{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> Base.IO</span></span>
<span id="cb4-182"><a href="#cb4-182"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-183"><a href="#cb4-183"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="aspects-of-the-stream-interface">Aspects of the Stream
interface</h3>
<p>Issue <a
href="https://github.com/JuliaLang/julia/issues/24526#issuecomment-431567472">24526</a>
identified three aspects of behaviour in the <code>Base.read*</code>
interface that, without precise specification, lead to ambiguity and
inconsistency:</p>
<ul>
<li>allocation: read into the caller’s buffer? (resize this buffer?) or
return a new buffer?</li>
<li>termination: read a specified size?, up to a delimiter? or read as
much as possible?</li>
<li>blocking: wait however long it takes for the termination condition
to be reached? or return early if insufficient data is available?</li>
</ul>
<p>The IOTraits interface attempts to limit the number of behavioural
permutations as much as possible by choosing a default behaviour for
each aspect and supporting other behaviours only by addition of clean
wrapper layers.</p>
<p><strong>Allocation:</strong> The <code>transfer</code> function never
allocates buffers or resizes buffers it simply transfers bytes to or
from the buffer provided. Exceptions to this rule are possible through
the <a href="#buffer-interface-traits">Buffer Interface Traits</a> <span
class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span
class="sidenote">e.g. if
<code>ToBufferInterface(buffer) == ToPush()</code> data is pushed into
the buffer, which may lead to resizing.<br />
<br />
</span></span>. The interface aims to support implementations that wish
to avoid unnecessary buffering. It should be simple to write a transfer
method that passes a supplied buffer directly to an OS system call.
Buffering can be added in wrapper layers as needed.</p>
<p><strong>Termination:</strong> The <code>transfer</code> function is
specified to “transfer at most <code>n</code> items” and “Return the
number of items transferred”. i.e. if some amount of data is available,
return it right away rather than waiting for the entire requested
amount. This behaviour can easily be wrapped with a retry layer to
support cases where all <code>n</code> items are required.</p>
<p><strong>Blocking:</strong> By default the <code>transfer</code>
function waits indefinitely for data to be available. Control over this
behaviour is provided by the optional <code>deadline=</code> argument.
The <code>transfer</code> function stops waiting when
<code>deadline &gt; time()</code>. This interface allows non-blocking
transfers (<code>deadline=0</code>), blocking transfers
(<code>deadline=Inf</code>) or anything in between.<span
class="sidenote-wrapper"><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span
class="sidenote">Note that <code>transfer</code> will always return data
that is immediately available irrespective of the deadline. i.e. There
is no race condition when <code>deadline ~= time()</code>.<br />
<br />
</span></span></p>
<p>The combination of the chosen termination and blocking behavior leads
to two cases where <code>transfer</code> returns zero: End of stream
(EOF), and deadline expired. This seems like a nice unification of the
treatment of streams that have a distinct end and those that don’t. The
caller can specify a deadline that makes sense for their application and
not have to worry about what type of underlying OS stream is
involved.<span
class="sidenote-wrapper"><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span
class="sidenote">With the current <code>IO</code> interface, there are
inconsistencies. e.g. reading log messages from a pipe with
<code>readline(io)</code> will block and wait for a line to be
available, but reading log messages from a file will yield endless empty
stings at the end of the file. The empty strings can be avoided by
<code>while !eof(io) readline(io) ...</code>, but <code>eof(io)</code>
returns true when all the currently available lines have been read, so
to wait for more lines we would need an additional polling loop.<br />
<br />
</span></span></p>
<p>Another relevant aspect is transfer direction. Does a stream support
input?, output? or both? Most operating systems have a mixture of
bi-directional and uni-directional stream APIs.<span
class="sidenote-wrapper"><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle"/><span
class="sidenote">In some places Unix uses bi-directional streams.
e.g. files can be opened for reading and writing and sockets are usually
bi-directional. However, in many instances Unix uses distinct streams
for input and output. e.g. STDIN and STDOUT are distinct streams and
<code>pipe(2)</code> returns the “read end” and the “write end” of a
one-way pipe. Even where Unix supports bi-directional streams there are
cases where is is best to use two seperate streams for a particular
resource. e.g. to eliminate ambiguity in <code>poll(2)</code>
events.<br />
<br />
</span></span> Streams that are both readable and writable can be
confusing<span
class="sidenote-wrapper"><label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle"/><span
class="sidenote">e.g. What does <code>close(::IO)</code> do for a
bi-directional stream? (<a
href="https://github.com/JuliaLang/julia/issues/41995">41995</a>) Does
<code>Base.position(io)</code> refer to the input position or the output
position?<br />
<br />
</span></span> and difficult to implement correctly.<span
class="sidenote-wrapper"><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle"/><span
class="sidenote"><a
href="https://github.com/JuliaLang/julia/issues/39727">39727</a>
“Bi-directional IOStream seems to mix input and output”<br />
<br />
</span></span> It seems simpler and more general to use a model where
all streams are uni-directional.</p>
<p><strong>Direction:</strong> In general a stream supports input, or
output but not both. The <a href="#transfer-direction-trait">Transfer
Direction Trait</a> specifies which.<span
class="sidenote-wrapper"><label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle"/><span
class="sidenote">Note the <a href="#transfer-direction-trait">Transfer
Direction Trait</a> supports direction: <code>Exchange</code> for
interfaces like <a
href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
where data must be synchronously exchanged between a buffer and the
interface (i.e. input and output are not separable). This can be though
of as having exactly the same behavior as direction <code>Out</code>
except that incoming data appears in the output buffer after each output
transfer.<br />
<br />
</span></span> This restriction simplifies the specification of things
like <code>position</code>, <code>mark</code> and <code>seek</code>. It
also avoids the need for distinctions like <code>close</code> vs
<code>closewrite</code> (<a
href="https://github.com/JuliaLang/julia/issues/41995">41995</a>).
Bi-directonal streams can easily be added by a wrapper layer that
combines two streams e.g. see DuplexIO.jl.</p>
<h3 id="atomicity-of-transfers">Atomicity of Transfers</h3>
<p>FIXME - byte transfers always atomic - multi-byte items - return zero
if bytesavailable &lt; ioelsize ? - if Unknown Availability try a
transfer and error if not enough bytes - include the partial bytes in
the exception object - warning with suggestion to wrap with a buffer</p>
<h3 id="generic-code-and-dependance-on-traits">Generic Code and
Dependance on Traits</h3>
<p>FIXME - Generic code may rely on e.g. Low Transfer Cost, or Known
Transfer Size - Generic code should have assertions for these traits. -
Generic code could promote streams to have required traits as needed
(i.e. wrap with buffered stream).</p>
<h3 id="methods-of-base-functions-for-streams">Methods of Base Functions
for Streams</h3>
<p>The IOTraits interface avoids defining methods of Base functions that
have incomplete or ambiguous specifications. It also avoids local
function names names that shadow Base functions. In some cases a similar
function name with an underscore prefix is used to differentiate local
functions.</p>
<p>The IOTraits interface defines methods for the following well defined
Base functions (the default methods for the generic <code>Stream</code>
type dispatch to a wrapped delegate stream if the
<code>StreamDelegation</code> trait is in effect).</p>
<div class="sourceCode" id="cb5" data-startFrom="320"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 319;"><span id="cb5-320"><a href="#cb5-320"></a><span class="bu">Base</span>.<span class="fu">isopen</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">isopen</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span> <span class="cn">false</span></span>
<span id="cb5-321"><a href="#cb5-321"></a></span>
<span id="cb5-322"><a href="#cb5-322"></a><span class="bu">Base</span>.<span class="fu">close</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">close</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span> <span class="cn">nothing</span></span>
<span id="cb5-323"><a href="#cb5-323"></a></span>
<span id="cb5-324"><a href="#cb5-324"></a><span class="bu">Base</span>.<span class="fu">wait</span>(s<span class="op">::</span><span class="dt">Stream</span>; deadline<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ?</span>
<span id="cb5-325"><a href="#cb5-325"></a>                                     <span class="fu">wait</span>(<span class="fu">unwrap</span>(s); deadline) <span class="op">:</span></span>
<span id="cb5-326"><a href="#cb5-326"></a>                                     <span class="fu">_wait</span>(s, <span class="fu">WaitingMechanism</span>(s); deadline)</span>
<span id="cb5-327"><a href="#cb5-327"></a></span>
<span id="cb5-328"><a href="#cb5-328"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">bytesavailable</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb5-329"><a href="#cb5-329"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb5-330"><a href="#cb5-330"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb5-331"><a href="#cb5-331"></a>    <span class="fu">_bytesavailable</span>(s, <span class="fu">Availability</span>(s), <span class="fu">TransferSize</span>(s))</span>
<span id="cb5-332"><a href="#cb5-332"></a><span class="kw">end</span></span>
<span id="cb5-333"><a href="#cb5-333"></a></span>
<span id="cb5-334"><a href="#cb5-334"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">length</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb5-335"><a href="#cb5-335"></a>    <span class="pp">@require</span> <span class="fu">TotalSize</span>(s) isa KnownTotalSize</span>
<span id="cb5-336"><a href="#cb5-336"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb5-337"><a href="#cb5-337"></a>    <span class="fu">_length</span>(s, <span class="fu">TotalSizeMechanism</span>(s))</span>
<span id="cb5-338"><a href="#cb5-338"></a><span class="kw">end</span></span>
<span id="cb5-339"><a href="#cb5-339"></a></span>
<span id="cb5-340"><a href="#cb5-340"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readline</span>(s<span class="op">::</span><span class="dt">Stream</span>; timeout<span class="op">=</span><span class="cn">Inf</span>, keep<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb5-341"><a href="#cb5-341"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb5-342"><a href="#cb5-342"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb5-343"><a href="#cb5-343"></a>    <span class="fu">_readline</span>(s, <span class="fu">ReadFragmentation</span>(s); timeout, keep)</span>
<span id="cb5-344"><a href="#cb5-344"></a><span class="kw">end</span></span>
<span id="cb5-345"><a href="#cb5-345"></a></span>
<span id="cb5-346"><a href="#cb5-346"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">peek</span>(s<span class="op">::</span><span class="dt">Stream</span>, <span class="op">::</span><span class="dt">Type{T}</span>; timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="kw">where</span> T</span>
<span id="cb5-347"><a href="#cb5-347"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb5-348"><a href="#cb5-348"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb5-349"><a href="#cb5-349"></a>    <span class="fu">_peek</span>(s, <span class="fu">PeekSupport</span>(s), T; timeout)</span>
<span id="cb5-350"><a href="#cb5-350"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="stream-delegation-wrappers">Stream Delegation Wrappers</h3>
<p>The StreamDelegation trait allows a Stream subtype to delegate most
method calls to a wrapped substream while redefining other methods as
needed.</p>
<p>Wrappers are used to augment low level stream drivers with features
like buffering or defragmentation. Wrappers are also used to make
<code>Stream</code> objects compatible with <code>Base.IO</code>.</p>
<p><code>StreamDelegation(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>NotDelegated()</code></td>
<td style="text-align: left;">This stream has its own stream interface
methods.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DelegatedToSubStream()</code></td>
<td style="text-align: left;">This stream is a proxy for a sub
stream.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb6" data-startFrom="371"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 370;"><span id="cb6-371"><a href="#cb6-371"></a><span class="kw">abstract type</span> StreamDelegation <span class="kw">end</span></span>
<span id="cb6-372"><a href="#cb6-372"></a><span class="kw">struct</span> NotDelegated <span class="op">&lt;:</span><span class="dt"> StreamDelegation </span><span class="kw">end</span></span>
<span id="cb6-373"><a href="#cb6-373"></a><span class="kw">struct</span> DelegatedToSubStream <span class="op">&lt;:</span><span class="dt"> StreamDelegation </span><span class="kw">end</span></span>
<span id="cb6-374"><a href="#cb6-374"></a><span class="fu">StreamDelegation</span>(s) <span class="op">=</span> <span class="fu">StreamDelegation</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb6-375"><a href="#cb6-375"></a><span class="fu">StreamDelegation</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">NotDelegated</span>()</span>
<span id="cb6-376"><a href="#cb6-376"></a></span>
<span id="cb6-377"><a href="#cb6-377"></a><span class="fu">is_proxy</span>(s) <span class="op">=</span> <span class="fu">StreamDelegation</span>(s) <span class="op">!=</span> <span class="fu">NotDelegated</span>()</span></code></pre></div>
<p><code>unwrap(stream)</code> – Retrieves the underlying stream that is
wrapped by a proxy stream.</p>
<div class="sourceCode" id="cb7" data-startFrom="384"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 383;"><span id="cb7-384"><a href="#cb7-384"></a><span class="fu">unwrap</span>(s) <span class="op">=</span> <span class="fu">unwrap</span>(s, <span class="fu">StreamDelegation</span>(s))</span>
<span id="cb7-385"><a href="#cb7-385"></a><span class="fu">unwrap</span>(s, <span class="op">::</span><span class="dt">NotDelegated</span>) <span class="op">=</span> s</span>
<span id="cb7-386"><a href="#cb7-386"></a><span class="fu">unwrap</span>(s, <span class="op">::</span><span class="dt">DelegatedToSubStream</span>) <span class="op">=</span> s.stream</span>
<span id="cb7-387"><a href="#cb7-387"></a><span class="fu">unwrap</span>(T<span class="op">::</span><span class="dt">Type</span>, <span class="op">::</span><span class="dt">DelegatedToSubStream</span>) <span class="op">=</span> <span class="fu">fieldtype</span>(T, <span class="op">:</span>stream)</span></code></pre></div>
<h2 id="unfiled-notes">Unfiled Notes</h2>
<ul>
<li>How could <code>Base.isready</code> apply to IO? It’s definition is
nice and concise: “Determine whether a Channel has a value stored to it.
Returns immediately, does not block.”</li>
<li>Build <code>ReadlineMux &lt;: IOMux</code> and
<code>ReadlineDemux &lt;: IODemux</code> as an example of a traits aware
IO mechanism. e.g. merge multiple streams onto a single IO with a
mux/demux header.</li>
<li>Consider traits to select special purpose IO functions where
appropriate: <code>pread</code>, <code>readv</code>,
<code>writev</code>, <code>sendfile</code> ?</li>
<li>Consider using traits to identify inefficient access patterns.
<ul>
<li>Keep stats per file
<ul>
<li>No. tranfers, No. bytes, No. seeks.</li>
<li>Time between transfers (rolling avg?)</li>
<li>Warn if stats don’t align with traits</li>
<li>e.g. large number of small reads for high per-call overhead IO.</li>
</ul></li>
</ul></li>
<li>Consider trait to characterise access speed:
<ul>
<li>fast mmap - ok for small and large requests</li>
<li>fast local - but slow for small requests</li>
<li>fast network - but slow for small requests</li>
<li>slow serial - no problem with small requests</li>
</ul></li>
<li>content:
<ul>
<li>Has bytes</li>
<li>no content (links)</li>
<li>directory</li>
</ul></li>
<li>writing
<ul>
<li>needs flush?</li>
<li>efficient to write one byte at a time?</li>
<li>natural page size?</li>
</ul></li>
</ul>
<h1 id="transfer-direction-trait">Transfer Direction Trait</h1>
<p>The <code>TransferDirection</code> trait describes the direction of
data transfer supported by a stream.</p>
<p><code>TransferDirection(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>In()</code></td>
<td style="text-align: left;">data is “read” from the <code>IO</code>
into a buffer.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Out()</code></td>
<td style="text-align: left;">data from a buffer is “written” to the
<code>IO</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Exchange()</code></td>
<td style="text-align: left;">data is exchanged between the
<code>IO</code> and a buffer.<span
class="sidenote-wrapper"><label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle"/><span
class="sidenote">e.g. a <a
href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface receives a byte for every byte transmitted.<br />
<br />
</span></span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb8" data-startFrom="444"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 443;"><span id="cb8-444"><a href="#cb8-444"></a><span class="kw">abstract type</span> TransferDirection <span class="kw">end</span></span>
<span id="cb8-445"><a href="#cb8-445"></a><span class="kw">struct</span> In <span class="op">&lt;:</span><span class="dt"> TransferDirection </span><span class="kw">end</span></span>
<span id="cb8-446"><a href="#cb8-446"></a><span class="kw">struct</span> Out <span class="op">&lt;:</span><span class="dt"> TransferDirection </span><span class="kw">end</span></span>
<span id="cb8-447"><a href="#cb8-447"></a><span class="kw">struct</span> Exchange <span class="op">&lt;:</span><span class="dt"> TransferDirection </span><span class="kw">end</span></span>
<span id="cb8-448"><a href="#cb8-448"></a><span class="kw">const</span> AnyDirection <span class="op">=</span> TransferDirection</span>
<span id="cb8-449"><a href="#cb8-449"></a><span class="fu">TransferDirection</span>(s) <span class="op">=</span> <span class="fu">TransferDirection</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb8-450"><a href="#cb8-450"></a><span class="fu">TransferDirection</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferDirection</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb8-451"><a href="#cb8-451"></a>                                           <span class="cn">nothing</span></span>
<span id="cb8-452"><a href="#cb8-452"></a></span>
<span id="cb8-453"><a href="#cb8-453"></a><span class="fu">is_input</span>(s) <span class="op">=</span> <span class="fu">TransferDirection</span>(s) <span class="op">!=</span> <span class="fu">Out</span>()</span>
<span id="cb8-454"><a href="#cb8-454"></a><span class="fu">is_output</span>(s) <span class="op">=</span> <span class="fu">TransferDirection</span>(s) <span class="op">!=</span> <span class="fu">In</span>()</span>
<span id="cb8-455"><a href="#cb8-455"></a></span>
<span id="cb8-456"><a href="#cb8-456"></a><span class="fu">verb</span>(<span class="op">::</span><span class="dt">In</span>) <span class="op">=</span> <span class="st">&quot;from&quot;</span></span>
<span id="cb8-457"><a href="#cb8-457"></a><span class="fu">verb</span>(<span class="op">::</span><span class="dt">Out</span>) <span class="op">=</span> <span class="st">&quot;to&quot;</span></span></code></pre></div>
<p>The constructor
<code>BaseIOStream(::Base.IO) -&gt; IOTraits.Stream</code> creates a
Stream compatible wrapper around a Base.IO.</p>
<div class="sourceCode" id="cb9" data-startFrom="464"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 463;"><span id="cb9-464"><a href="#cb9-464"></a><span class="kw">struct</span> BaseIOStream{T<span class="op">&lt;:</span><span class="dt">Base.IO</span>,D<span class="op">&lt;:</span><span class="dt">TransferDirection</span>} <span class="op">&lt;:</span><span class="dt"> Stream</span></span>
<span id="cb9-465"><a href="#cb9-465"></a>    io<span class="op">::</span><span class="dt">T</span></span>
<span id="cb9-466"><a href="#cb9-466"></a><span class="kw">end</span></span>
<span id="cb9-467"><a href="#cb9-467"></a></span>
<span id="cb9-468"><a href="#cb9-468"></a><span class="fu">TransferDirection</span>(<span class="op">::</span><span class="dt">Type{BaseIOStream{T, D}}</span>) <span class="kw">where</span> {T, D} <span class="op">=</span> <span class="fu">D</span>()</span>
<span id="cb9-469"><a href="#cb9-469"></a></span>
<span id="cb9-470"><a href="#cb9-470"></a><span class="bu">Base</span>.<span class="fu">isopen</span>(s<span class="op">::</span><span class="dt">BaseIOStream</span>) <span class="op">=</span> <span class="fu">isopen</span>(s.io)</span></code></pre></div>
<h1 id="io-indexing-trait">IO Indexing Trait</h1>
<p>Is indexing (e.g. <code>pread(2)</code>) supported?</p>
<div class="sourceCode" id="cb10" data-startFrom="478"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 477;"><span id="cb10-478"><a href="#cb10-478"></a><span class="kw">abstract type</span> StreamIndexing <span class="kw">end</span></span>
<span id="cb10-479"><a href="#cb10-479"></a><span class="kw">struct</span> NotIndexable <span class="op">&lt;:</span><span class="dt"> StreamIndexing </span><span class="kw">end</span></span>
<span id="cb10-480"><a href="#cb10-480"></a><span class="kw">struct</span> IndexableIO <span class="op">&lt;:</span><span class="dt"> StreamIndexing </span><span class="kw">end</span></span>
<span id="cb10-481"><a href="#cb10-481"></a><span class="fu">StreamIndexing</span>(s) <span class="op">=</span> <span class="fu">StreamIndexing</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb10-482"><a href="#cb10-482"></a><span class="fu">StreamIndexing</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">StreamIndexing</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb10-483"><a href="#cb10-483"></a>                                        NotIndexable</span>
<span id="cb10-484"><a href="#cb10-484"></a></span>
<span id="cb10-485"><a href="#cb10-485"></a><span class="fu">stream_is_indexable</span>(s) <span class="op">=</span> <span class="fu">StreamIndexing</span>(s) <span class="op">==</span> <span class="fu">IndexableIO</span>()</span>
<span id="cb10-486"><a href="#cb10-486"></a></span>
<span id="cb10-487"><a href="#cb10-487"></a></span>
<span id="cb10-488"><a href="#cb10-488"></a><span class="fu">ioeltype</span>(s) <span class="op">=</span> <span class="fu">isabstracttype</span>(<span class="fu">eltype</span>(s)) ? <span class="dt">UInt8</span> <span class="op">:</span> <span class="fu">eltype</span>(s)</span>
<span id="cb10-489"><a href="#cb10-489"></a><span class="pp">@selfdoc</span> <span class="fu">ioelsize</span>(s) <span class="op">=</span> <span class="fu">sizeof</span>(<span class="fu">ioeltype</span>(s))</span></code></pre></div>
<h1 id="data-transfer-function">Data Transfer Function</h1>
<pre><code>transfer(stream, buffer, [n]; start=1, deadline=Inf) -&gt; n_transfered</code></pre>
<p>Transfer at most <code>n</code> items between <code>stream</code> and
<code>buffer</code>.<span
class="sidenote-wrapper"><label for="sn-12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-12" class="margin-toggle"/><span
class="sidenote">If <code>n</code> is not specified then the number of
items transferred depends on the number of items available and the
capacity of <code>buffer</code>.<br />
<br />
</span></span> Return the number of items transferred.</p>
<p>If no items are immediately available, wait until
<code>time() &gt; deadline</code> for at least one item to be
transferred.<span
class="sidenote-wrapper"><label for="sn-13" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-13" class="margin-toggle"/><span
class="sidenote">The <a
href="#event-notification-mechanism-trait"><code>WaitingMechanism</code></a>
trait determines what polling mechamism is used.<br />
<br />
</span></span> If the optional <code>timeout=</code> argument is
provided then the deadline is <code>time() + timeout</code>.</p>
<p><code>start</code> specifies a buffer index at which the transfer
begins. If <code>stream</code> is indexable then <code>start</code> can
be a tuple of two indexes:
<code>(stream_start_byte_index, buffer_start_index)</code>.</p>
<p>The direction of transfer depends on
<code>TransferDirection(stream) -&gt;</code> (<code>In</code>,
<code>Out</code> or <code>Exchange</code>).</p>
<p>The type of items transferred depends on
<code>ioeltype(buffer)</code>.<span
class="sidenote-wrapper"><label for="sn-14" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-14" class="margin-toggle"/><span
class="sidenote">By default <code>ioeltype(x) = eltype(x)</code>.<br />
<br />
</span></span></p>
<p>The <code>buffer</code> can be an <code>AbstractArray</code>, an
<code>AbstractChannel</code>, a <code>URI</code>, a
<code>Base.IO</code>, or another <code>Stream</code>. Or, the
<code>buffer</code> can be any collection that implements the Iteration
Interface, the Indexing Interface, the AbstractChannel interface, or the
<code>push!</code>/<code>pop!</code> interface.<span
class="sidenote-wrapper"><label for="sn-15" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-15" class="margin-toggle"/><span
class="sidenote">In some cases it is necessary to define a method of <a
href="#buffer-interface-traits"><code>ToBufferInterface</code> or
<code>FromBufferInterface</code></a> to specify the interface to use for
a particular buffer type (e.g. if a buffer implements more than one of
the supported interfaces). Defining these trait methods can also help to
ensure that the most efficient interface is used for a particular buffer
type.<br />
<br />
</span></span></p>
<p>If either the <code>stream</code> or the <code>buffer</code> is a
<code>URI</code> then items are transferred to (or from) the identified
resource. A transfer to a <code>URI</code> creates a new resource or
replaces the resource (i.e. HTTP PUT semantics).</p>
<div class="sourceCode" id="cb12" data-startFrom="540"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 539;"><span id="cb12-540"><a href="#cb12-540"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer</span>(stream, buf, n<span class="op">::</span><span class="dt">Union{Integer,Missing}</span>=<span class="cn">missing</span>;</span>
<span id="cb12-541"><a href="#cb12-541"></a>                  start<span class="op">::</span><span class="dt">Union{Integer, NTuple{2,Integer}}</span>=<span class="fu">UInt</span>(<span class="fl">1</span>),</span>
<span id="cb12-542"><a href="#cb12-542"></a>                  timeout<span class="op">=</span><span class="cn">Inf</span>,</span>
<span id="cb12-543"><a href="#cb12-543"></a>                  deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb12-544"><a href="#cb12-544"></a></span>
<span id="cb12-545"><a href="#cb12-545"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(stream)</span>
<span id="cb12-546"><a href="#cb12-546"></a>    <span class="pp">@require</span> <span class="fu">ismissing</span>(n) <span class="op">||</span> n <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb12-547"><a href="#cb12-547"></a>    <span class="pp">@require</span> <span class="fu">all</span>(start <span class="op">.&gt;</span> <span class="fl">0</span>)</span>
<span id="cb12-548"><a href="#cb12-548"></a>    <span class="cf">if</span> timeout <span class="op">!=</span> <span class="cn">Inf</span></span>
<span id="cb12-549"><a href="#cb12-549"></a>        deadline <span class="op">=</span> <span class="fu">time</span>() <span class="op">+</span> timeout</span>
<span id="cb12-550"><a href="#cb12-550"></a>    <span class="cf">end</span></span>
<span id="cb12-551"><a href="#cb12-551"></a>    n <span class="op">=</span> <span class="fu">transfer</span>(stream, buf, n, start, <span class="fu">Float64</span>(deadline))</span>
<span id="cb12-552"><a href="#cb12-552"></a>    <span class="fu">transfer_complete</span>(stream, buf, n)</span>
<span id="cb12-553"><a href="#cb12-553"></a>    <span class="pp">@ensure</span> n isa <span class="dt">UInt</span></span>
<span id="cb12-554"><a href="#cb12-554"></a>    <span class="pp">@db</span> <span class="cf">return</span> n</span>
<span id="cb12-555"><a href="#cb12-555"></a><span class="kw">end</span></span></code></pre></div>
<p><code>transfer_complete</code> is called at the end of the top-level
<code>transfer</code> method. A single call to the top-level
<code>tansfer</code> method may result in many calls to low level driver
methods. e.g. to transfer every item in a collection. The
<code>transfer_complete</code> hook can be used, for example, to flush
an output buffer at end of a transfer.</p>
<div class="sourceCode" id="cb13" data-startFrom="565"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 564;"><span id="cb13-565"><a href="#cb13-565"></a><span class="fu">transfer_complete</span>(stream, buf, n) <span class="op">=</span> <span class="cn">nothing</span></span></code></pre></div>
<h3 id="transfera-b"><code>transfer(a =&gt; b)</code></h3>
<pre><code>transfer(stream =&gt; buffer, [n]; start=(1 =&gt; 1), kw...) -&gt; n_transfered
transfer(buffer =&gt; stream, [n]; start=(1 =&gt; 1), kw...) -&gt; n_transfered</code></pre>
<p><code>stream</code> and <code>buffer</code> can be passed to
<code>transfer</code> as a pair. <code>In</code> streams must be on the
left. <code>Out</code> streams must be on the right.</p>
<div class="sourceCode" id="cb15" data-startFrom="578"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 577;"><span id="cb15-578"><a href="#cb15-578"></a><span class="kw">function</span> <span class="fu">transfer</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Stream, &lt;:Any}</span>, a<span class="op">...</span>; start<span class="op">=</span>(<span class="fl">1</span> <span class="op">=&gt;</span> <span class="fl">1</span>), kw<span class="op">...</span>)</span>
<span id="cb15-579"><a href="#cb15-579"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">1</span>]) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb15-580"><a href="#cb15-580"></a>    <span class="cf">if</span> start isa <span class="dt">Pair</span></span>
<span id="cb15-581"><a href="#cb15-581"></a>        start <span class="op">=</span> (start[<span class="fl">1</span>], start[<span class="fl">2</span>])</span>
<span id="cb15-582"><a href="#cb15-582"></a>    <span class="cf">end</span></span>
<span id="cb15-583"><a href="#cb15-583"></a>    <span class="fu">transfer</span>(t[<span class="fl">1</span>], t[<span class="fl">2</span>], a<span class="op">...</span>; start, kw<span class="op">...</span>)</span>
<span id="cb15-584"><a href="#cb15-584"></a><span class="kw">end</span></span>
<span id="cb15-585"><a href="#cb15-585"></a></span>
<span id="cb15-586"><a href="#cb15-586"></a><span class="kw">function</span> <span class="fu">transfer</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Any,&lt;:Stream}</span>, a<span class="op">...</span>; start<span class="op">=</span>(<span class="fl">1</span> <span class="op">=&gt;</span> <span class="fl">1</span>), kw<span class="op">...</span>)</span>
<span id="cb15-587"><a href="#cb15-587"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">2</span>]) <span class="op">==</span> <span class="fu">Out</span>()</span>
<span id="cb15-588"><a href="#cb15-588"></a>    <span class="cf">if</span> start isa <span class="dt">Pair</span></span>
<span id="cb15-589"><a href="#cb15-589"></a>        start <span class="op">=</span> (start[<span class="fl">2</span>], start[<span class="fl">1</span>])</span>
<span id="cb15-590"><a href="#cb15-590"></a>    <span class="cf">end</span></span>
<span id="cb15-591"><a href="#cb15-591"></a>    <span class="fu">transfer</span>(t[<span class="fl">2</span>], t[<span class="fl">1</span>], a<span class="op">...</span>; start<span class="op">=</span>start, kw<span class="op">...</span>)</span>
<span id="cb15-592"><a href="#cb15-592"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="waiting-for-the-deadline">Waiting for the Deadline</h2>
<p>The specification for <code>transfer</code> says: If no items are
immediately available, wait until <code>time() &gt; deadline</code> for
at least one item to be transferred.</p>
<p>The method below starts by simply attempting the transfer. This
avoids the overhead of locking and measuring the current time. If the
initial transfer attempt yields no data, the
<code>wait_for_transfer</code> method is selected based on Waiting
Mechanism trait.</p>
<p>If the buffer elements are larger than one byte and the stream has
Unknown Availability then <code>transfer_available</code> can end up
with a partial item in the buffer. In this situation a second attempt is
needed to transfer the missing bytes. A TimeoutStream wrapper is used to
ensure that the second transfer adheres to the specified deadline.</p>
<div class="sourceCode" id="cb16" data-startFrom="614"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 613;"><span id="cb16-614"><a href="#cb16-614"></a><span class="kw">function</span> <span class="fu">transfer</span>(stream, buffer, n, start, deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb16-615"><a href="#cb16-615"></a></span>
<span id="cb16-616"><a href="#cb16-616"></a>    <span class="cf">if</span> <span class="fu">Availability</span>(stream) <span class="op">==</span> <span class="fu">UnknownAvailability</span>() <span class="op">&amp;&amp;</span></span>
<span id="cb16-617"><a href="#cb16-617"></a>    <span class="fu">ioelsize</span>(buffer) <span class="op">!=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span></span>
<span id="cb16-618"><a href="#cb16-618"></a>    deadline <span class="op">!=</span> <span class="cn">Inf</span></span>
<span id="cb16-619"><a href="#cb16-619"></a>        stream <span class="op">=</span> <span class="fu">timeout_stream</span>(stream; deadline)</span>
<span id="cb16-620"><a href="#cb16-620"></a>    <span class="cf">end</span></span>
<span id="cb16-621"><a href="#cb16-621"></a></span>
<span id="cb16-622"><a href="#cb16-622"></a>    r <span class="op">=</span> <span class="fu">transfer_available</span>(stream, buffer, n, start)</span>
<span id="cb16-623"><a href="#cb16-623"></a>    <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">||</span> <span class="fu">iszero</span>(deadline)</span>
<span id="cb16-624"><a href="#cb16-624"></a>        <span class="cf">return</span> r</span>
<span id="cb16-625"><a href="#cb16-625"></a>    <span class="cf">end</span></span>
<span id="cb16-626"><a href="#cb16-626"></a>    <span class="fu">wait_for_transfer</span>(stream, <span class="fu">WaitingMechanism</span>(stream),</span>
<span id="cb16-627"><a href="#cb16-627"></a>                      buffer, n, start, deadline)</span>
<span id="cb16-628"><a href="#cb16-628"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="waiting-mechanism-trait">Waiting Mechanism Trait</h1>
<div class="sourceCode" id="cb17" data-startFrom="634"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 633;"><span id="cb17-634"><a href="#cb17-634"></a><span class="kw">abstract type</span> WaitingMechanism <span class="kw">end</span></span>
<span id="cb17-635"><a href="#cb17-635"></a><span class="kw">struct</span> WaitBySleeping     <span class="op">&lt;:</span><span class="dt"> WaitingMechanism </span><span class="kw">end</span></span>
<span id="cb17-636"><a href="#cb17-636"></a><span class="kw">struct</span> WaitUsingPosixPoll <span class="op">&lt;:</span><span class="dt"> WaitingMechanism </span><span class="kw">end</span></span>
<span id="cb17-637"><a href="#cb17-637"></a><span class="kw">struct</span> WaitUsingEPoll     <span class="op">&lt;:</span><span class="dt"> WaitingMechanism </span><span class="kw">end</span></span>
<span id="cb17-638"><a href="#cb17-638"></a><span class="kw">struct</span> WaitUsingPidFD     <span class="op">&lt;:</span><span class="dt"> WaitingMechanism </span><span class="kw">end</span></span>
<span id="cb17-639"><a href="#cb17-639"></a><span class="kw">struct</span> WaitUsingKQueue    <span class="op">&lt;:</span><span class="dt"> WaitingMechanism </span><span class="kw">end</span></span></code></pre></div>
<p>The <code>WaitingMechanism</code> trait describes ways of waiting for
OS resources that are not immediately available. e.g. when
<code>read(2)</code> returns <code>EAGAIN</code>
(<code>EWOULDBLOCK</code>), or when <code>waitpid(2)</code> returns
<code>0</code>.</p>
<p>Resource types, <code>R</code>, that have an applicable
<code>WaitingMechanism</code>, <code>T</code>, define a method of
<code>Base.wait(::T, r::R)</code>. <code>WaitBySleeping</code> is the
default.<span
class="sidenote-wrapper"><label for="sn-16" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-16" class="margin-toggle"/><span
class="sidenote">Sleeping may be the most efficient mechanism for small
systems with simple IO requirements, for large systems where throughput
is more important than latency, or for systems that simply do not spend
a lot of time waiting for IO. Sleeping allows other Julia tasks to run
immediately, whereas the other polling mechanisms all have some amount
of book-keeping and system call overhead.<br />
<br />
</span></span></p>
<p>If a <code>WaitingMechanism</code>, <code>T</code>, is not available
on a particular OS then <code>Base.isvalid(::T)</code> should be defined
to return <code>false</code>.<span
class="sidenote-wrapper"><label for="sn-17" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-17" class="margin-toggle"/><span
class="sidenote">⚠️ Consider Linux AIO <code>io_getevents</code> for
disk io?<br />
<br />
</span></span></p>
<p><code>WaitingMechanism(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Waiting Mechanism</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>WaitBySleeping</code></td>
<td style="text-align: left;">Wait using a dumb retry/sleep loop.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>WaitUsingPosixPoll</code></td>
<td style="text-align: left;">Wait using the POSIX <code>poll</code>
mechanism. Wait for activity on a set of file descriptors. Applicable to
FIFO pipes, sockets and character devices (but not local files). See <a
href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll(2)</code></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>WaitUsingEPoll</code></td>
<td style="text-align: left;">Wait using the Linux <code>epoll</code>
mechanism. Like <code>poll</code> but scales better for workloads with a
large number of waiting streams. See <a
href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code>epoll(7)</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>WaitUsingKQueue</code></td>
<td style="text-align: left;">Wait using the BSD <code>kqueue</code>
mechanism. Like <code>epoll</code> but can also wait for files,
processes, signals etc. See <a
href="https://www.freebsd.org/cgi/man.cgi?kqueue"><code>kqueue(2)</code></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>WaitUsingPidFD()</code></td>
<td style="text-align: left;">Wait for process termination using the
Linux <code>pidfd</code> mechanism. A <code>pidfd</code> is a special
process monitoring file descriptor that can in turn be monitored by
<code>poll</code> or <code>epoll</code>. See <a
href="http://man7.org/linux/man-pages/man2/pidfd_open.2.html"><code>pidfd_open(2)</code></a></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb18" data-startFrom="695"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 694;"><span id="cb18-695"><a href="#cb18-695"></a><span class="fu">WaitingMechanism</span>(x) <span class="op">=</span> <span class="fu">WaitingMechanism</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb18-696"><a href="#cb18-696"></a><span class="fu">WaitingMechanism</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">WaitingMechanism</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb18-697"><a href="#cb18-697"></a>                                          <span class="fu">WaitBySleeping</span>()</span>
<span id="cb18-698"><a href="#cb18-698"></a></span>
<span id="cb18-699"><a href="#cb18-699"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitingMechanism</span>) <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb18-700"><a href="#cb18-700"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitUsingEPoll</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">islinux</span>()</span>
<span id="cb18-701"><a href="#cb18-701"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitUsingPidFD</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">islinux</span>()</span>
<span id="cb18-702"><a href="#cb18-702"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitUsingKQueue</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">isbsd</span>() <span class="op">&amp;&amp;</span> <span class="cn">false</span> <span class="co"># not yet implemented.</span></span>
<span id="cb18-703"><a href="#cb18-703"></a></span>
<span id="cb18-704"><a href="#cb18-704"></a><span class="fu">firstvalid</span>(x, xs<span class="op">...</span>) <span class="op">=</span> <span class="fu">isvalid</span>(x) ? x <span class="op">:</span> <span class="fu">firstvalid</span>(xs<span class="op">...</span>)</span>
<span id="cb18-705"><a href="#cb18-705"></a></span>
<span id="cb18-706"><a href="#cb18-706"></a><span class="kw">const</span> default_poll_mechanism <span class="op">=</span> <span class="fu">firstvalid</span>(<span class="fu">WaitUsingKQueue</span>(),</span>
<span id="cb18-707"><a href="#cb18-707"></a>                                          <span class="fu">WaitUsingEPoll</span>(),</span>
<span id="cb18-708"><a href="#cb18-708"></a>                                          <span class="fu">WaitUsingPosixPoll</span>(),</span>
<span id="cb18-709"><a href="#cb18-709"></a>                                          <span class="fu">WaitBySleeping</span>())</span>
<span id="cb18-710"><a href="#cb18-710"></a></span>
<span id="cb18-711"><a href="#cb18-711"></a><span class="fu">_wait</span>(x, <span class="op">::</span><span class="dt">WaitBySleeping</span>; deadline<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span> <span class="fu">sleep</span>(<span class="fl">0.1</span>)</span></code></pre></div>
<h2 id="preferred-polling-mechanism">Preferred Polling Mechanism</h2>
<pre><code>set_poll_mechanism(name)</code></pre>
<p>Configure the preferred event polling mechanism: “kqueue”, “epoll”,
“poll”, or “sleep”.<span
class="sidenote-wrapper"><label for="sn-18" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-18" class="margin-toggle"/><span
class="sidenote">This setting applies only to
<code>poll(2)</code>-compatible file descriptors (i.e. it does not apply
to local disk files).<br />
<br />
</span></span> This setting is persistently stored through <a
href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p>
<p>By default, IOTraits will try to choose the best available mechanism
(see <code>default_poll_mechanism</code>).</p>
<p>To find out what mechanism is used for a particular <code>FD</code>
call: <code>WaitingMechanism(fd)</code></p>
<div class="sourceCode" id="cb20" data-startFrom="735"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 734;"><span id="cb20-735"><a href="#cb20-735"></a><span class="kw">function</span> <span class="fu">set_poll_mechanism</span>(x)</span>
<span id="cb20-736"><a href="#cb20-736"></a>    <span class="pp">@require</span> <span class="fu">poll_mechanism</span>(x) <span class="op">!=</span> <span class="cn">nothing</span></span>
<span id="cb20-737"><a href="#cb20-737"></a>    <span class="pp">@require</span> <span class="fu">isvalid</span>(<span class="fu">poll_mechanism</span>(x))</span>
<span id="cb20-738"><a href="#cb20-738"></a>    <span class="pp">@set_preferences</span>!(<span class="st">&quot;waiting_mechanism&quot;</span> <span class="op">=&gt;</span> x)</span>
<span id="cb20-739"><a href="#cb20-739"></a>    <span class="pp">@warn</span> <span class="st">&quot;Preferred IOTraits.WaitingMechanism set to </span><span class="sc">$</span>(<span class="fu">poll_mechanism</span>(x))<span class="st">.&quot;</span> <span class="op">*</span></span>
<span id="cb20-740"><a href="#cb20-740"></a>          <span class="st">&quot;UnixIO must be recompiled for this setting to take effect.&quot;</span></span>
<span id="cb20-741"><a href="#cb20-741"></a><span class="kw">end</span></span>
<span id="cb20-742"><a href="#cb20-742"></a></span>
<span id="cb20-743"><a href="#cb20-743"></a><span class="fu">poll_mechanism</span>(name) <span class="op">=</span> name <span class="op">==</span> <span class="st">&quot;kqueue&quot;</span> ? <span class="fu">WaitUsingKQueue</span>() <span class="op">:</span></span>
<span id="cb20-744"><a href="#cb20-744"></a>                       name <span class="op">==</span> <span class="st">&quot;epoll&quot;</span>  ? <span class="fu">WaitUsingEPoll</span>() <span class="op">:</span></span>
<span id="cb20-745"><a href="#cb20-745"></a>                       name <span class="op">==</span> <span class="st">&quot;poll&quot;</span>   ? <span class="fu">WaitUsingPosixPoll</span>() <span class="op">:</span></span>
<span id="cb20-746"><a href="#cb20-746"></a>                       name <span class="op">==</span> <span class="st">&quot;sleep&quot;</span>  ? <span class="fu">WaitBySleeping</span>() <span class="op">:</span></span>
<span id="cb20-747"><a href="#cb20-747"></a>                                          default_poll_mechanism</span>
<span id="cb20-748"><a href="#cb20-748"></a></span>
<span id="cb20-749"><a href="#cb20-749"></a><span class="kw">const</span> preferred_poll_mechanism <span class="op">=</span></span>
<span id="cb20-750"><a href="#cb20-750"></a>    <span class="fu">poll_mechanism</span>(<span class="pp">@load_preference</span>(<span class="st">&quot;waiting_mechanism&quot;</span>))</span></code></pre></div>
<h2 id="wait-by-sleeping-method">Wait By Sleeping Method</h2>
<p>The Wait By Sleeping method for <code>wait_for_transfer</code> calls
<code>transfer_available</code> in a loop until data is available or the
deadline is reached.</p>
<p>An exponentially increasing sleep delay minimises latency for short
waits and limits CPU use for longer waits.</p>
<div class="sourceCode" id="cb21" data-startFrom="763"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 762;"><span id="cb21-763"><a href="#cb21-763"></a><span class="kw">const</span> delay_sequence <span class="op">=</span></span>
<span id="cb21-764"><a href="#cb21-764"></a>    <span class="fu">ExponentialBackOff</span>(;n <span class="op">=</span> <span class="fu">typemax</span>(<span class="dt">Int</span>),</span>
<span id="cb21-765"><a href="#cb21-765"></a>                        first_delay <span class="op">=</span> <span class="fl">0.01</span>, factor <span class="op">=</span> <span class="fl">1.2</span>, max_delay <span class="op">=</span> <span class="fl">0.25</span>)</span>
<span id="cb21-766"><a href="#cb21-766"></a></span>
<span id="cb21-767"><a href="#cb21-767"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">wait_for_transfer</span>(stream, <span class="op">::</span><span class="dt">WaitBySleeping</span>,</span>
<span id="cb21-768"><a href="#cb21-768"></a>                               buf, n, start, deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb21-769"><a href="#cb21-769"></a>    <span class="cf">for</span> delay <span class="kw">in</span> delay_sequence</span>
<span id="cb21-770"><a href="#cb21-770"></a>        r <span class="op">=</span> <span class="fu">transfer_available</span>(stream, buf, n, start);</span>
<span id="cb21-771"><a href="#cb21-771"></a>        <span class="cf">if</span> r <span class="op">&gt;=</span> <span class="fl">0</span></span>
<span id="cb21-772"><a href="#cb21-772"></a>            <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb21-773"><a href="#cb21-773"></a>        <span class="cf">end</span></span>
<span id="cb21-774"><a href="#cb21-774"></a>        <span class="cf">if</span> <span class="fu">time</span>() <span class="op">&gt;=</span> deadline</span>
<span id="cb21-775"><a href="#cb21-775"></a>            <span class="pp">@db</span> <span class="cf">return</span> <span class="fl">0</span></span>
<span id="cb21-776"><a href="#cb21-776"></a>        <span class="cf">end</span></span>
<span id="cb21-777"><a href="#cb21-777"></a>        <span class="fu">sleep</span>(delay)</span>
<span id="cb21-778"><a href="#cb21-778"></a>    <span class="cf">end</span></span>
<span id="cb21-779"><a href="#cb21-779"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="specialised-waiting-methods">Specialised Waiting Methods</h2>
<p>In the default waiting method, <code>wait</code> is called in a loop
until data is available or the deadline is reached. The appropriate
<code>wait</code> method will be selected according to Waiting
Mechanism.</p>
<p><code>Base.lock</code> and <code>Base.unlock</code> must be
implemented for each stream type.<span
class="sidenote-wrapper"><label for="sn-19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-19" class="margin-toggle"/><span
class="sidenote">These methods should do whatever is necessary to avoid
race conditions between <code>Base.wait</code> and
<code>transfer_available</code>. In UnixIO.jl <code>Base.wait</code>
waits for a <code>ThreadSynchronizer</code> and the underlying polling
mechanism notifies the <code>ThreadSynchronizer</code> to wake up the
waiting task.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb22" data-startFrom="797"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 796;"><span id="cb22-797"><a href="#cb22-797"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">wait_for_transfer</span>(stream, buf, n, start, deadline<span class="op">::</span><span class="dt">Float64</span>,</span>
<span id="cb22-798"><a href="#cb22-798"></a>                               <span class="op">::</span><span class="dt">WaitingMechanism</span>)</span>
<span id="cb22-799"><a href="#cb22-799"></a>    try </span>
<span id="cb22-800"><a href="#cb22-800"></a>        <span class="fu">lock</span>(stream)</span>
<span id="cb22-801"><a href="#cb22-801"></a>        <span class="cf">while</span> <span class="fu">time</span>() <span class="op">&lt;</span> deadline</span>
<span id="cb22-802"><a href="#cb22-802"></a>            <span class="fu">wait</span>(stream; deadline)</span>
<span id="cb22-803"><a href="#cb22-803"></a>            r <span class="op">=</span> <span class="fu">transfer_available</span>(stream, buf, n, start);</span>
<span id="cb22-804"><a href="#cb22-804"></a>            <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb22-805"><a href="#cb22-805"></a>                <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb22-806"><a href="#cb22-806"></a>            <span class="cf">end</span></span>
<span id="cb22-807"><a href="#cb22-807"></a>        <span class="cf">end</span></span>
<span id="cb22-808"><a href="#cb22-808"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="fl">0</span></span>
<span id="cb22-809"><a href="#cb22-809"></a>    finally</span>
<span id="cb22-810"><a href="#cb22-810"></a>        <span class="fu">unlock</span>(stream)</span>
<span id="cb22-811"><a href="#cb22-811"></a>    <span class="kw">end</span></span>
<span id="cb22-812"><a href="#cb22-812"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="buffer-interface-traits">Buffer Interface Traits</h1>
<div class="sourceCode" id="cb23" data-startFrom="818"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 817;"><span id="cb23-818"><a href="#cb23-818"></a><span class="kw">abstract type</span> BufferInterface <span class="kw">end</span></span>
<span id="cb23-819"><a href="#cb23-819"></a><span class="kw">struct</span> UsingIndex <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-820"><a href="#cb23-820"></a><span class="kw">struct</span> UsingPtr <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-821"><a href="#cb23-821"></a><span class="kw">struct</span> IsItemPtr <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-822"><a href="#cb23-822"></a><span class="kw">struct</span> IsBytePtr <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-823"><a href="#cb23-823"></a><span class="kw">struct</span> FromIO <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-824"><a href="#cb23-824"></a><span class="kw">struct</span> FromStream <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-825"><a href="#cb23-825"></a><span class="kw">struct</span> FromPop <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-826"><a href="#cb23-826"></a><span class="kw">struct</span> FromTake <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-827"><a href="#cb23-827"></a><span class="kw">struct</span> FromIteration <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-828"><a href="#cb23-828"></a><span class="kw">struct</span> ToIO <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-829"><a href="#cb23-829"></a><span class="kw">struct</span> ToStream <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-830"><a href="#cb23-830"></a><span class="kw">struct</span> ToPush <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb23-831"><a href="#cb23-831"></a><span class="kw">struct</span> ToPut <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span></code></pre></div>
<p>The <code>FromBufferInterface</code> trait defines what interface is
used to take data from a particular buffer type (or what interface is
preferred for best performance).</p>
<p><code>FromBufferInterface(buffer)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>FromIO()</code></td>
<td style="text-align: left;">Take data from the buffer using the
<code>Base.IO</code> interface.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FromStream()</code></td>
<td style="text-align: left;">Take data from the
<code>IOTraits.Stream</code> interface.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FromPop()</code></td>
<td style="text-align: left;">Use <code>pop!(buffer)</code> to read from
the buffer.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FromTake()</code></td>
<td style="text-align: left;">Use <code>take!(buffer)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FromIteration()</code></td>
<td style="text-align: left;">Use <code>for x in buffer...</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>UsingIndex()</code></td>
<td style="text-align: left;">Use <code>buffer[i]</code> (the
default).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>UsingPtr()</code></td>
<td style="text-align: left;">Use
<code>unsafe_copyto!(x, pointer(buffer), n)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IsItemPtr()</code></td>
<td style="text-align: left;">Use
<code>unsafe_copyto!(x, buffer, n)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IsBytePtr()</code></td>
<td style="text-align: left;">Special case of <code>IsItemPtr</code> for
<code>ioelsize(buffer) == 1</code>.</td>
</tr>
</tbody>
</table>
<p>Default <code>FromBufferInterface</code> methods are built-in for
common buffer types:</p>
<div class="sourceCode" id="cb24" data-startFrom="855"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 854;"><span id="cb24-855"><a href="#cb24-855"></a><span class="fu">FromBufferInterface</span>(x) <span class="op">=</span> <span class="fu">FromBufferInterface</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb24-856"><a href="#cb24-856"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">FromIteration</span>()</span>
<span id="cb24-857"><a href="#cb24-857"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:IO}</span>) <span class="op">=</span> <span class="fu">FromIO</span>()</span>
<span id="cb24-858"><a href="#cb24-858"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Stream}</span>) <span class="op">=</span> <span class="fu">FromStream</span>()</span>
<span id="cb24-859"><a href="#cb24-859"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:AbstractChannel}</span>) <span class="op">=</span> <span class="fu">FromTake</span>()</span>
<span id="cb24-860"><a href="#cb24-860"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ref}</span>) <span class="op">=</span> <span class="fu">UsingPtr</span>()</span>
<span id="cb24-861"><a href="#cb24-861"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ptr{T}}</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">sizeof</span>(T) <span class="op">==</span> <span class="fl">1</span> ? <span class="fu">IsBytePtr</span>() <span class="op">:</span></span>
<span id="cb24-862"><a href="#cb24-862"></a>                                                                 <span class="fu">IsItemPtr</span>()</span></code></pre></div>
<p>Pointers can be used for <code>AbstractArray</code> buffers of Bits
types.</p>
<div class="sourceCode" id="cb25" data-startFrom="868"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 867;"><span id="cb25-868"><a href="#cb25-868"></a><span class="fu">FromBufferInterface</span>(T<span class="op">::</span><span class="dt">Type{&lt;:AbstractArray}</span>) <span class="op">=</span> <span class="fu">ArrayIOInterface</span>(T)</span>
<span id="cb25-869"><a href="#cb25-869"></a></span>
<span id="cb25-870"><a href="#cb25-870"></a><span class="fu">ArrayIOInterface</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">UsingIndex</span>()</span>
<span id="cb25-871"><a href="#cb25-871"></a></span>
<span id="cb25-872"><a href="#cb25-872"></a><span class="fu">ArrayIOInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Array{T}}</span>) <span class="kw">where</span> T <span class="op">=</span></span>
<span id="cb25-873"><a href="#cb25-873"></a>    <span class="fu">isbitstype</span>(T) ? <span class="fu">UsingPtr</span>() <span class="op">:</span> <span class="fu">UsingIndex</span>()</span>
<span id="cb25-874"><a href="#cb25-874"></a></span>
<span id="cb25-875"><a href="#cb25-875"></a><span class="fu">ArrayIOInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Base.FastContiguousSubArray{T,&lt;:Any,&lt;:Array{T}}}</span>) <span class="kw">where</span> T <span class="op">=</span></span>
<span id="cb25-876"><a href="#cb25-876"></a>    <span class="fu">isbitstype</span>(T) ? <span class="fu">UsingPtr</span>() <span class="op">:</span> <span class="fu">UsingIndex</span>()</span></code></pre></div>
<p>The <code>ToBufferInterface</code> trait defines what interface is
used to store data in a particular type of buffer (or what interface is
preferred for best performance).</p>
<p><code>ToBufferInterface(buffer)</code> one of:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ToIO</code></td>
<td style="text-align: left;">Write data to the buffer using the
<code>Base.IO</code> interface.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ToStream</code></td>
<td style="text-align: left;">Write data using the
<code>IOTraits.Stream</code> interface.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ToPush</code></td>
<td style="text-align: left;">Use <code>push!(buffer, data)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ToPut</code></td>
<td style="text-align: left;">Use <code>put!(buffer, data)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>UsingIndex</code></td>
<td style="text-align: left;">Use
<code>buffer[i] = data (the default)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>UsingPtr</code></td>
<td style="text-align: left;">Use
<code>unsafe_copyto!(pointer(buffer), x, n)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IsItemPtr</code></td>
<td style="text-align: left;">Use
<code>unsafe_copyto!(buffer, x, n)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IsBytePtr</code></td>
<td style="text-align: left;">Special case of <code>IsItemPtr</code> for
<code>ioelsize(buffer) == 1</code>.</td>
</tr>
</tbody>
</table>
<p>Default <code>ToBufferInterface</code> methods are built-in for
common buffer types.</p>
<div class="sourceCode" id="cb26" data-startFrom="901"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 900;"><span id="cb26-901"><a href="#cb26-901"></a><span class="fu">ToBufferInterface</span>(x) <span class="op">=</span> <span class="fu">ToBufferInterface</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb26-902"><a href="#cb26-902"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">ToPush</span>()</span>
<span id="cb26-903"><a href="#cb26-903"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:IO}</span>) <span class="op">=</span> <span class="fu">ToIO</span>()</span>
<span id="cb26-904"><a href="#cb26-904"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Stream}</span>) <span class="op">=</span> <span class="fu">ToStream</span>()</span>
<span id="cb26-905"><a href="#cb26-905"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:AbstractChannel}</span>) <span class="op">=</span> <span class="fu">ToPut</span>()</span>
<span id="cb26-906"><a href="#cb26-906"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ref}</span>) <span class="op">=</span> <span class="fu">UsingPtr</span>()</span>
<span id="cb26-907"><a href="#cb26-907"></a><span class="fu">ToBufferInterface</span>(T<span class="op">::</span><span class="dt">Type{&lt;:AbstractArray}</span>) <span class="op">=</span> <span class="fu">ArrayIOInterface</span>(T)</span>
<span id="cb26-908"><a href="#cb26-908"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ptr{T}}</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">sizeof</span>(T) <span class="op">==</span> <span class="fl">1</span> ? <span class="fu">IsBytePtr</span>() <span class="op">:</span></span>
<span id="cb26-909"><a href="#cb26-909"></a>                                                               <span class="fu">IsItemPtr</span>()</span></code></pre></div>
<h1 id="total-data-size-trait">Total Data Size Trait</h1>
<div class="sourceCode" id="cb27" data-startFrom="915"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 914;"><span id="cb27-915"><a href="#cb27-915"></a><span class="kw">abstract type</span> TotalSize <span class="kw">end</span></span>
<span id="cb27-916"><a href="#cb27-916"></a><span class="kw">struct</span> UnknownTotalSize <span class="op">&lt;:</span><span class="dt"> TotalSize </span><span class="kw">end</span></span>
<span id="cb27-917"><a href="#cb27-917"></a><span class="kw">struct</span> InfiniteTotalSize <span class="op">&lt;:</span><span class="dt"> TotalSize </span><span class="kw">end</span></span>
<span id="cb27-918"><a href="#cb27-918"></a><span class="kw">abstract type</span> KnownTotalSize <span class="kw">end</span></span>
<span id="cb27-919"><a href="#cb27-919"></a><span class="kw">struct</span> VariableTotalSize <span class="op">&lt;:</span><span class="dt"> KnownTotalSize </span><span class="kw">end</span></span>
<span id="cb27-920"><a href="#cb27-920"></a><span class="kw">struct</span> FixedTotalSize <span class="op">&lt;:</span><span class="dt"> KnownTotalSize </span><span class="kw">end</span></span>
<span id="cb27-921"><a href="#cb27-921"></a><span class="kw">const</span> AnyTotalSize <span class="op">=</span> TotalSize</span></code></pre></div>
<p>The <code>TotalSize</code> trait describes how much data is available
from a stream.</p>
<p><code>TotalSize(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Total Size</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>VariableTotalSize()</code></td>
<td style="text-align: left;">The total amount of data available can be
queried using the <code>length</code> function. Note: the total size can
change. e.g. new lines might be appended to a log file.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FixedTotalSize()</code></td>
<td style="text-align: left;">The amount of data is known and will not
change. Applicable to block devices. Applicable to some network streams.
e.g. a HTTP Message where Content-Length is known.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InfiniteTotalSize()</code></td>
<td style="text-align: left;">End of file will never be reached.
Applicable to some device files.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>UnknownTotalSize()</code></td>
<td style="text-align: left;">No known data size limit. But end of file
may be reached. e.g. if the other end is closed.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb28" data-startFrom="947"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 946;"><span id="cb28-947"><a href="#cb28-947"></a><span class="fu">TotalSize</span>(x) <span class="op">=</span> <span class="fu">TotalSize</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb28-948"><a href="#cb28-948"></a><span class="fu">TotalSize</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TotalSize</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb28-949"><a href="#cb28-949"></a>                                   <span class="fu">UnknownTotalSize</span>()</span>
<span id="cb28-950"><a href="#cb28-950"></a></span>
<span id="cb28-951"><a href="#cb28-951"></a><span class="kw">abstract type</span> SizeMechanism <span class="kw">end</span></span>
<span id="cb28-952"><a href="#cb28-952"></a><span class="kw">struct</span> NoSizeMechanism <span class="op">&lt;:</span><span class="dt"> SizeMechanism </span><span class="kw">end</span></span>
<span id="cb28-953"><a href="#cb28-953"></a><span class="kw">struct</span> SupportsStatSize <span class="op">&lt;:</span><span class="dt"> SizeMechanism </span><span class="kw">end</span></span>
<span id="cb28-954"><a href="#cb28-954"></a><span class="kw">struct</span> SupportsFIONREAD <span class="op">&lt;:</span><span class="dt"> SizeMechanism </span><span class="kw">end</span></span>
<span id="cb28-955"><a href="#cb28-955"></a><span class="fu">TotalSizeMechanism</span>(x) <span class="op">=</span> <span class="fu">TotalSizeMechanism</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb28-956"><a href="#cb28-956"></a><span class="fu">TotalSizeMechanism</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TotalSizeMechanism</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb28-957"><a href="#cb28-957"></a>                                            <span class="fu">NoSizeMechanism</span>()</span>
<span id="cb28-958"><a href="#cb28-958"></a></span>
<span id="cb28-959"><a href="#cb28-959"></a><span class="fu">_length</span>(stream, <span class="op">::</span><span class="dt">SupportsStatSize</span>) <span class="op">=</span> <span class="fu">stat</span>(stream).size</span></code></pre></div>
<h1 id="transfer-size-trait">Transfer Size Trait</h1>
<div class="sourceCode" id="cb29" data-startFrom="965"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 964;"><span id="cb29-965"><a href="#cb29-965"></a><span class="kw">abstract type</span> TransferSize <span class="kw">end</span></span>
<span id="cb29-966"><a href="#cb29-966"></a><span class="kw">struct</span> UnlimitedTransferSize <span class="op">&lt;:</span><span class="dt"> TransferSize </span><span class="kw">end</span></span>
<span id="cb29-967"><a href="#cb29-967"></a><span class="kw">struct</span> LimitedTransferSize <span class="op">&lt;:</span><span class="dt"> TransferSize </span><span class="kw">end</span></span>
<span id="cb29-968"><a href="#cb29-968"></a><span class="kw">struct</span> FixedTransferSize <span class="op">&lt;:</span><span class="dt"> TransferSize </span><span class="kw">end</span></span>
<span id="cb29-969"><a href="#cb29-969"></a><span class="kw">const</span> AnyTransferSize <span class="op">=</span> TransferSize</span></code></pre></div>
<p>The <code>TransferSize</code> trait describes how much data can be
moved in a single transfer.</p>
<p><code>TransferSize(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Transfer Size</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>UnlimitedTransferSize()</code></td>
<td style="text-align: left;">No known transfer size limit.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>LimitedTransferSize()</code></td>
<td style="text-align: left;">The amount of data that can be moved in a
single transfer is limited. e.g. by a device block size or buffer size.
The maximum transfer size can queried using the
<code>max_transfer_size</code> function.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FixedTransferSize()</code></td>
<td style="text-align: left;">The amount of data moved by a single
transfer is fixed. e.g. <code>/dev/input/event0</code> device always
transfers <code>sizeof(input_event)</code> bytes.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb30" data-startFrom="992"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 991;"><span id="cb30-992"><a href="#cb30-992"></a><span class="fu">TransferSize</span>(s) <span class="op">=</span> <span class="fu">TransferSize</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb30-993"><a href="#cb30-993"></a><span class="fu">TransferSize</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ?  <span class="fu">TransferSize</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb30-994"><a href="#cb30-994"></a>                                       <span class="fu">UnlimitedTransferSize</span>()</span>
<span id="cb30-995"><a href="#cb30-995"></a></span>
<span id="cb30-996"><a href="#cb30-996"></a><span class="fu">max_transfer_size</span>(s) <span class="op">=</span> <span class="fu">max_transfer_size</span>(s, <span class="fu">TransferSize</span>(s), <span class="fu">TotalSize</span>(s))</span>
<span id="cb30-997"><a href="#cb30-997"></a><span class="fu">max_transfer_size</span>(s, <span class="op">::</span><span class="dt">AnyTransferSize</span>, <span class="op">::</span><span class="dt">AnyTotalSize</span>) <span class="op">=</span> <span class="fu">typemax</span>(<span class="dt">UInt</span>)</span>
<span id="cb30-998"><a href="#cb30-998"></a><span class="fu">max_transfer_size</span>(s, <span class="op">::</span><span class="dt">UnlimitedTransferSize</span>, <span class="op">::</span><span class="dt">KnownTotalSize</span>) <span class="op">=</span> <span class="fu">length</span>(s)</span>
<span id="cb30-999"><a href="#cb30-999"></a><span class="fu">max_transfer_size</span>(s, <span class="op">::</span><span class="dt">LimitedTransferSize</span>, <span class="op">::</span><span class="dt">AnyTotalSize</span>) <span class="op">=</span> </span>
<span id="cb30-1000"><a href="#cb30-1000"></a>    <span class="fu">max_transfer_size</span>(s, <span class="fu">TransferSizeMechanism</span>(s))</span></code></pre></div>
<p><code>TransferSizeMechanism(stream)</code> returns one of:</p>
<p>FIXME look at <code>F_GETPIPE_SZ</code> and
<code>SO_SNDBUF</code></p>
<ul>
<li><code>SupportsFIONREAD()</code> – The underlying device supports
<code>ioctl(2), FIONREAD</code>.</li>
<li><code>SupportsStatSize()</code> – The underlying device supports
<code>fstat(2), st_size</code>.</li>
</ul>
<div class="sourceCode" id="cb31" data-startFrom="1012"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1011;"><span id="cb31-1012"><a href="#cb31-1012"></a><span class="fu">TransferSizeMechanism</span>(s) <span class="op">=</span> <span class="fu">TransferSizeMechanism</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb31-1013"><a href="#cb31-1013"></a><span class="fu">TransferSizeMechanism</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ?</span>
<span id="cb31-1014"><a href="#cb31-1014"></a>                                 <span class="fu">TransferSizeMechanism</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb31-1015"><a href="#cb31-1015"></a>                                 <span class="fu">NoSizeMechanism</span>()</span></code></pre></div>
<h1 id="data-availability-trait">Data Availability Trait</h1>
<div class="sourceCode" id="cb32" data-startFrom="1021"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1020;"><span id="cb32-1021"><a href="#cb32-1021"></a><span class="kw">abstract type</span> Availability <span class="kw">end</span></span>
<span id="cb32-1022"><a href="#cb32-1022"></a><span class="kw">struct</span> AlwaysAvailable <span class="op">&lt;:</span><span class="dt"> Availability </span><span class="kw">end</span></span>
<span id="cb32-1023"><a href="#cb32-1023"></a><span class="kw">struct</span> PartiallyAvailable <span class="op">&lt;:</span><span class="dt"> Availability </span><span class="kw">end</span></span>
<span id="cb32-1024"><a href="#cb32-1024"></a><span class="kw">struct</span> UnknownAvailability <span class="op">&lt;:</span><span class="dt"> Availability </span><span class="kw">end</span></span></code></pre></div>
<p>The <code>Availability</code> trait describes when data is available
from a stream.</p>
<p><code>Availability(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Availability</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>AlwaysAvailable()</code></td>
<td style="text-align: left;">Data is always immediately available.
i.e. <code>bytesavailable</code> === <code>bytes_remaining</code>.
Applicable to some device files (dev/event, /dev/zero). Applicable to
local disk files.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>PartiallyAvailable()</code></td>
<td style="text-align: left;">Some data may be immediately available
from a buffer, but <code>bytesavailable</code> can be less than
<code>bytes_remaining</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>UnknownAvailability()</code></td>
<td style="text-align: left;">There is no mechanism for determining data
availability. The only way to know how much data is available is to
attempt a transfer. i.e. <code>bytesavailable</code> is always 0.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb33" data-startFrom="1049"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1048;"><span id="cb33-1049"><a href="#cb33-1049"></a><span class="fu">Availability</span>(x) <span class="op">=</span> <span class="fu">Availability</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb33-1050"><a href="#cb33-1050"></a><span class="fu">Availability</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">Availability</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb33-1051"><a href="#cb33-1051"></a>                                      <span class="fu">UnknownAvailability</span>()</span>
<span id="cb33-1052"><a href="#cb33-1052"></a></span>
<span id="cb33-1053"><a href="#cb33-1053"></a><span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">UnknownAvailability</span>,</span>
<span id="cb33-1054"><a href="#cb33-1054"></a>                   <span class="op">::</span><span class="dt">AnyTransferSize</span>) <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb33-1055"><a href="#cb33-1055"></a></span>
<span id="cb33-1056"><a href="#cb33-1056"></a><span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">AlwaysAvailable</span>,</span>
<span id="cb33-1057"><a href="#cb33-1057"></a>                   <span class="op">::</span><span class="dt">UnlimitedTransferSize</span>) <span class="op">=</span> <span class="fu">bytes_remaining</span>(s)</span>
<span id="cb33-1058"><a href="#cb33-1058"></a></span>
<span id="cb33-1059"><a href="#cb33-1059"></a><span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">AlwaysAvailable</span>,</span>
<span id="cb33-1060"><a href="#cb33-1060"></a>                   <span class="op">::</span><span class="dt">FixedTransferSize</span>) <span class="op">=</span> <span class="fu">max_transfer_size</span>(s)</span>
<span id="cb33-1061"><a href="#cb33-1061"></a></span>
<span id="cb33-1062"><a href="#cb33-1062"></a></span>
<span id="cb33-1063"><a href="#cb33-1063"></a><span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">PartiallyAvailable</span>,</span>
<span id="cb33-1064"><a href="#cb33-1064"></a>                   <span class="op">::</span><span class="dt">AnyTransferSize</span>) <span class="op">=</span></span>
<span id="cb33-1065"><a href="#cb33-1065"></a>    <span class="fu">_bytesavailable</span>(s, <span class="fu">TransferSizeMechanism</span>(s))</span></code></pre></div>
<h1 id="transfer-function-dispatch">Transfer Function Dispatch</h1>
<pre><code>transfer_available(stream, buf, n, start)</code></pre>
<p>Transfer at most <code>n</code> items between <code>stream</code> and
<code>buffer</code>. Return the number of items transferred.</p>
<div class="sourceCode" id="cb35" data-startFrom="1077"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1076;"><span id="cb35-1077"><a href="#cb35-1077"></a><span class="kw">function</span> transfer_available <span class="kw">end</span></span></code></pre></div>
<h2 id="start-index-normalisation"><code>start</code> Index
Normalisation</h2>
<p>If <code>start</code> is a Tuple of indexes it is normalised by the
method below. The <code>StreamIndexing</code> trait is used to check
that <code>stream</code> supports indexing. Indexable streams are
replaced by a <code>Tuple</code> containing <code>stream</code> and the
stream index.</p>
<div class="sourceCode" id="cb36" data-startFrom="1087"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1086;"><span id="cb36-1087"><a href="#cb36-1087"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, buf, n, start<span class="op">::</span><span class="dt">Tuple</span>)</span>
<span id="cb36-1088"><a href="#cb36-1088"></a>    <span class="pp">@require</span> <span class="fu">StreamIndexing</span>(stream) <span class="op">==</span> <span class="fu">IndexableIO</span>() <span class="op">||</span> start[<span class="fl">1</span>] <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb36-1089"><a href="#cb36-1089"></a>    <span class="pp">@require</span> start <span class="op">&gt;=</span> (<span class="fl">1</span>,<span class="fl">1</span>)</span>
<span id="cb36-1090"><a href="#cb36-1090"></a>    <span class="cf">if</span> start[<span class="fl">1</span>] <span class="op">!=</span> <span class="fl">1</span></span>
<span id="cb36-1091"><a href="#cb36-1091"></a>        stream <span class="op">=</span> (stream, <span class="fu">UInt</span>(start[<span class="fl">1</span>]))</span>
<span id="cb36-1092"><a href="#cb36-1092"></a>    <span class="cf">end</span></span>
<span id="cb36-1093"><a href="#cb36-1093"></a>    <span class="fu">transfer_available</span>(stream, buf, n, <span class="fu">UInt</span>(start[<span class="fl">2</span>]))</span>
<span id="cb36-1094"><a href="#cb36-1094"></a><span class="kw">end</span></span></code></pre></div>
<p>From here on, <code>start</code> is always a simple <code>UInt</code>
index into <code>buf</code>.</p>
<h2
id="application-of-the-direction-and-buffer-interface-traits">Application
of the Direction and Buffer Interface Traits</h2>
<p>Next, the <code>IODriection</code> and <code>BufferInterface</code>
traits are inserted into the argument list.<span
class="sidenote-wrapper"><label for="sn-20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-20" class="margin-toggle"/><span
class="sidenote">Note that although the <code>IODirection</code> is now
part of the argument list, premature specialisation on direction is
avoided. Eventually most transfers will end up calling an OS
<code>read</code> or <code>write</code> function. However, much of the
transfer logic is the same irrespective of direction. For example, the
methods for <code>UsingPtr</code> and <code>UsingIndex</code> below work
for both input and output. (Another consideration is supporting
interfaces with <code>IODirection</code> <code>Exchange</code>).<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb37" data-startFrom="1113"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1112;"><span id="cb37-1113"><a href="#cb37-1113"></a><span class="fu">transfer_available</span>(stream, buf, n, start) <span class="op">=</span> </span>
<span id="cb37-1114"><a href="#cb37-1114"></a>    <span class="fu">transfer_available</span>(stream, <span class="fu">TransferDirection</span>(stream), buf, n, start)</span>
<span id="cb37-1115"><a href="#cb37-1115"></a></span>
<span id="cb37-1116"><a href="#cb37-1116"></a><span class="fu">transfer_available</span>(stream, <span class="op">::</span><span class="dt">In</span>, buf, n, start) <span class="op">=</span></span>
<span id="cb37-1117"><a href="#cb37-1117"></a>    <span class="fu">transfer_available</span>(stream, <span class="fu">In</span>(), buf, <span class="fu">ToBufferInterface</span>(buf), n, start)</span>
<span id="cb37-1118"><a href="#cb37-1118"></a></span>
<span id="cb37-1119"><a href="#cb37-1119"></a><span class="fu">transfer_available</span>(stream, <span class="op">::</span><span class="dt">Out</span>, buf, n, start) <span class="op">=</span></span>
<span id="cb37-1120"><a href="#cb37-1120"></a>    <span class="fu">transfer_available</span>(stream, <span class="fu">Out</span>(), buf, <span class="fu">FromBufferInterface</span>(buf), n, start)</span></code></pre></div>
<h2 id="low-level-byte-stream-methods">Low Level Byte-Stream
Methods</h2>
<p>The specialised methods for various Buffer Interfaces eventually call
this this IsBytePtr method, which in turn calls the low level
<code>unsafe_transfer</code> implementation methods.</p>
<div class="sourceCode" id="cb38" data-startFrom="1131"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1130;"><span id="cb38-1131"><a href="#cb38-1131"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, direction, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, <span class="op">::</span><span class="dt">IsBytePtr</span>,</span>
<span id="cb38-1132"><a href="#cb38-1132"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb38-1133"><a href="#cb38-1133"></a>    r <span class="op">=</span> <span class="fu">unsafe_transfer</span>(stream, direction, buf <span class="op">+</span> (start<span class="op">-</span><span class="fl">1</span>), n)</span>
<span id="cb38-1134"><a href="#cb38-1134"></a>    <span class="pp">@ensure</span> r isa <span class="dt">UInt</span></span>
<span id="cb38-1135"><a href="#cb38-1135"></a>    <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb38-1136"><a href="#cb38-1136"></a><span class="kw">end</span></span></code></pre></div>
<p>This method handles items larger than one byte. It returns zero if
there are not enough bytes available for a whole item. For streams with
Unknown Transfer Size the requested transfer is attempted but an error
is thrown if a partial item is transferred.</p>
<div class="sourceCode" id="cb39" data-startFrom="1145"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1144;"><span id="cb39-1145"><a href="#cb39-1145"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, direction, buf, <span class="op">::</span><span class="dt">IsItemPtr</span>,</span>
<span id="cb39-1146"><a href="#cb39-1146"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb39-1147"><a href="#cb39-1147"></a>    sz <span class="op">=</span> <span class="fu">ioelsize</span>(buf)</span>
<span id="cb39-1148"><a href="#cb39-1148"></a>    <span class="pp">@assert</span> sz <span class="op">&gt;</span> <span class="fl">1</span></span>
<span id="cb39-1149"><a href="#cb39-1149"></a>    <span class="cf">if</span> <span class="fu">Availability</span>(stream) <span class="op">!=</span> <span class="fu">UnknownAvailability</span>()</span>
<span id="cb39-1150"><a href="#cb39-1150"></a>        n<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fu">min</span>(n, <span class="fu">bytesavailable</span>(stream) <span class="op">÷</span> sz)</span>
<span id="cb39-1151"><a href="#cb39-1151"></a>        n <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">||</span> <span class="pp">@db</span> <span class="cf">return</span> <span class="fu">UInt</span>(<span class="fl">0</span>)</span>
<span id="cb39-1152"><a href="#cb39-1152"></a>    <span class="cf">end</span></span>
<span id="cb39-1153"><a href="#cb39-1153"></a></span>
<span id="cb39-1154"><a href="#cb39-1154"></a>    buf <span class="op">=</span> <span class="fu">Ptr</span><span class="dt">{UInt8}</span>(buf)</span>
<span id="cb39-1155"><a href="#cb39-1155"></a>    start <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> ((start<span class="op">-</span><span class="fl">1</span>) <span class="op">*</span> sz)</span>
<span id="cb39-1156"><a href="#cb39-1156"></a></span>
<span id="cb39-1157"><a href="#cb39-1157"></a>    r <span class="op">=</span> <span class="fu">transfer_available</span>(stream, direction, buf, <span class="fu">IsBytePtr</span>(), n <span class="op">*</span> sz, start)</span>
<span id="cb39-1158"><a href="#cb39-1158"></a>    <span class="pp">@ensure</span> r isa <span class="dt">UInt</span></span>
<span id="cb39-1159"><a href="#cb39-1159"></a></span>
<span id="cb39-1160"><a href="#cb39-1160"></a>    <span class="cf">if</span> r <span class="op">%</span> sz <span class="op">!=</span> <span class="fl">0</span></span>
<span id="cb39-1161"><a href="#cb39-1161"></a>        <span class="pp">@assert</span> <span class="fu">Availability</span>(stream) <span class="op">==</span> <span class="fu">UnknownAvailability</span>()</span>
<span id="cb39-1162"><a href="#cb39-1162"></a>        r <span class="op">+=</span> <span class="fu">transferall</span>(stream, buf <span class="op">+</span> (start<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> r, r <span class="op">%</span> sz)</span>
<span id="cb39-1163"><a href="#cb39-1163"></a>    <span class="cf">end</span></span>
<span id="cb39-1164"><a href="#cb39-1164"></a>    <span class="cf">if</span> r <span class="op">%</span> sz <span class="op">!=</span> <span class="fl">0</span></span>
<span id="cb39-1165"><a href="#cb39-1165"></a>        <span class="fu">throw</span>(<span class="fu">IOTraitsError</span>(stream,</span>
<span id="cb39-1166"><a href="#cb39-1166"></a>              <span class="st">&quot;Partial Transfer Error: &quot;</span> <span class="op">*</span></span>
<span id="cb39-1167"><a href="#cb39-1167"></a>              <span class="st">&quot;Transfer </span><span class="sc">$</span>(<span class="fu">verb</span>(direction))<span class="st"> </span><span class="sc">$</span>stream<span class="st"> returned </span><span class="sc">$</span>r<span class="st"> bytes &quot;</span> <span class="op">*</span></span>
<span id="cb39-1168"><a href="#cb39-1168"></a>              <span class="st">&quot;but </span><span class="sc">$</span>(<span class="fu">typeof</span>(buf))<span class="st"> has </span><span class="sc">$</span>sz<span class="st">-byte elements &quot;</span> <span class="op">*</span></span>
<span id="cb39-1169"><a href="#cb39-1169"></a>              <span class="st">&quot;(</span><span class="sc">$</span>r<span class="st"> % </span><span class="sc">$</span>sz<span class="st"> = </span><span class="sc">$</span>(r <span class="op">%</span> sz)<span class="st">).</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">*</span></span>
<span id="cb39-1170"><a href="#cb39-1170"></a>              <span class="st">&quot;Consider using BufferedInput(stream) to ensure that &quot;</span> <span class="op">*</span></span>
<span id="cb39-1171"><a href="#cb39-1171"></a>              <span class="st">&quot;`Availability(stream) != UnknownAvailability`.&quot;</span>))</span>
<span id="cb39-1172"><a href="#cb39-1172"></a>    <span class="cf">end</span></span>
<span id="cb39-1173"><a href="#cb39-1173"></a>    r <span class="op">÷=</span> sz</span>
<span id="cb39-1174"><a href="#cb39-1174"></a>    <span class="pp">@ensure</span> r <span class="op">&lt;=</span> n</span>
<span id="cb39-1175"><a href="#cb39-1175"></a>    <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb39-1176"><a href="#cb39-1176"></a><span class="kw">end</span></span></code></pre></div>
<p>At least one of the following <code>unsafe_transfer</code> methods
must be implemented for each type
<code>T &lt;: IOTraits.Stream</code>:</p>
<pre><code>unsafe_transfer(s::T, ::IOTraits.In,           buffer::Ptr{UInt8}, n::UInt)
unsafe_transfer(s::T, ::IOTraits.Out,          buffer::Ptr{UInt8}, n::UInt)
unsafe_transfer(s::T, ::IOTraits.Exchange,     buffer::Ptr{UInt8}, n::UInt)
unsafe_transfer(s::T, ::IOTraits.AnyDirection, buffer::Ptr{UInt8}, n::UInt)</code></pre>
<p><code>unsafe_transfer</code> should transfer at most <code>n</code>
items between <code>stream</code> and <code>buffer</code> and return the
number of items transferred (or zero if no items are immediately
available)<span
class="sidenote-wrapper"><label for="sn-21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-21" class="margin-toggle"/><span
class="sidenote">⚠️ Note that the <code>BaseIOStream</code> methods
defined here do not properly implement the specification because
<code>unsafe_read</code> and <code>unsafe_write</code> may block to wait
for data. These methods are intended for testing purposes only. The
transfer timeout feature will not work properly for
<code>BaseIOStream</code>.<br />
<br />
</span></span>.</p>
<div class="sourceCode" id="cb41" data-startFrom="1198"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1197;"><span id="cb41-1198"><a href="#cb41-1198"></a><span class="kw">function</span> unsafe_transfer <span class="kw">end</span></span>
<span id="cb41-1199"><a href="#cb41-1199"></a></span>
<span id="cb41-1200"><a href="#cb41-1200"></a></span>
<span id="cb41-1201"><a href="#cb41-1201"></a><span class="fu">unsafe_transfer</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">ReadFragmentation</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb41-1202"><a href="#cb41-1202"></a>                                           <span class="fu">ReadsBytes</span>()</span>
<span id="cb41-1203"><a href="#cb41-1203"></a></span>
<span id="cb41-1204"><a href="#cb41-1204"></a><span class="fu">unsafe_transfer</span>(s<span class="op">::</span><span class="dt">BaseIOStream</span>, <span class="op">::</span><span class="dt">In</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, n<span class="op">::</span><span class="dt">UInt</span>) <span class="op">=</span></span>
<span id="cb41-1205"><a href="#cb41-1205"></a>    <span class="fu">UInt</span>(<span class="fu">unsafe_read</span>(s.io, buf, n))</span>
<span id="cb41-1206"><a href="#cb41-1206"></a></span>
<span id="cb41-1207"><a href="#cb41-1207"></a><span class="fu">unsafe_transfer</span>(s<span class="op">::</span><span class="dt">BaseIOStream</span>, <span class="op">::</span><span class="dt">Out</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, n<span class="op">::</span><span class="dt">UInt</span>) <span class="op">=</span></span>
<span id="cb41-1208"><a href="#cb41-1208"></a>    <span class="fu">UInt</span>(<span class="fu">unsafe_write</span>(s.io, buf, n))</span></code></pre></div>
<h2 id="transfer-specialisations-for-indexable-buffers">Transfer
Specialisations for Indexable Buffers</h2>
<p>If <code>n</code> is missing, use the whole length of the buffer.</p>
<p>After this both <code>n</code> and <code>start</code> are always
<code>UInt</code>s.</p>
<div class="sourceCode" id="cb42" data-startFrom="1220"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1219;"><span id="cb42-1220"><a href="#cb42-1220"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, direction<span class="op">::</span><span class="dt">AnyDirection</span>,</span>
<span id="cb42-1221"><a href="#cb42-1221"></a>                                buf, interface<span class="op">::</span><span class="dt">Union{UsingPtr, UsingIndex}</span>,</span>
<span id="cb42-1222"><a href="#cb42-1222"></a>                                n<span class="op">::</span><span class="dt">Missing</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb42-1223"><a href="#cb42-1223"></a>    <span class="pp">@require</span> <span class="fu">length</span>(buf) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb42-1224"><a href="#cb42-1224"></a>    n <span class="op">=</span> <span class="fu">length</span>(buf) <span class="op">-</span> (start <span class="op">-</span> <span class="fl">1</span>)</span>
<span id="cb42-1225"><a href="#cb42-1225"></a>    <span class="fu">transfer_available</span>(stream, direction, buf, interface, <span class="fu">UInt</span>(n), start)</span>
<span id="cb42-1226"><a href="#cb42-1226"></a><span class="kw">end</span></span>
<span id="cb42-1227"><a href="#cb42-1227"></a></span>
<span id="cb42-1228"><a href="#cb42-1228"></a><span class="fu">transfer_available</span>(stream, direction, buf, interface, n<span class="op">::</span><span class="dt">Missing</span>, start<span class="op">::</span><span class="dt">UInt</span>) <span class="op">=</span></span>
<span id="cb42-1229"><a href="#cb42-1229"></a>    <span class="fu">transfer_available</span>(stream, direction, buf, interface, <span class="fu">typemax</span>(<span class="dt">UInt</span>), start)</span>
<span id="cb42-1230"><a href="#cb42-1230"></a></span>
<span id="cb42-1231"><a href="#cb42-1231"></a><span class="fu">transfer_available</span>(stream, direction, buf, interface, n<span class="op">::</span><span class="dt">Integer</span>, start<span class="op">::</span><span class="dt">Integer</span>) <span class="op">=</span> </span>
<span id="cb42-1232"><a href="#cb42-1232"></a>    <span class="fu">transfer_available</span>(stream, direction, buf, interface, <span class="fu">UInt</span>(n), <span class="fu">UInt</span>(start))</span></code></pre></div>
<p>If the buffer is pointer-compatible convert it to a pointer.
<code>unsafe_transfer</code> function.</p>
<div class="sourceCode" id="cb43" data-startFrom="1239"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1238;"><span id="cb43-1239"><a href="#cb43-1239"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, <span class="op">::</span><span class="dt">AnyDirection</span>, buf, <span class="op">::</span><span class="dt">UsingPtr</span>,</span>
<span id="cb43-1240"><a href="#cb43-1240"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb43-1241"><a href="#cb43-1241"></a>    <span class="fu">checkbounds</span>(buf, (start<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> n)</span>
<span id="cb43-1242"><a href="#cb43-1242"></a>    GC.<span class="pp">@preserve</span> buf <span class="fu">transfer_available</span>(stream, <span class="fu">pointer</span>(buf, start), n, <span class="fl">1</span>)</span>
<span id="cb43-1243"><a href="#cb43-1243"></a><span class="kw">end</span></span>
<span id="cb43-1244"><a href="#cb43-1244"></a></span>
<span id="cb43-1245"><a href="#cb43-1245"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, <span class="op">::</span><span class="dt">AnyDirection</span>, buf<span class="op">::</span><span class="dt">Ref</span>, <span class="op">::</span><span class="dt">UsingPtr</span>,</span>
<span id="cb43-1246"><a href="#cb43-1246"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb43-1247"><a href="#cb43-1247"></a>    p <span class="op">=</span> <span class="bu">Base</span>.<span class="fu">unsafe_convert</span>(<span class="dt">Ptr</span>{<span class="fu">eltype</span>(buf)}, buf)</span>
<span id="cb43-1248"><a href="#cb43-1248"></a>    GC.<span class="pp">@preserve</span> buf <span class="fu">transfer_available</span>(stream, p, n, <span class="fl">1</span>)</span>
<span id="cb43-1249"><a href="#cb43-1249"></a><span class="kw">end</span></span></code></pre></div>
<p>If the buffer is not pointer-compatible, transfer one item at a
time.</p>
<div class="sourceCode" id="cb44" data-startFrom="1255"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1254;"><span id="cb44-1255"><a href="#cb44-1255"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, d<span class="op">::</span><span class="dt">AnyDirection</span>, buf, <span class="op">::</span><span class="dt">UsingIndex</span>,</span>
<span id="cb44-1256"><a href="#cb44-1256"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb44-1257"><a href="#cb44-1257"></a>    T <span class="op">=</span> <span class="fu">ioeltype</span>(buf)</span>
<span id="cb44-1258"><a href="#cb44-1258"></a>    x <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{T}</span>(<span class="cn">undef</span>, <span class="fl">1</span>)</span>
<span id="cb44-1259"><a href="#cb44-1259"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb44-1260"><a href="#cb44-1260"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">eachindex</span>(<span class="fu">view</span>(buf, start<span class="op">:</span>(start<span class="op">-</span><span class="fl">1</span>)<span class="op">+</span>n))</span>
<span id="cb44-1261"><a href="#cb44-1261"></a>        d <span class="op">==</span> <span class="fu">In</span>() <span class="op">||</span> (x[<span class="fl">1</span>] <span class="op">=</span> buf[i])</span>
<span id="cb44-1262"><a href="#cb44-1262"></a>        n <span class="op">=</span> <span class="fu">transfer</span>(stream, x; deadline<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb44-1263"><a href="#cb44-1263"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb44-1264"><a href="#cb44-1264"></a>            <span class="cf">break</span></span>
<span id="cb44-1265"><a href="#cb44-1265"></a>        <span class="cf">end</span></span>
<span id="cb44-1266"><a href="#cb44-1266"></a>        d <span class="op">==</span> <span class="fu">Out</span>() <span class="op">||</span> (buf[i] <span class="op">=</span> x[<span class="fl">1</span>])</span>
<span id="cb44-1267"><a href="#cb44-1267"></a>        count <span class="op">+=</span> n</span>
<span id="cb44-1268"><a href="#cb44-1268"></a>        stream <span class="op">=</span> <span class="fu">next_stream_index</span>(stream, T)</span>
<span id="cb44-1269"><a href="#cb44-1269"></a>    <span class="cf">end</span></span>
<span id="cb44-1270"><a href="#cb44-1270"></a>    <span class="pp">@db</span> <span class="cf">return</span> count</span>
<span id="cb44-1271"><a href="#cb44-1271"></a><span class="kw">end</span></span>
<span id="cb44-1272"><a href="#cb44-1272"></a></span>
<span id="cb44-1273"><a href="#cb44-1273"></a><span class="fu">next_stream_index</span>((stream, i), T) <span class="op">=</span> (stream, i <span class="op">+</span> <span class="fu">sizeof</span>(T))</span>
<span id="cb44-1274"><a href="#cb44-1274"></a><span class="fu">next_stream_index</span>(stream<span class="op">::</span><span class="dt">Stream</span>, T) <span class="op">=</span> stream</span></code></pre></div>
<h2 id="transfer-specialisations-for-iterable-buffers">Transfer
Specialisations for Iterable Buffers</h2>
<p>Iterate over <code>buf</code> (skip items until <code>start</code>
index is reached). Transfer each item one at a time.</p>
<div class="sourceCode" id="cb45" data-startFrom="1283"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1282;"><span id="cb45-1283"><a href="#cb45-1283"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, <span class="op">::</span><span class="dt">In</span>, buf, <span class="op">::</span><span class="dt">FromIteration</span>,</span>
<span id="cb45-1284"><a href="#cb45-1284"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb45-1285"><a href="#cb45-1285"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb45-1286"><a href="#cb45-1286"></a>    <span class="cf">for</span> x <span class="kw">in</span> buf</span>
<span id="cb45-1287"><a href="#cb45-1287"></a>        <span class="cf">if</span> start <span class="op">&gt;</span> <span class="fl">1</span></span>
<span id="cb45-1288"><a href="#cb45-1288"></a>            start <span class="op">-=</span> <span class="fl">1</span></span>
<span id="cb45-1289"><a href="#cb45-1289"></a>            <span class="cf">continue</span></span>
<span id="cb45-1290"><a href="#cb45-1290"></a>        <span class="cf">end</span></span>
<span id="cb45-1291"><a href="#cb45-1291"></a>        n <span class="op">=</span> <span class="fu">transfer</span>(stream, [x]; deadline<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb45-1292"><a href="#cb45-1292"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb45-1293"><a href="#cb45-1293"></a>            <span class="cf">break</span></span>
<span id="cb45-1294"><a href="#cb45-1294"></a>        <span class="cf">end</span></span>
<span id="cb45-1295"><a href="#cb45-1295"></a>        count <span class="op">+=</span> n</span>
<span id="cb45-1296"><a href="#cb45-1296"></a>        stream <span class="op">=</span> <span class="fu">next_stream_index</span>(stream, <span class="fu">ioeltype</span>(buf))</span>
<span id="cb45-1297"><a href="#cb45-1297"></a>    <span class="cf">end</span></span>
<span id="cb45-1298"><a href="#cb45-1298"></a>    <span class="cf">return</span> count</span>
<span id="cb45-1299"><a href="#cb45-1299"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="transfer-specialisations-for-collection-buffers">Transfer
Specialisations for Collection Buffers</h2>
<div class="sourceCode" id="cb46" data-startFrom="1305"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1304;"><span id="cb46-1305"><a href="#cb46-1305"></a><span class="cf">for</span> (T, f) <span class="kw">in</span> [ToPut <span class="op">=&gt;</span> put!,</span>
<span id="cb46-1306"><a href="#cb46-1306"></a>              ToPush <span class="op">=&gt;</span> push!,</span>
<span id="cb46-1307"><a href="#cb46-1307"></a>              FromPop <span class="op">=&gt;</span> pop!,</span>
<span id="cb46-1308"><a href="#cb46-1308"></a>              FromTake <span class="op">=&gt;</span> take!]</span>
<span id="cb46-1309"><a href="#cb46-1309"></a>    <span class="fu">eval</span>(<span class="op">:</span>(<span class="fu">transfer_available</span>(s, dir, buf, <span class="op">::</span><span class="dt">$T</span>, n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>) <span class="op">=</span></span>
<span id="cb46-1310"><a href="#cb46-1310"></a>           <span class="fu">transfer_available</span>(s, dir, buf,   <span class="op">$</span>f, n, start)))</span>
<span id="cb46-1311"><a href="#cb46-1311"></a><span class="cf">end</span></span>
<span id="cb46-1312"><a href="#cb46-1312"></a></span>
<span id="cb46-1313"><a href="#cb46-1313"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(stream, d<span class="op">::</span><span class="dt">TransferDirection</span>, buf, f<span class="op">::</span><span class="dt">Function</span>,</span>
<span id="cb46-1314"><a href="#cb46-1314"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb46-1315"><a href="#cb46-1315"></a>    <span class="pp">@require</span> start <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb46-1316"><a href="#cb46-1316"></a>    T <span class="op">=</span> <span class="fu">ioeltype</span>(buf)</span>
<span id="cb46-1317"><a href="#cb46-1317"></a>    x <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{T}</span>(<span class="cn">undef</span>, <span class="fl">1</span>)</span>
<span id="cb46-1318"><a href="#cb46-1318"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb46-1319"><a href="#cb46-1319"></a>    <span class="cf">while</span> count <span class="op">&lt;</span> n</span>
<span id="cb46-1320"><a href="#cb46-1320"></a>        d <span class="op">==</span> <span class="fu">In</span>() <span class="op">||</span> (x[<span class="fl">1</span>] <span class="op">=</span> <span class="fu">f</span>(buf))</span>
<span id="cb46-1321"><a href="#cb46-1321"></a>        r <span class="op">=</span> <span class="fu">transfer</span>(stream, x; deadline<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb46-1322"><a href="#cb46-1322"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb46-1323"><a href="#cb46-1323"></a>            <span class="cf">break</span></span>
<span id="cb46-1324"><a href="#cb46-1324"></a>        <span class="cf">end</span></span>
<span id="cb46-1325"><a href="#cb46-1325"></a>        d <span class="op">==</span> <span class="fu">Out</span>() <span class="op">||</span> <span class="fu">f</span>(buf, x[<span class="fl">1</span>])</span>
<span id="cb46-1326"><a href="#cb46-1326"></a>        count <span class="op">+=</span> r</span>
<span id="cb46-1327"><a href="#cb46-1327"></a>        stream <span class="op">=</span> <span class="fu">next_stream_index</span>(stream, T)</span>
<span id="cb46-1328"><a href="#cb46-1328"></a>    <span class="cf">end</span></span>
<span id="cb46-1329"><a href="#cb46-1329"></a>    <span class="pp">@db</span> <span class="cf">return</span> count</span>
<span id="cb46-1330"><a href="#cb46-1330"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="transfer-specialisations-for-io-buffers">Transfer
Specialisations for IO Buffers</h2>
<div class="sourceCode" id="cb47" data-startFrom="1336"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1335;"><span id="cb47-1336"><a href="#cb47-1336"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(s1, <span class="op">::</span><span class="dt">In</span>, s2, <span class="op">::</span><span class="dt">ToStream</span>,</span>
<span id="cb47-1337"><a href="#cb47-1337"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb47-1338"><a href="#cb47-1338"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, <span class="fu">min</span>(n, <span class="fu">max</span>(<span class="fu">default_buffer_size</span>(s1),</span>
<span id="cb47-1339"><a href="#cb47-1339"></a>                                          <span class="fu">default_buffer_size</span>(s2))))</span>
<span id="cb47-1340"><a href="#cb47-1340"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb47-1341"><a href="#cb47-1341"></a>    <span class="cf">while</span> count <span class="op">&lt;</span> n</span>
<span id="cb47-1342"><a href="#cb47-1342"></a>        r <span class="op">=</span> <span class="fu">transfer</span>(s1 <span class="op">=&gt;</span> buf; deadline<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb47-1343"><a href="#cb47-1343"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb47-1344"><a href="#cb47-1344"></a>            <span class="cf">break</span></span>
<span id="cb47-1345"><a href="#cb47-1345"></a>        <span class="cf">end</span></span>
<span id="cb47-1346"><a href="#cb47-1346"></a>        r2 <span class="op">=</span> <span class="fu">transfer</span>(buf <span class="op">=&gt;</span> s2, r)</span>
<span id="cb47-1347"><a href="#cb47-1347"></a>        <span class="pp">@assert</span> r2 <span class="op">==</span> r</span>
<span id="cb47-1348"><a href="#cb47-1348"></a>        <span class="co"># FIXME should query available capacity and not read more than that?</span></span>
<span id="cb47-1349"><a href="#cb47-1349"></a>        count <span class="op">+=</span> r</span>
<span id="cb47-1350"><a href="#cb47-1350"></a>    <span class="cf">end</span></span>
<span id="cb47-1351"><a href="#cb47-1351"></a>    <span class="cf">return</span> count</span>
<span id="cb47-1352"><a href="#cb47-1352"></a><span class="kw">end</span></span>
<span id="cb47-1353"><a href="#cb47-1353"></a></span>
<span id="cb47-1354"><a href="#cb47-1354"></a><span class="fu">transfer_available</span>(s1, <span class="op">::</span><span class="dt">Out</span>, s2, <span class="op">::</span><span class="dt">FromStream</span>, n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>) <span class="op">=</span></span>
<span id="cb47-1355"><a href="#cb47-1355"></a>    <span class="fu">transfer_available</span>(s2, <span class="fu">In</span>(), s1, <span class="fu">ToStream</span>(), n, start)</span>
<span id="cb47-1356"><a href="#cb47-1356"></a></span>
<span id="cb47-1357"><a href="#cb47-1357"></a><span class="kw">function</span> <span class="fu">transfer_available</span>(s, direction, io, <span class="op">::</span><span class="dt">Union{ToIO,FromIO}</span>,</span>
<span id="cb47-1358"><a href="#cb47-1358"></a>                            n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb47-1359"><a href="#cb47-1359"></a>    s2 <span class="op">=</span> <span class="fu">BaseIOStream</span><span class="dt">{typeof(io), direction == In() ? Out : In}</span>(io)</span>
<span id="cb47-1360"><a href="#cb47-1360"></a>    <span class="fu">transfer_available</span>(s, direction, s2, n, start)</span>
<span id="cb47-1361"><a href="#cb47-1361"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="data-fragmentation-trait">Data Fragmentation Trait</h1>
<div class="sourceCode" id="cb48" data-startFrom="1368"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1367;"><span id="cb48-1368"><a href="#cb48-1368"></a><span class="kw">abstract type</span> ReadFragmentation <span class="kw">end</span></span>
<span id="cb48-1369"><a href="#cb48-1369"></a><span class="kw">struct</span> ReadsBytes         <span class="op">&lt;:</span><span class="dt"> ReadFragmentation </span><span class="kw">end</span></span>
<span id="cb48-1370"><a href="#cb48-1370"></a><span class="kw">struct</span> ReadsLines         <span class="op">&lt;:</span><span class="dt"> ReadFragmentation </span><span class="kw">end</span></span>
<span id="cb48-1371"><a href="#cb48-1371"></a><span class="kw">struct</span> ReadsPackets       <span class="op">&lt;:</span><span class="dt"> ReadFragmentation </span><span class="kw">end</span></span>
<span id="cb48-1372"><a href="#cb48-1372"></a><span class="kw">struct</span> ReadsRequestedSize <span class="op">&lt;:</span><span class="dt"> ReadFragmentation </span><span class="kw">end</span></span>
<span id="cb48-1373"><a href="#cb48-1373"></a><span class="kw">const</span> AnyReadFragmentation <span class="op">=</span> ReadFragmentation </span></code></pre></div>
<p>The <code>ReadFragmentation</code> trait describes what guarantees a
stream makes about fragmentation of data returned by the underlying
<code>read(2)</code> system call.</p>
<p><code>ReadFragmentation(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Data Fragmentation</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ReadsBytes()</code></td>
<td style="text-align: left;">No special guarantees about what is
returned by <code>read(2)</code>. This is the default.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ReadsLines()</code></td>
<td style="text-align: left;"><code>read(2)</code> returns exactly one
line at a time. Does not return partially buffered lines unless an
explicit <code>EOL</code> or <code>EOF</code> control character is
received. Applicable to Character devices in canonical mode. See <a
href="https://man7.org/linux/man-pages/man3/termios.3.html">termios(3)</a>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ReadsPackets()</code></td>
<td style="text-align: left;"><code>read(2)</code> returns exactly one
packet at a time. Does not return partially buffered packets. Applicable
to some sockets and pipes depending on configuration. e.g. See the
<code>O_DIRECT</code> flag in <a
href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe(2)</a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ReadsRequestedSize()</code></td>
<td style="text-align: left;"><code>read(2)</code> returns exactly the
number of elements requested. Applicable to local files and some virtual
files (e.g. <code>/dev/random</code>, <code>/dev/null</code>).</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb49" data-startFrom="1405"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1404;"><span id="cb49-1405"><a href="#cb49-1405"></a><span class="fu">ReadFragmentation</span>(s) <span class="op">=</span> <span class="fu">ReadFragmentation</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb49-1406"><a href="#cb49-1406"></a><span class="fu">ReadFragmentation</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">ReadFragmentation</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb49-1407"><a href="#cb49-1407"></a>                                           <span class="fu">ReadsBytes</span>()</span></code></pre></div>
<h1 id="performance-traits">Performance Traits</h1>
<div class="sourceCode" id="cb50" data-startFrom="1412"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1411;"><span id="cb50-1412"><a href="#cb50-1412"></a><span class="kw">abstract type</span> TransferCost <span class="kw">end</span></span>
<span id="cb50-1413"><a href="#cb50-1413"></a><span class="kw">struct</span> HighTransferCost <span class="op">&lt;:</span><span class="dt"> TransferCost </span><span class="kw">end</span></span>
<span id="cb50-1414"><a href="#cb50-1414"></a><span class="kw">struct</span> LowTransferCost <span class="op">&lt;:</span><span class="dt"> TransferCost </span><span class="kw">end</span></span>
<span id="cb50-1415"><a href="#cb50-1415"></a><span class="fu">TransferCost</span>(s) <span class="op">=</span> <span class="fu">TransferCost</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb50-1416"><a href="#cb50-1416"></a><span class="fu">TransferCost</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferCost</span>(T) <span class="op">:</span></span>
<span id="cb50-1417"><a href="#cb50-1417"></a>                                      <span class="fu">HighTransferCost</span>()</span>
<span id="cb50-1418"><a href="#cb50-1418"></a></span>
<span id="cb50-1419"><a href="#cb50-1419"></a></span>
<span id="cb50-1420"><a href="#cb50-1420"></a><span class="kw">const</span> kBytesPerSecond <span class="op">=</span> <span class="fu">Int</span>(<span class="fl">1e3</span>)</span>
<span id="cb50-1421"><a href="#cb50-1421"></a><span class="kw">const</span> MBytesPerSecond <span class="op">=</span> <span class="fu">Int</span>(<span class="fl">1e6</span>)</span>
<span id="cb50-1422"><a href="#cb50-1422"></a><span class="kw">const</span> GBytesPerSecond <span class="op">=</span> <span class="fu">Int</span>(<span class="fl">1e9</span>)</span>
<span id="cb50-1423"><a href="#cb50-1423"></a><span class="fu">DataRate</span>(s) <span class="op">=</span> <span class="fu">DataRate</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb50-1424"><a href="#cb50-1424"></a><span class="fu">DataRate</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">DataRate</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb50-1425"><a href="#cb50-1425"></a>                                  MBytesPerSecond</span></code></pre></div>
<h1 id="cursor-traits-mark-seek">Cursor Traits (Mark &amp; Seek)</h1>
<div class="sourceCode" id="cb51" data-startFrom="1430"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1429;"><span id="cb51-1430"><a href="#cb51-1430"></a><span class="kw">abstract type</span> CursorSupport <span class="kw">end</span></span>
<span id="cb51-1431"><a href="#cb51-1431"></a><span class="kw">abstract type</span> AbstractHasPosition <span class="op">&lt;:</span><span class="dt"> CursorSupport </span><span class="kw">end</span></span>
<span id="cb51-1432"><a href="#cb51-1432"></a><span class="kw">struct</span> NoCursors <span class="op">&lt;:</span><span class="dt"> CursorSupport </span><span class="kw">end</span></span>
<span id="cb51-1433"><a href="#cb51-1433"></a><span class="kw">struct</span> HasPosition <span class="op">&lt;:</span><span class="dt"> AbstractHasPosition </span><span class="kw">end</span></span>
<span id="cb51-1434"><a href="#cb51-1434"></a><span class="kw">struct</span> Seekable  <span class="op">&lt;:</span><span class="dt"> AbstractHasPosition </span><span class="kw">end</span></span>
<span id="cb51-1435"><a href="#cb51-1435"></a><span class="kw">struct</span> Markable  <span class="op">&lt;:</span><span class="dt"> AbstractHasPosition </span><span class="kw">end</span></span></code></pre></div>
<p>The <code>CursorSupport</code> trait describes mark and seek
capabilities.</p>
<p><code>CursorSupport(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Cursor Support</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>NoCursors()</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Seekable()</code></td>
<td style="text-align: left;">Supports <code>seek</code>,
<code>skip</code>, <code>seekstart</code> and <code>seekend</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Markable()</code></td>
<td style="text-align: left;">Is seekable, and also supports
<code>mark</code>, <code>ismarked</code>, <code>unmark</code>,
<code>reset</code>.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb52" data-startFrom="1453"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1452;"><span id="cb52-1453"><a href="#cb52-1453"></a><span class="fu">CursorSupport</span>(s) <span class="op">=</span> <span class="fu">CursorSupport</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb52-1454"><a href="#cb52-1454"></a><span class="fu">CursorSupport</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">CursorSupport</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb52-1455"><a href="#cb52-1455"></a>                                       <span class="fu">NoCursors</span>()</span>
<span id="cb52-1456"><a href="#cb52-1456"></a><span class="kw">const</span> NotMarkable <span class="op">=</span> <span class="dt">Union</span>{NoCursors,Seekable}</span>
<span id="cb52-1457"><a href="#cb52-1457"></a></span>
<span id="cb52-1458"><a href="#cb52-1458"></a><span class="fu">trait_error</span>(s, trait) <span class="op">=</span></span>
<span id="cb52-1459"><a href="#cb52-1459"></a>    <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">typeof</span>(s))<span class="st"> does not implement </span><span class="sc">$</span>trait<span class="st">&quot;</span>))</span>
<span id="cb52-1460"><a href="#cb52-1460"></a></span>
<span id="cb52-1461"><a href="#cb52-1461"></a><span class="bu">Base</span>.<span class="fu">seek</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, pos) <span class="op">=</span> <span class="fu">seek</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream), pos)</span>
<span id="cb52-1462"><a href="#cb52-1462"></a><span class="fu">_seek</span>(s, <span class="op">::</span><span class="dt">NoCursors</span>, pos) <span class="op">=</span> <span class="fu">trait_error</span>(s, Seekable)</span>
<span id="cb52-1463"><a href="#cb52-1463"></a></span>
<span id="cb52-1464"><a href="#cb52-1464"></a><span class="bu">Base</span>.<span class="fu">skip</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, offset) <span class="op">=</span> <span class="fu">_skip</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream), offset)</span>
<span id="cb52-1465"><a href="#cb52-1465"></a><span class="fu">_skip</span>(s, <span class="op">::</span><span class="dt">NoCursors</span>, offset) <span class="op">=</span> <span class="fu">trait_error</span>(s, Seekable)</span>
<span id="cb52-1466"><a href="#cb52-1466"></a></span>
<span id="cb52-1467"><a href="#cb52-1467"></a><span class="bu">Base</span>.<span class="fu">position</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_position</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream))</span>
<span id="cb52-1468"><a href="#cb52-1468"></a><span class="fu">_position</span>(s, <span class="op">::</span><span class="dt">NoCursors</span>) <span class="op">=</span> <span class="cn">nothing</span></span>
<span id="cb52-1469"><a href="#cb52-1469"></a></span>
<span id="cb52-1470"><a href="#cb52-1470"></a><span class="bu">Base</span>.<span class="fu">seekend</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_seekend</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream))</span>
<span id="cb52-1471"><a href="#cb52-1471"></a><span class="fu">_seekend</span>(s, <span class="op">::</span><span class="dt">NoCursors</span>) <span class="op">=</span> <span class="cn">nothing</span></span>
<span id="cb52-1472"><a href="#cb52-1472"></a></span>
<span id="cb52-1473"><a href="#cb52-1473"></a><span class="bu">Base</span>.<span class="fu">mark</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_mark</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream))</span>
<span id="cb52-1474"><a href="#cb52-1474"></a><span class="fu">_mark</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, Markable)</span>
<span id="cb52-1475"><a href="#cb52-1475"></a></span>
<span id="cb52-1476"><a href="#cb52-1476"></a><span class="bu">Base</span>.<span class="fu">unmark</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_unmark</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream))</span>
<span id="cb52-1477"><a href="#cb52-1477"></a><span class="fu">_unmark</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, Markable)</span>
<span id="cb52-1478"><a href="#cb52-1478"></a></span>
<span id="cb52-1479"><a href="#cb52-1479"></a><span class="bu">Base</span>.<span class="fu">reset</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_reset</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream))</span>
<span id="cb52-1480"><a href="#cb52-1480"></a><span class="fu">_reset</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, Markable)</span>
<span id="cb52-1481"><a href="#cb52-1481"></a></span>
<span id="cb52-1482"><a href="#cb52-1482"></a><span class="bu">Base</span>.<span class="fu">ismarked</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_ismarked</span>(io.stream, <span class="fu">CursorSupport</span>(io.stream))</span>
<span id="cb52-1483"><a href="#cb52-1483"></a><span class="fu">_ismarked</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, Markable)</span></code></pre></div>
<h1 id="peekable-trait">Peekable Trait</h1>
<div class="sourceCode" id="cb53" data-startFrom="1489"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1488;"><span id="cb53-1489"><a href="#cb53-1489"></a><span class="kw">abstract type</span> PeekSupport <span class="kw">end</span></span>
<span id="cb53-1490"><a href="#cb53-1490"></a><span class="kw">struct</span> Peekable <span class="op">&lt;:</span><span class="dt"> PeekSupport </span><span class="kw">end</span></span>
<span id="cb53-1491"><a href="#cb53-1491"></a><span class="kw">struct</span> NotPeekable <span class="op">&lt;:</span><span class="dt"> PeekSupport </span><span class="kw">end</span></span>
<span id="cb53-1492"><a href="#cb53-1492"></a><span class="fu">PeekSupport</span>(s) <span class="op">=</span> <span class="fu">PeekSupport</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb53-1493"><a href="#cb53-1493"></a><span class="fu">PeekSupport</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">PeekSupport</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb53-1494"><a href="#cb53-1494"></a>                                     <span class="fu">NotPeekable</span>()</span>
<span id="cb53-1495"><a href="#cb53-1495"></a></span>
<span id="cb53-1496"><a href="#cb53-1496"></a><span class="fu">_peek</span>(s, <span class="op">::</span><span class="dt">NotPeekable</span>, T) <span class="op">=</span> <span class="fu">trait_error</span>(s, Peekable)</span></code></pre></div>
<h1 id="timeout-stream">Timeout Stream</h1>
<pre><code>TimeoutStream(stream; timeout, deadline) -&gt; TimeoutStream
timeout_stream(stream; timeout=Inf, deadline=Inf) -&gt; Stream</code></pre>
<p>The temporary <code>TimeoutStream</code> wrapper adds an immutable
transfer deadline to a stream. It is used in cases where a stream
interface function needs to make multiple calls to <code>transfer</code>
(e.g. <code>readall</code>).</p>
<p>Note that the <code>timeout_stream</code> function simply returns
<code>stream</code> if <code>timeout</code> and <code>deadline</code>
are both <code>Inf</code>.</p>
<div class="sourceCode" id="cb55" data-startFrom="1513"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1512;"><span id="cb55-1513"><a href="#cb55-1513"></a><span class="kw">struct</span> TimeoutStream{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> Stream</span></span>
<span id="cb55-1514"><a href="#cb55-1514"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb55-1515"><a href="#cb55-1515"></a>    deadline<span class="op">::</span><span class="dt">Float64</span></span>
<span id="cb55-1516"><a href="#cb55-1516"></a>    <span class="kw">function</span> <span class="fu">TimeoutStream</span>(stream<span class="op">::</span><span class="dt">T</span>; timeout, deadline) <span class="kw">where</span> T</span>
<span id="cb55-1517"><a href="#cb55-1517"></a>        <span class="pp">@require</span> timeout <span class="op">&lt;</span> <span class="cn">Inf</span> <span class="op">||</span> deadline <span class="op">&lt;</span> <span class="cn">Inf</span></span>
<span id="cb55-1518"><a href="#cb55-1518"></a>        <span class="cf">if</span> timeout <span class="op">&lt;</span> <span class="cn">Inf</span></span>
<span id="cb55-1519"><a href="#cb55-1519"></a>            deadline <span class="op">=</span> <span class="fu">time</span>() <span class="op">+</span> timeout</span>
<span id="cb55-1520"><a href="#cb55-1520"></a>        <span class="cf">end</span></span>
<span id="cb55-1521"><a href="#cb55-1521"></a>        <span class="fu">new</span><span class="dt">{T}</span>(stream, deadline)</span>
<span id="cb55-1522"><a href="#cb55-1522"></a>    <span class="kw">end</span></span>
<span id="cb55-1523"><a href="#cb55-1523"></a><span class="kw">end</span></span>
<span id="cb55-1524"><a href="#cb55-1524"></a></span>
<span id="cb55-1525"><a href="#cb55-1525"></a><span class="fu">timeout_stream</span>(s<span class="op">::</span><span class="dt">TimeoutStream</span>; kw<span class="op">...</span>) <span class="op">=</span> <span class="fu">timeout_stream</span>(s.stream; kw<span class="op">...</span>)</span>
<span id="cb55-1526"><a href="#cb55-1526"></a></span>
<span id="cb55-1527"><a href="#cb55-1527"></a><span class="fu">timeout_stream</span>(s; timeout<span class="op">=</span><span class="cn">Inf</span>, deadline<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span></span>
<span id="cb55-1528"><a href="#cb55-1528"></a>    timeout <span class="op">==</span> <span class="cn">Inf</span> <span class="op">&amp;&amp;</span> deadline <span class="op">==</span> <span class="cn">Inf</span> ? s <span class="op">:</span> <span class="fu">TimeoutStream</span>(s; timeout, deadline)</span>
<span id="cb55-1529"><a href="#cb55-1529"></a></span>
<span id="cb55-1530"><a href="#cb55-1530"></a><span class="fu">StreamDelegation</span>(<span class="op">::</span><span class="dt">Type{&lt;:TimeoutStream}</span>) <span class="op">=</span> <span class="fu">DelegatedToSubStream</span>()</span>
<span id="cb55-1531"><a href="#cb55-1531"></a></span>
<span id="cb55-1532"><a href="#cb55-1532"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer</span>(s<span class="op">::</span><span class="dt">TimeoutStream{T}</span>, buffer,</span>
<span id="cb55-1533"><a href="#cb55-1533"></a>                      n<span class="op">::</span><span class="dt">Union{Missing, Integer}</span>; kw<span class="op">...</span>) <span class="kw">where</span> T</span>
<span id="cb55-1534"><a href="#cb55-1534"></a>    <span class="pp">@info</span> <span class="st">&quot;transfer(t::TimeoutStream, ...)&quot;</span></span>
<span id="cb55-1535"><a href="#cb55-1535"></a>    <span class="fu">transfer</span>(s.stream, buffer, n; deadline <span class="op">=</span> s.deadline, kw<span class="op">...</span>)</span>
<span id="cb55-1536"><a href="#cb55-1536"></a><span class="kw">end</span></span>
<span id="cb55-1537"><a href="#cb55-1537"></a></span>
<span id="cb55-1538"><a href="#cb55-1538"></a><span class="fu">unsafe_transfer</span>(s<span class="op">::</span><span class="dt">TimeoutStream</span>, direction, buffer, n) <span class="op">=</span></span>
<span id="cb55-1539"><a href="#cb55-1539"></a>    <span class="fu">unsafe_transfer</span>(s.stream, direction, buffer, n)</span></code></pre></div>
<h1 id="interface-functions">Interface Functions</h1>
<p>How many bytes remain before the end of <code>stream</code>?</p>
<div class="sourceCode" id="cb56" data-startFrom="1548"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1547;"><span id="cb56-1548"><a href="#cb56-1548"></a><span class="kw">function</span> <span class="fu">bytes_remaning</span>(stream<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb56-1549"><a href="#cb56-1549"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb56-1550"><a href="#cb56-1550"></a>    <span class="fu">bytes_remaining</span>(s, <span class="fu">TotalSize</span>(io), <span class="fu">CursorSupport</span>(io))</span>
<span id="cb56-1551"><a href="#cb56-1551"></a><span class="kw">end</span></span>
<span id="cb56-1552"><a href="#cb56-1552"></a></span>
<span id="cb56-1553"><a href="#cb56-1553"></a><span class="fu">bytes_remaining</span>(s, <span class="op">::</span><span class="dt">UnknownTotalSize</span>, <span class="op">::</span><span class="dt">Any</span>) <span class="op">=</span> <span class="cn">nothing</span></span>
<span id="cb56-1554"><a href="#cb56-1554"></a><span class="fu">bytes_reamaining</span>(s, <span class="op">::</span><span class="dt">InfiniteTotalSize</span>, <span class="op">::</span><span class="dt">Any</span>) <span class="op">=</span> <span class="fu">typemax</span>(<span class="dt">UInt</span>)</span>
<span id="cb56-1555"><a href="#cb56-1555"></a><span class="fu">bytes_remaining</span>(s, <span class="op">::</span><span class="dt">KnownTotalSize</span>, <span class="op">::</span><span class="dt">AbstractHasPosition</span>) <span class="op">=</span></span>
<span id="cb56-1556"><a href="#cb56-1556"></a>    <span class="fu">length</span>(s) <span class="op">-</span> <span class="fu">position</span>(s)</span></code></pre></div>
<p><code>readbyte</code> returns one byte (or <code>nothing</code> at
end of stream or if <code>timeout</code> expires).</p>
<p>Specialized based on Transfer Cost.</p>
<div class="sourceCode" id="cb57" data-startFrom="1566"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1565;"><span id="cb57-1566"><a href="#cb57-1566"></a><span class="kw">function</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">Stream</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb57-1567"><a href="#cb57-1567"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb57-1568"><a href="#cb57-1568"></a>    <span class="fu">readbyte</span>(s, <span class="fu">TransferCost</span>(s); timeout)</span>
<span id="cb57-1569"><a href="#cb57-1569"></a><span class="kw">end</span></span>
<span id="cb57-1570"><a href="#cb57-1570"></a></span>
<span id="cb57-1571"><a href="#cb57-1571"></a><span class="fu">readbyte</span>(s, <span class="op">::</span><span class="dt">HighTransferCost</span>; kw<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb57-1572"><a href="#cb57-1572"></a>    <span class="fu">error</span>(<span class="fu">typeof</span>(s), <span class="st">&quot; does not support byte I/O. &quot;</span>,</span>
<span id="cb57-1573"><a href="#cb57-1573"></a>          <span class="st">&quot;Consider using the `LazyBufferedInput` wrapper.&quot;</span>)</span></code></pre></div>
<p>Allow single byte read for interfaces with Low Transfer Cost, but
warn if a special Read Fragmentation trait is available.<span
class="sidenote-wrapper"><label for="sn-22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-22" class="margin-toggle"/><span
class="sidenote">⚠️ FIXME: Warnings should be configurable via
Preferences.jl<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb58" data-startFrom="1582"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1581;"><span id="cb58-1582"><a href="#cb58-1582"></a><span class="kw">function</span> <span class="fu">readbyte</span>(stream, <span class="op">::</span><span class="dt">LowTransferCost</span>; timeout)</span>
<span id="cb58-1583"><a href="#cb58-1583"></a>    <span class="cf">if</span> <span class="fu">ReadFragmentation</span>(stream) <span class="op">==</span> <span class="fu">ReadsLines</span>()</span>
<span id="cb58-1584"><a href="#cb58-1584"></a>        <span class="pp">@warn</span> <span class="st">&quot;read(::</span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st">, UInt8): &quot;</span> <span class="op">*</span></span>
<span id="cb58-1585"><a href="#cb58-1585"></a>              <span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st"> implements `IOTraits.ReadsLines`.&quot;</span> <span class="op">*</span></span>
<span id="cb58-1586"><a href="#cb58-1586"></a>              <span class="st">&quot;Reading one byte at a time may not be efficient.&quot;</span> <span class="op">*</span></span>
<span id="cb58-1587"><a href="#cb58-1587"></a>              <span class="st">&quot;Consider using `readline` instead.&quot;</span></span>
<span id="cb58-1588"><a href="#cb58-1588"></a>    <span class="cf">end</span></span>
<span id="cb58-1589"><a href="#cb58-1589"></a>    x <span class="op">=</span> <span class="fu">Ref</span><span class="dt">{UInt8}</span>()</span>
<span id="cb58-1590"><a href="#cb58-1590"></a>    n <span class="op">=</span> GC.<span class="pp">@preserve</span> x <span class="fu">transfer</span>(stream <span class="op">=&gt;</span> <span class="fu">pointer</span>(x), <span class="fl">1</span>)</span>
<span id="cb58-1591"><a href="#cb58-1591"></a>    n <span class="op">==</span> <span class="fl">1</span> <span class="op">||</span> <span class="cf">return</span> <span class="cn">nothing</span></span>
<span id="cb58-1592"><a href="#cb58-1592"></a>    <span class="cf">return</span> x[]</span>
<span id="cb58-1593"><a href="#cb58-1593"></a><span class="kw">end</span></span></code></pre></div>
<p><code>readall</code> reads until the end of <code>stream</code> (or
until <code>timeout</code> expires) and returns
<code>Vector{UInt8}</code>.</p>
<p>Specialise on Total Size and Cursor Support.</p>
<div class="sourceCode" id="cb59" data-startFrom="1603"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1602;"><span id="cb59-1603"><a href="#cb59-1603"></a><span class="kw">function</span> <span class="fu">readall</span>(s<span class="op">::</span><span class="dt">Stream</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb59-1604"><a href="#cb59-1604"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb59-1605"><a href="#cb59-1605"></a>    <span class="fu">readall</span>(s, <span class="fu">TotalSize</span>(s), <span class="fu">CursorSupport</span>(s); timeout)</span>
<span id="cb59-1606"><a href="#cb59-1606"></a><span class="kw">end</span></span>
<span id="cb59-1607"><a href="#cb59-1607"></a></span>
<span id="cb59-1608"><a href="#cb59-1608"></a></span>
<span id="cb59-1609"><a href="#cb59-1609"></a><span class="kw">function</span> <span class="fu">readall</span>(stream, <span class="op">::</span><span class="dt">UnknownTotalSize</span>, <span class="op">::</span><span class="dt">NoCursors</span>)</span>
<span id="cb59-1610"><a href="#cb59-1610"></a>    n <span class="op">=</span> <span class="fu">default_buffer_size</span>(stream)</span>
<span id="cb59-1611"><a href="#cb59-1611"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb59-1612"><a href="#cb59-1612"></a>    <span class="fu">_readbytes!</span>(stream, buf, <span class="fu">typemax</span>(<span class="dt">UInt</span>))</span>
<span id="cb59-1613"><a href="#cb59-1613"></a>    <span class="cf">return</span> buf</span>
<span id="cb59-1614"><a href="#cb59-1614"></a><span class="kw">end</span></span>
<span id="cb59-1615"><a href="#cb59-1615"></a></span>
<span id="cb59-1616"><a href="#cb59-1616"></a></span>
<span id="cb59-1617"><a href="#cb59-1617"></a><span class="kw">function</span> <span class="fu">readall</span>(stream, <span class="op">::</span><span class="dt">KnownTotalSize</span>, <span class="op">::</span><span class="dt">AbstractHasPosition</span>)</span>
<span id="cb59-1618"><a href="#cb59-1618"></a>    n <span class="op">=</span> <span class="fu">length</span>(stream) <span class="op">-</span> <span class="fu">position</span>(stream)</span>
<span id="cb59-1619"><a href="#cb59-1619"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb59-1620"><a href="#cb59-1620"></a>    <span class="fu">transferall</span>(stream, buf, n)</span>
<span id="cb59-1621"><a href="#cb59-1621"></a>    <span class="cf">return</span> buf</span>
<span id="cb59-1622"><a href="#cb59-1622"></a><span class="kw">end</span></span></code></pre></div>
<p>Transfer <code>n</code> items between <code>stream</code> and
<code>buf</code>.</p>
<p>Call <code>transfer</code> repeatedly until all <code>n</code> items
have been Transferred, stopping only if end of file is reached.</p>
<p>Return the number of items transferred.</p>
<div class="sourceCode" id="cb60" data-startFrom="1633"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1632;"><span id="cb60-1633"><a href="#cb60-1633"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transferall</span>(stream, buf, n<span class="op">=</span><span class="fu">length</span>(buf); deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb60-1634"><a href="#cb60-1634"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(stream; timeout, deadline)</span>
<span id="cb60-1635"><a href="#cb60-1635"></a>    ntransferred<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb60-1636"><a href="#cb60-1636"></a>    <span class="cf">while</span> ntransferred <span class="op">&lt;</span> n</span>
<span id="cb60-1637"><a href="#cb60-1637"></a>        r <span class="op">=</span> <span class="fu">transfer</span>(stream, buf, n <span class="op">-</span> ntransferred; start <span class="op">=</span> ntransferred <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb60-1638"><a href="#cb60-1638"></a>                                            <span class="co"># FIXME ^^^^^ passing start is not allowed for ToPut etc</span></span>
<span id="cb60-1639"><a href="#cb60-1639"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb60-1640"><a href="#cb60-1640"></a>            <span class="cf">break</span></span>
<span id="cb60-1641"><a href="#cb60-1641"></a>        <span class="cf">end</span></span>
<span id="cb60-1642"><a href="#cb60-1642"></a>        ntransferred <span class="op">+=</span> r</span>
<span id="cb60-1643"><a href="#cb60-1643"></a>    <span class="cf">end</span></span>
<span id="cb60-1644"><a href="#cb60-1644"></a>    <span class="pp">@ensure</span> ntransferred isa <span class="dt">UInt</span></span>
<span id="cb60-1645"><a href="#cb60-1645"></a>    <span class="pp">@db</span> <span class="cf">return</span> ntransferred</span>
<span id="cb60-1646"><a href="#cb60-1646"></a><span class="kw">end</span></span>
<span id="cb60-1647"><a href="#cb60-1647"></a></span>
<span id="cb60-1648"><a href="#cb60-1648"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transferall</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Stream,&lt;:Any}</span>, a<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb60-1649"><a href="#cb60-1649"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">1</span>]) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb60-1650"><a href="#cb60-1650"></a>    <span class="fu">transferall</span>(t[<span class="fl">1</span>], t[<span class="fl">2</span>], a<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb60-1651"><a href="#cb60-1651"></a><span class="kw">end</span></span>
<span id="cb60-1652"><a href="#cb60-1652"></a></span>
<span id="cb60-1653"><a href="#cb60-1653"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transferall</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Any,&lt;:Stream}</span>, a<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb60-1654"><a href="#cb60-1654"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">1</span>]) <span class="op">==</span> <span class="fu">Out</span>()</span>
<span id="cb60-1655"><a href="#cb60-1655"></a>    <span class="fu">transferall</span>(t[<span class="fl">2</span>], t[<span class="fl">1</span>], a<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb60-1656"><a href="#cb60-1656"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="null-streams">Null Streams</h1>
<p><code>NullIn()</code> is an input stream that does nothing. It is
intended to be used for testing Delegate Streams.</p>
<div class="sourceCode" id="cb61" data-startFrom="1668"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1667;"><span id="cb61-1668"><a href="#cb61-1668"></a><span class="kw">struct</span> NullIn <span class="op">&lt;:</span><span class="dt"> Stream </span><span class="kw">end</span></span>
<span id="cb61-1669"><a href="#cb61-1669"></a></span>
<span id="cb61-1670"><a href="#cb61-1670"></a><span class="fu">TransferDirection</span>(<span class="op">::</span><span class="dt">Type{NullIn}</span>) <span class="op">=</span> <span class="fu">In</span>()</span>
<span id="cb61-1671"><a href="#cb61-1671"></a></span>
<span id="cb61-1672"><a href="#cb61-1672"></a><span class="fu">transfer</span>(io<span class="op">::</span><span class="dt">NullIn</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, n; kw<span class="op">...</span>) <span class="op">=</span> n</span>
<span id="cb61-1673"><a href="#cb61-1673"></a></span>
<span id="cb61-1674"><a href="#cb61-1674"></a></span>
<span id="cb61-1675"><a href="#cb61-1675"></a><span class="co">#=</span></span>
<span id="cb61-1676"><a href="#cb61-1676"></a><span class="co">FIXME</span></span>
<span id="cb61-1677"><a href="#cb61-1677"></a><span class="co">include(&quot;wrap.jl&quot;)</span></span></code></pre></div>
<p><code>@delegate_io f</code> creates wrapper methods for function
<code>f</code>. A separate method is created with a specific 2nd
argument type for each 2nd argument type used in pre-existing methods of
<code>f</code> (to avoid method selection ambiguity). e.g.</p>
<pre><code>f(io::IODelegate; kw...) = f(unwrap(io); kw...)
f(io::IODelegate, a2::T, a...; kw...) = f(unwrap(io), a2, a...; kw...)</code></pre>
<div class="sourceCode" id="cb63" data-startFrom="1688"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1687;"><span id="cb63-1688"><a href="#cb63-1688"></a><span class="kw">macro</span> <span class="fu">delegate_io</span>(f, <span class="co">#= FIXME ---&gt; =#</span> D<span class="op">=</span>FullInDelegate, u<span class="op">=</span>unwrap)</span>
<span id="cb63-1689"><a href="#cb63-1689"></a>    methods <span class="op">=</span> [</span>
<span id="cb63-1690"><a href="#cb63-1690"></a>      <span class="fu">esc</span>(<span class="op">:</span>(( <span class="op">$</span><span class="fu">f</span>(io<span class="op">::</span><span class="dt">$D              </span>; k<span class="op">...</span>) <span class="op">=</span> <span class="op">$</span><span class="fu">f</span>(<span class="op">$</span><span class="fu">u</span>(io)          ; k<span class="op">...</span>)   ))),</span>
<span id="cb63-1691"><a href="#cb63-1691"></a>    ( <span class="fu">esc</span>(<span class="op">:</span>(( <span class="op">$</span><span class="fu">f</span>(io<span class="op">::</span><span class="dt">$D</span>, a<span class="op">::</span><span class="dt">$T</span>, aa<span class="op">...</span>; k<span class="op">...</span>) <span class="op">=</span> <span class="op">$</span><span class="fu">f</span>(<span class="op">$</span><span class="fu">u</span>(io), a, aa<span class="op">...</span>; k<span class="op">...</span>)   )))</span>
<span id="cb63-1692"><a href="#cb63-1692"></a>                         for T <span class="kw">in</span> <span class="fu">arg2_types</span>(<span class="bu">Main</span>.<span class="fu">eval</span>(<span class="op">:</span>(<span class="op">$</span>f)))</span>
<span id="cb63-1693"><a href="#cb63-1693"></a>    )<span class="op">...</span>]</span>
<span id="cb63-1694"><a href="#cb63-1694"></a>    (m<span class="op">-&gt;</span><span class="pp">@debug</span> m).(methods)</span>
<span id="cb63-1695"><a href="#cb63-1695"></a>    <span class="fu">Expr</span>(<span class="op">:</span>block, methods<span class="op">...</span>)</span>
<span id="cb63-1696"><a href="#cb63-1696"></a><span class="kw">end</span></span>
<span id="cb63-1697"><a href="#cb63-1697"></a></span>
<span id="cb63-1698"><a href="#cb63-1698"></a></span>
<span id="cb63-1699"><a href="#cb63-1699"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.read!</span>
<span id="cb63-1700"><a href="#cb63-1700"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readuntil</span>
<span id="cb63-1701"><a href="#cb63-1701"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readline</span>
<span id="cb63-1702"><a href="#cb63-1702"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.countlines</span>
<span id="cb63-1703"><a href="#cb63-1703"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.eachline</span>
<span id="cb63-1704"><a href="#cb63-1704"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readeach</span>
<span id="cb63-1705"><a href="#cb63-1705"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.unsafe_read</span>
<span id="cb63-1706"><a href="#cb63-1706"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.peek</span>
<span id="cb63-1707"><a href="#cb63-1707"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readavailable</span>
<span id="cb63-1708"><a href="#cb63-1708"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.mark</span>
<span id="cb63-1709"><a href="#cb63-1709"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.ismarked</span>
<span id="cb63-1710"><a href="#cb63-1710"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.unmark</span>
<span id="cb63-1711"><a href="#cb63-1711"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.reset</span>
<span id="cb63-1712"><a href="#cb63-1712"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.seek</span>
<span id="cb63-1713"><a href="#cb63-1713"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.position</span>
<span id="cb63-1714"><a href="#cb63-1714"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.seekend</span>
<span id="cb63-1715"><a href="#cb63-1715"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.seekstart</span>
<span id="cb63-1716"><a href="#cb63-1716"></a><span class="op">=</span><span class="co">#</span></span></code></pre></div>
<h1 id="buffered-streams">Buffered Streams</h1>
<p>Generic type for Buffered Input Wrappers.</p>
<p>See concrete types <code>BufferedInput</code> and
<code>LazyBufferedInput</code> below.</p>
<div class="sourceCode" id="cb64" data-startFrom="1727"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1726;"><span id="cb64-1727"><a href="#cb64-1727"></a><span class="kw">abstract type</span> GenericBufferedInput{T} <span class="op">&lt;:</span><span class="dt"> Stream </span><span class="kw">end</span></span>
<span id="cb64-1728"><a href="#cb64-1728"></a></span>
<span id="cb64-1729"><a href="#cb64-1729"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">show</span>(io<span class="op">::</span><span class="dt">IO</span>, s<span class="op">::</span><span class="dt">GenericBufferedInput{T}</span>) <span class="kw">where</span> T</span>
<span id="cb64-1730"><a href="#cb64-1730"></a>    <span class="fu">print</span>(io, <span class="st">&quot;GenericBufferedInput{&quot;</span>, T, <span class="st">&quot;}(&quot;</span>, <span class="fu">bytesavailable</span>(s.buffer), <span class="st">&quot;)&quot;</span>)</span>
<span id="cb64-1731"><a href="#cb64-1731"></a><span class="kw">end</span></span>
<span id="cb64-1732"><a href="#cb64-1732"></a></span>
<span id="cb64-1733"><a href="#cb64-1733"></a><span class="fu">StreamDelegation</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">DelegatedToSubStream</span>()</span>
<span id="cb64-1734"><a href="#cb64-1734"></a></span>
<span id="cb64-1735"><a href="#cb64-1735"></a><span class="fu">TransferCost</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">LowTransferCost</span>()</span>
<span id="cb64-1736"><a href="#cb64-1736"></a></span>
<span id="cb64-1737"><a href="#cb64-1737"></a><span class="fu">ReadFragmentation</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">ReadsBytes</span>()</span>
<span id="cb64-1738"><a href="#cb64-1738"></a></span>
<span id="cb64-1739"><a href="#cb64-1739"></a><span class="fu">PeekSupport</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">Peekable</span>()</span>
<span id="cb64-1740"><a href="#cb64-1740"></a></span>
<span id="cb64-1741"><a href="#cb64-1741"></a><span class="kw">function</span> <span class="fu">buffered_in_warning</span>(stream)</span>
<span id="cb64-1742"><a href="#cb64-1742"></a>    <span class="cf">if</span> <span class="fu">ReadFragmentation</span>(stream) <span class="op">!=</span> <span class="fu">ReadsBytes</span>()</span>
<span id="cb64-1743"><a href="#cb64-1743"></a>        <span class="pp">@warn</span> <span class="st">&quot;Wrapping </span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st"> with `BufferedInput` causes &quot;</span> <span class="op">*</span></span>
<span id="cb64-1744"><a href="#cb64-1744"></a>              <span class="st">&quot;the </span><span class="sc">$</span>(<span class="fu">ReadFragmentation</span>(stream))<span class="st"> trait to be ignored!&quot;</span></span>
<span id="cb64-1745"><a href="#cb64-1745"></a>    <span class="cf">end</span></span>
<span id="cb64-1746"><a href="#cb64-1746"></a>    <span class="cf">if</span> <span class="fu">TransferCost</span>(stream) <span class="op">==</span> <span class="fu">LowTransferCost</span>()</span>
<span id="cb64-1747"><a href="#cb64-1747"></a>        <span class="pp">@warn</span> <span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st"> already has LowTransfterCost. &quot;</span> <span class="op">*</span></span>
<span id="cb64-1748"><a href="#cb64-1748"></a>              <span class="st">&quot;Wrapping with `BufferedInput` may degrade performance.&quot;</span></span>
<span id="cb64-1749"><a href="#cb64-1749"></a>    <span class="cf">end</span></span>
<span id="cb64-1750"><a href="#cb64-1750"></a><span class="kw">end</span></span>
<span id="cb64-1751"><a href="#cb64-1751"></a></span>
<span id="cb64-1752"><a href="#cb64-1752"></a><span class="bu">Base</span>.<span class="fu">close</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>) <span class="op">=</span> ( <span class="fu">take!</span>(s.buffer);</span>
<span id="cb64-1753"><a href="#cb64-1753"></a>                                        <span class="bu">Base</span>.<span class="fu">close</span>(s.io) )</span></code></pre></div>
<p>Size of the internal buffer.</p>
<div class="sourceCode" id="cb65" data-startFrom="1759"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1758;"><span id="cb65-1759"><a href="#cb65-1759"></a><span class="fu">buffer_size</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>) <span class="op">=</span> s.buffer_size</span></code></pre></div>
<p>Buffer ~1 second of data by default.</p>
<div class="sourceCode" id="cb66" data-startFrom="1765"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1764;"><span id="cb66-1765"><a href="#cb66-1765"></a><span class="fu">default_buffer_size</span>(stream) <span class="op">=</span> <span class="fu">DataRate</span>(stream)</span></code></pre></div>
<p>Transfer bytes from the wrapped IO to the internal buffer.</p>
<div class="sourceCode" id="cb67" data-startFrom="1771"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1770;"><span id="cb67-1771"><a href="#cb67-1771"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">refill_internal_buffer</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>,</span>
<span id="cb67-1772"><a href="#cb67-1772"></a>                                    n<span class="op">=</span>s.buffer_size; kw<span class="op">...</span>)</span>
<span id="cb67-1773"><a href="#cb67-1773"></a>    <span class="co"># If needed, expand the buffer.</span></span>
<span id="cb67-1774"><a href="#cb67-1774"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb67-1775"><a href="#cb67-1775"></a>    <span class="pp">@assert</span> sbuf.append</span>
<span id="cb67-1776"><a href="#cb67-1776"></a>    <span class="bu">Base</span>.<span class="fu">ensureroom</span>(sbuf, n)</span>
<span id="cb67-1777"><a href="#cb67-1777"></a>    <span class="fu">checkbounds</span>(sbuf.data, sbuf.size<span class="op">+</span>n)</span>
<span id="cb67-1778"><a href="#cb67-1778"></a></span>
<span id="cb67-1779"><a href="#cb67-1779"></a>    <span class="co"># Transfer from the stream to the buffer.</span></span>
<span id="cb67-1780"><a href="#cb67-1780"></a>    p <span class="op">=</span> <span class="fu">pointer</span>(sbuf.data, sbuf.size<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb67-1781"><a href="#cb67-1781"></a>    n <span class="op">=</span> GC.<span class="pp">@preserve</span> sbuf <span class="fu">transfer</span>(s.stream, p, n; kw<span class="op">...</span>)</span>
<span id="cb67-1782"><a href="#cb67-1782"></a>    sbuf.size <span class="op">+=</span> n</span>
<span id="cb67-1783"><a href="#cb67-1783"></a>    <span class="cn">nothing</span></span>
<span id="cb67-1784"><a href="#cb67-1784"></a><span class="kw">end</span></span>
<span id="cb67-1785"><a href="#cb67-1785"></a></span>
<span id="cb67-1786"><a href="#cb67-1786"></a><span class="kw">function</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>; timeout)</span>
<span id="cb67-1787"><a href="#cb67-1787"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb67-1788"><a href="#cb67-1788"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(sbuf) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb67-1789"><a href="#cb67-1789"></a>        <span class="fu">refill_internal_buffer</span>(s; timeout)</span>
<span id="cb67-1790"><a href="#cb67-1790"></a>    <span class="cf">end</span></span>
<span id="cb67-1791"><a href="#cb67-1791"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(sbuf) <span class="op">!=</span> <span class="fl">0</span></span>
<span id="cb67-1792"><a href="#cb67-1792"></a>        <span class="cf">return</span> <span class="fu">read</span>(sbuf, <span class="dt">UInt8</span>)</span>
<span id="cb67-1793"><a href="#cb67-1793"></a>    <span class="cf">end</span></span>
<span id="cb67-1794"><a href="#cb67-1794"></a>    <span class="pp">@invoke</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">Stream</span>; timeout)</span>
<span id="cb67-1795"><a href="#cb67-1795"></a><span class="kw">end</span></span>
<span id="cb67-1796"><a href="#cb67-1796"></a></span>
<span id="cb67-1797"><a href="#cb67-1797"></a><span class="kw">function</span> <span class="fu">_peek</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>, <span class="op">::</span><span class="dt">Type{T}</span>; kw<span class="op">...</span>) <span class="kw">where</span> T</span>
<span id="cb67-1798"><a href="#cb67-1798"></a>    <span class="cf">while</span> <span class="fu">bytesavailable</span>(s.buffer) <span class="op">&lt;</span> <span class="fu">sizeof</span>(T)</span>
<span id="cb67-1799"><a href="#cb67-1799"></a>        <span class="fu">refill_internal_buffer</span>(s; kw<span class="op">...</span>)</span>
<span id="cb67-1800"><a href="#cb67-1800"></a>    <span class="cf">end</span></span>
<span id="cb67-1801"><a href="#cb67-1801"></a>    <span class="fu">peek</span>(s.buffer, T)</span>
<span id="cb67-1802"><a href="#cb67-1802"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="buffered-input">Buffered Input</h2>
<pre><code>BufferedInput(stream; [buffer_size]) -&gt; Stream</code></pre>
<p>Create a wrapper around <code>stream</code> to buffer input
transfers.</p>
<p>The wrapper will try to read <code>buffer_size</code> bytes into its
buffer every time it transfers data from <code>stream</code>.</p>
<p>The default <code>buffer_size</code> depends on
<code>IOTratis.DataRate(stream)</code>.</p>
<p><code>stream</code> must not be used directly after the wrapper is
created.</p>
<div class="sourceCode" id="cb69" data-startFrom="1820"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1819;"><span id="cb69-1820"><a href="#cb69-1820"></a><span class="kw">struct</span> BufferedInput{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> GenericBufferedInput{T}</span></span>
<span id="cb69-1821"><a href="#cb69-1821"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb69-1822"><a href="#cb69-1822"></a>    buffer<span class="op">::</span><span class="dt">IOBuffer</span></span>
<span id="cb69-1823"><a href="#cb69-1823"></a>    buffer_size<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb69-1824"><a href="#cb69-1824"></a>    <span class="kw">function</span> <span class="fu">BufferedInput</span>(stream<span class="op">::</span><span class="dt">T</span>; buffer_size<span class="op">=</span><span class="fu">default_buffer_size</span>(stream)) <span class="kw">where</span> T</span>
<span id="cb69-1825"><a href="#cb69-1825"></a>        <span class="pp">@require</span> <span class="fu">TransferDirection</span>(stream) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb69-1826"><a href="#cb69-1826"></a>        <span class="fu">buffered_in_warning</span>(stream)</span>
<span id="cb69-1827"><a href="#cb69-1827"></a>        <span class="fu">new</span><span class="dt">{T}</span>(stream, <span class="fu">PipeBuffer</span>(), buffer_size)</span>
<span id="cb69-1828"><a href="#cb69-1828"></a>    <span class="kw">end</span></span>
<span id="cb69-1829"><a href="#cb69-1829"></a><span class="kw">end</span></span>
<span id="cb69-1830"><a href="#cb69-1830"></a></span>
<span id="cb69-1831"><a href="#cb69-1831"></a><span class="fu">TransferSize</span>(<span class="op">::</span><span class="dt">Type{BufferedInput{T}}</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">LimitedTransferSize</span>()</span>
<span id="cb69-1832"><a href="#cb69-1832"></a></span>
<span id="cb69-1833"><a href="#cb69-1833"></a><span class="fu">max_transfer_size</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>) <span class="op">=</span> s.buffer_size</span></code></pre></div>
<p>The non-buffered method returns zero if there are not enough bytes
available to transfer a whole item (<code>ioelsize</code>). This method
refills the internal buffer if there are less than <code>ioelsize</code>
bytes available. Note that <code>refill_internal_buffer</code> may still
not yield enough bytes. However, calling it here ensures that the
enclosing retry loop will eventually get the data it needs.</p>
<div class="sourceCode" id="cb70" data-startFrom="1844"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1843;"><span id="cb70-1844"><a href="#cb70-1844"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer_available</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>, direction,</span>
<span id="cb70-1845"><a href="#cb70-1845"></a>                                buf, interface<span class="op">::</span><span class="dt">IsItemPtr</span>,</span>
<span id="cb70-1846"><a href="#cb70-1846"></a>                                n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb70-1847"><a href="#cb70-1847"></a>    <span class="pp">@assert</span> <span class="fu">ioelsize</span>(buf) <span class="op">&gt;</span> <span class="fl">1</span></span>
<span id="cb70-1848"><a href="#cb70-1848"></a>    <span class="pp">@assert</span> <span class="fu">ioelsize</span>(buf) <span class="op">&lt;</span> s.buffer_size</span>
<span id="cb70-1849"><a href="#cb70-1849"></a></span>
<span id="cb70-1850"><a href="#cb70-1850"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&lt;</span> <span class="fu">ioelsize</span>(buf)</span>
<span id="cb70-1851"><a href="#cb70-1851"></a>        <span class="fu">refill_internal_buffer</span>(s)</span>
<span id="cb70-1852"><a href="#cb70-1852"></a>    <span class="cf">end</span></span>
<span id="cb70-1853"><a href="#cb70-1853"></a></span>
<span id="cb70-1854"><a href="#cb70-1854"></a>    <span class="pp">@invoke</span> <span class="fu">transfer_available</span>(s<span class="op">::</span><span class="dt">Stream</span>, direction,</span>
<span id="cb70-1855"><a href="#cb70-1855"></a>                               buf, interface<span class="op">::</span><span class="dt">IsItemPtr</span>,</span>
<span id="cb70-1856"><a href="#cb70-1856"></a>                               n<span class="op">::</span><span class="dt">UInt</span>, start<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb70-1857"><a href="#cb70-1857"></a><span class="kw">end</span></span>
<span id="cb70-1858"><a href="#cb70-1858"></a></span>
<span id="cb70-1859"><a href="#cb70-1859"></a></span>
<span id="cb70-1860"><a href="#cb70-1860"></a></span>
<span id="cb70-1861"><a href="#cb70-1861"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">bytesavailable</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>) </span>
<span id="cb70-1862"><a href="#cb70-1862"></a>    n <span class="op">=</span> <span class="fu">bytesavailable</span>(s.buffer) </span>
<span id="cb70-1863"><a href="#cb70-1863"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb70-1864"><a href="#cb70-1864"></a>        n <span class="op">=</span> <span class="fu">bytesavailable</span>(s.stream) </span>
<span id="cb70-1865"><a href="#cb70-1865"></a>    <span class="cf">end</span></span>
<span id="cb70-1866"><a href="#cb70-1866"></a>    <span class="pp">@db</span> <span class="cf">return</span> n</span>
<span id="cb70-1867"><a href="#cb70-1867"></a><span class="kw">end</span></span>
<span id="cb70-1868"><a href="#cb70-1868"></a></span>
<span id="cb70-1869"><a href="#cb70-1869"></a></span>
<span id="cb70-1870"><a href="#cb70-1870"></a></span>
<span id="cb70-1871"><a href="#cb70-1871"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">unsafe_transfer</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>, <span class="op">::</span><span class="dt">In</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb70-1872"><a href="#cb70-1872"></a></span>
<span id="cb70-1873"><a href="#cb70-1873"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb70-1874"><a href="#cb70-1874"></a>    <span class="co"># If there are not enough bytes in `sbuf`, read more from the wrapped stream.</span></span>
<span id="cb70-1875"><a href="#cb70-1875"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(sbuf) <span class="op">&lt;</span> n</span>
<span id="cb70-1876"><a href="#cb70-1876"></a>        <span class="fu">refill_internal_buffer</span>(s)</span>
<span id="cb70-1877"><a href="#cb70-1877"></a>    <span class="cf">end</span></span>
<span id="cb70-1878"><a href="#cb70-1878"></a></span>
<span id="cb70-1879"><a href="#cb70-1879"></a>    <span class="co"># Read available bytes from `sbuf` into the caller&#39;s `buffer`.</span></span>
<span id="cb70-1880"><a href="#cb70-1880"></a>    n <span class="op">=</span> <span class="fu">min</span>(n, <span class="fu">bytesavailable</span>(sbuf))</span>
<span id="cb70-1881"><a href="#cb70-1881"></a>    <span class="fu">unsafe_read</span>(sbuf, buf, n)</span>
<span id="cb70-1882"><a href="#cb70-1882"></a>    <span class="pp">@db</span> <span class="cf">return</span> n</span>
<span id="cb70-1883"><a href="#cb70-1883"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="lazy-buffered-input">Lazy Buffered Input</h2>
<pre><code>LazyBufferedInput(stream; [buffer_size]) -&gt; Stream</code></pre>
<p>Create a wrapper around <code>stream</code> to buffer input
transfers.</p>
<p>The internal buffer is only used when a small transfer is attempted
or if <code>peek</code> is called. Most reads are fulfilled directly
from the underling stream. This avoids the overhead of double buffering
in situations where there is an occasional need to read one byte at a
time (e.g. <code>readuntil()</code>) but most reads are already of a
reasonable size.</p>
<p>The default <code>buffer_size</code> depends on
<code>IOTratis.DataRate(io)</code>.</p>
<p><code>stream</code> must not be used directly after the wrapper is
created.</p>
<div class="sourceCode" id="cb72" data-startFrom="1905"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1904;"><span id="cb72-1905"><a href="#cb72-1905"></a><span class="kw">struct</span> LazyBufferedInput{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> GenericBufferedInput{T}</span></span>
<span id="cb72-1906"><a href="#cb72-1906"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb72-1907"><a href="#cb72-1907"></a>    buffer<span class="op">::</span><span class="dt">IOBuffer</span></span>
<span id="cb72-1908"><a href="#cb72-1908"></a>    buffer_size<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb72-1909"><a href="#cb72-1909"></a>    <span class="kw">function</span> <span class="fu">LazyBufferedInput</span>(s<span class="op">::</span><span class="dt">T</span>; buffer_size<span class="op">=</span><span class="fu">default_buffer_size</span>(s)) <span class="kw">where</span> T</span>
<span id="cb72-1910"><a href="#cb72-1910"></a>        <span class="pp">@require</span> <span class="fu">TransferDirection</span>(s) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb72-1911"><a href="#cb72-1911"></a>        <span class="fu">buffered_in_warning</span>(s)</span>
<span id="cb72-1912"><a href="#cb72-1912"></a>        <span class="fu">new</span><span class="dt">{T}</span>(s, <span class="fu">PipeBuffer</span>(), buffer_size)</span>
<span id="cb72-1913"><a href="#cb72-1913"></a>    <span class="kw">end</span></span>
<span id="cb72-1914"><a href="#cb72-1914"></a><span class="kw">end</span></span>
<span id="cb72-1915"><a href="#cb72-1915"></a></span>
<span id="cb72-1916"><a href="#cb72-1916"></a></span>
<span id="cb72-1917"><a href="#cb72-1917"></a><span class="bu">Base</span>.<span class="fu">bytesavailable</span>(s<span class="op">::</span><span class="dt">LazyBufferedInput</span>) <span class="op">=</span> <span class="fu">bytesavailable</span>(s.buffer) <span class="op">+</span> </span>
<span id="cb72-1918"><a href="#cb72-1918"></a>                                            <span class="fu">bytesavailable</span>(s.stream);</span>
<span id="cb72-1919"><a href="#cb72-1919"></a></span>
<span id="cb72-1920"><a href="#cb72-1920"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">unsafe_transfer</span>(s<span class="op">::</span><span class="dt">LazyBufferedInput</span>, <span class="op">::</span><span class="dt">In</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb72-1921"><a href="#cb72-1921"></a></span>
<span id="cb72-1922"><a href="#cb72-1922"></a>    <span class="co"># First take bytes from the buffer.</span></span>
<span id="cb72-1923"><a href="#cb72-1923"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb72-1924"><a href="#cb72-1924"></a>    count <span class="op">=</span> <span class="fu">bytesavailable</span>(sbuf)</span>
<span id="cb72-1925"><a href="#cb72-1925"></a>    <span class="cf">if</span> count <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb72-1926"><a href="#cb72-1926"></a>        count <span class="op">=</span> <span class="fu">min</span>(count, n)</span>
<span id="cb72-1927"><a href="#cb72-1927"></a>        <span class="fu">unsafe_read</span>(sbuf, buf, count)</span>
<span id="cb72-1928"><a href="#cb72-1928"></a>    <span class="cf">end</span></span>
<span id="cb72-1929"><a href="#cb72-1929"></a></span>
<span id="cb72-1930"><a href="#cb72-1930"></a>    <span class="co"># Then read from the wrapped IO.</span></span>
<span id="cb72-1931"><a href="#cb72-1931"></a>    <span class="cf">if</span> n <span class="op">&gt;</span> count</span>
<span id="cb72-1932"><a href="#cb72-1932"></a>        count <span class="op">+=</span> <span class="fu">unsafe_transfer</span>(s.stream, <span class="fu">In</span>(), buf <span class="op">+</span> count, n <span class="op">-</span> count)</span>
<span id="cb72-1933"><a href="#cb72-1933"></a>    <span class="cf">end</span></span>
<span id="cb72-1934"><a href="#cb72-1934"></a></span>
<span id="cb72-1935"><a href="#cb72-1935"></a>    <span class="pp">@ensure</span> count <span class="op">&lt;=</span> n</span>
<span id="cb72-1936"><a href="#cb72-1936"></a>    <span class="pp">@db</span> <span class="cf">return</span> count</span>
<span id="cb72-1937"><a href="#cb72-1937"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="base.io-interface">Base.IO Interface</h1>
<div class="sourceCode" id="cb73" data-startFrom="1943"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1942;"><span id="cb73-1943"><a href="#cb73-1943"></a><span class="bu">Base</span>.<span class="fu">isreadable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb73-1944"><a href="#cb73-1944"></a><span class="bu">Base</span>.<span class="fu">iswritable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">is_output</span>(io.stream)</span></code></pre></div>
<h2 id="function-eof">Function <code>eof</code></h2>
<p><code>eof</code> is specialised on Total Size.</p>
<div class="sourceCode" id="cb74" data-startFrom="1952"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1951;"><span id="cb74-1952"><a href="#cb74-1952"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">eof</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb74-1953"><a href="#cb74-1953"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb74-1954"><a href="#cb74-1954"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(io) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb74-1955"><a href="#cb74-1955"></a>        <span class="cf">return</span> <span class="cn">false</span></span>
<span id="cb74-1956"><a href="#cb74-1956"></a>    <span class="cf">end</span></span>
<span id="cb74-1957"><a href="#cb74-1957"></a>    <span class="cf">if</span> <span class="fu">bytes_remaining</span>(io) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb74-1958"><a href="#cb74-1958"></a>        <span class="cf">return</span> <span class="cn">true</span></span>
<span id="cb74-1959"><a href="#cb74-1959"></a>    <span class="cf">end</span></span>
<span id="cb74-1960"><a href="#cb74-1960"></a>    <span class="fu">wait</span>(io.stream; kw<span class="op">...</span>)</span>
<span id="cb74-1961"><a href="#cb74-1961"></a>    <span class="cf">return</span> <span class="fu">bytesavailable</span>(io) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb74-1962"><a href="#cb74-1962"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readio-t">Function <code>read(io, T)</code></h2>
<div class="sourceCode" id="cb75" data-startFrom="1967"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1966;"><span id="cb75-1967"><a href="#cb75-1967"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, <span class="op">::</span><span class="dt">Type{UInt8}</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb75-1968"><a href="#cb75-1968"></a>    x <span class="op">=</span> <span class="fu">readbyte</span>(io.stream, timeout)</span>
<span id="cb75-1969"><a href="#cb75-1969"></a>    x <span class="op">!=</span> <span class="cn">nothing</span> <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">EOFError</span>())</span>
<span id="cb75-1970"><a href="#cb75-1970"></a>    <span class="cf">return</span> x</span>
<span id="cb75-1971"><a href="#cb75-1971"></a><span class="kw">end</span></span></code></pre></div>
<p>Read as String.<br />
Wrap with <code>TimeoutStream</code> if timeout is requested.</p>
<div class="sourceCode" id="cb76" data-startFrom="1978"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1977;"><span id="cb76-1978"><a href="#cb76-1978"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, <span class="op">::</span><span class="dt">Type{String}</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb76-1979"><a href="#cb76-1979"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb76-1980"><a href="#cb76-1980"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb76-1981"><a href="#cb76-1981"></a>    <span class="fu">String</span>(<span class="fu">_read</span>(stream, <span class="fu">TotalSize</span>(stream), <span class="fu">CursorSupport</span>(stream)))</span>
<span id="cb76-1982"><a href="#cb76-1982"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readbytes">Function <code>readbytes!</code></h2>
<div class="sourceCode" id="cb77" data-startFrom="1988"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1987;"><span id="cb77-1988"><a href="#cb77-1988"></a><span class="bu">Base</span>.<span class="fu">readbytes!</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Vector{UInt8}</span>, nbytes<span class="op">=</span><span class="fu">length</span>(buf); kw<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb77-1989"><a href="#cb77-1989"></a>    <span class="fu">readbytes!</span>(io, buf, <span class="fu">UInt</span>(nbytes); kw<span class="op">...</span>)</span>
<span id="cb77-1990"><a href="#cb77-1990"></a></span>
<span id="cb77-1991"><a href="#cb77-1991"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readbytes!</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Vector{UInt8}</span>, nbytes<span class="op">::</span><span class="dt">UInt</span>;</span>
<span id="cb77-1992"><a href="#cb77-1992"></a>                         all<span class="op">::</span><span class="dt">Bool</span>=<span class="cn">true</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb77-1993"><a href="#cb77-1993"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb77-1994"><a href="#cb77-1994"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb77-1995"><a href="#cb77-1995"></a>    <span class="fu">_readbytes!</span>(stream, buf, nbytes; all)</span>
<span id="cb77-1996"><a href="#cb77-1996"></a><span class="kw">end</span></span>
<span id="cb77-1997"><a href="#cb77-1997"></a></span>
<span id="cb77-1998"><a href="#cb77-1998"></a><span class="kw">function</span> <span class="fu">_readbytes!</span>(stream, buf, nbytes; all<span class="op">=</span><span class="cn">true</span>)</span>
<span id="cb77-1999"><a href="#cb77-1999"></a>    lb<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fu">length</span>(buf)</span>
<span id="cb77-2000"><a href="#cb77-2000"></a>    nread <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb77-2001"><a href="#cb77-2001"></a>    <span class="cf">while</span> nread <span class="op">&lt;</span> nbytes</span>
<span id="cb77-2002"><a href="#cb77-2002"></a>        <span class="pp">@assert</span> nread <span class="op">&lt;=</span> lb</span>
<span id="cb77-2003"><a href="#cb77-2003"></a>        <span class="cf">if</span> (lb <span class="op">-</span> nread) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb77-2004"><a href="#cb77-2004"></a>            lb <span class="op">=</span> lb <span class="op">==</span> <span class="fl">0</span> ? nbytes <span class="op">:</span> <span class="fu">min</span>(lb <span class="op">*</span> <span class="fl">10</span>, nbytes)</span>
<span id="cb77-2005"><a href="#cb77-2005"></a>            <span class="fu">resize!</span>(buf, lb)</span>
<span id="cb77-2006"><a href="#cb77-2006"></a>        <span class="cf">end</span></span>
<span id="cb77-2007"><a href="#cb77-2007"></a>        <span class="pp">@assert</span> lb <span class="op">&gt;</span> nread</span>
<span id="cb77-2008"><a href="#cb77-2008"></a>        n <span class="op">=</span> <span class="fu">transfer</span>(stream <span class="op">=&gt;</span> buf, lb <span class="op">-</span> nread; start <span class="op">=</span> nread <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb77-2009"><a href="#cb77-2009"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span> <span class="op">||</span> !all</span>
<span id="cb77-2010"><a href="#cb77-2010"></a>            <span class="cf">break</span></span>
<span id="cb77-2011"><a href="#cb77-2011"></a>        <span class="cf">end</span></span>
<span id="cb77-2012"><a href="#cb77-2012"></a>        nread <span class="op">+=</span> n</span>
<span id="cb77-2013"><a href="#cb77-2013"></a>    <span class="cf">end</span></span>
<span id="cb77-2014"><a href="#cb77-2014"></a>    <span class="pp">@ensure</span> nread <span class="op">&lt;=</span> nbytes</span>
<span id="cb77-2015"><a href="#cb77-2015"></a>    <span class="cf">return</span> nread</span>
<span id="cb77-2016"><a href="#cb77-2016"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readstream">Function <code>read(stream)</code></h2>
<div class="sourceCode" id="cb78" data-startFrom="2022"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2021;"><span id="cb78-2022"><a href="#cb78-2022"></a><span class="bu">Base</span>.<span class="fu">read</span>(io; timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span> <span class="fu">readall</span>(io.stream; timeout)</span></code></pre></div>
<h2 id="function-readstream-n">Function
<code>read(stream, n)</code></h2>
<div class="sourceCode" id="cb79" data-startFrom="2029"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2028;"><span id="cb79-2029"><a href="#cb79-2029"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(stream<span class="op">::</span><span class="dt">BaseIO</span>, n<span class="op">::</span><span class="dt">Integer</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb79-2030"><a href="#cb79-2030"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb79-2031"><a href="#cb79-2031"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb79-2032"><a href="#cb79-2032"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb79-2033"><a href="#cb79-2033"></a>    <span class="fu">transfer_n</span>(stream, buf, n)</span>
<span id="cb79-2034"><a href="#cb79-2034"></a>    <span class="cf">return</span> buf</span>
<span id="cb79-2035"><a href="#cb79-2035"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-unsafe_read">Function <code>unsafe_read</code></h2>
<p><code>unsafe_read</code> must keep trying until <code>nbytes</code>
nave been transferred.</p>
<div class="sourceCode" id="cb80" data-startFrom="2043"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2042;"><span id="cb80-2043"><a href="#cb80-2043"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">unsafe_read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, nbytes<span class="op">::</span><span class="dt">UInt</span>;</span>
<span id="cb80-2044"><a href="#cb80-2044"></a>                          timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb80-2045"><a href="#cb80-2045"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb80-2046"><a href="#cb80-2046"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb80-2047"><a href="#cb80-2047"></a>    nread <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb80-2048"><a href="#cb80-2048"></a>    <span class="pp">@debug</span> <span class="st">&quot;Base.unsafe_read(io::BaseIO, buf::Ptr{UInt8}, nbytes::UInt)&quot;</span></span>
<span id="cb80-2049"><a href="#cb80-2049"></a>    <span class="cf">while</span> nread <span class="op">&lt;</span> nbytes</span>
<span id="cb80-2050"><a href="#cb80-2050"></a>        n <span class="op">=</span> <span class="fu">transfer</span>(stream <span class="op">=&gt;</span> (buf <span class="op">+</span> nread), nbytes <span class="op">-</span> nread)</span>
<span id="cb80-2051"><a href="#cb80-2051"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb80-2052"><a href="#cb80-2052"></a>            <span class="fu">throw</span>(<span class="fu">EOFError</span>())</span>
<span id="cb80-2053"><a href="#cb80-2053"></a>        <span class="cf">end</span></span>
<span id="cb80-2054"><a href="#cb80-2054"></a>        nread <span class="op">+=</span> n</span>
<span id="cb80-2055"><a href="#cb80-2055"></a>    <span class="cf">end</span></span>
<span id="cb80-2056"><a href="#cb80-2056"></a>    <span class="pp">@ensure</span> nread <span class="op">==</span> nbytes</span>
<span id="cb80-2057"><a href="#cb80-2057"></a>    <span class="cn">nothing</span></span>
<span id="cb80-2058"><a href="#cb80-2058"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readavailable">Function <code>readavailable</code></h2>
<pre><code>readavailable(stream::BaseIO; [timeout=0]) -&gt; Vector{UInt8}</code></pre>
<p>Read immediately available data from a stream.</p>
<p>If <code>Availability(stream)</code> is
<code>UnknownAvailability()</code> the only way to know how much data is
available is to attempt a transfer.</p>
<p>Otherwise, the amount of data immediately available can be queried
using the <code>bytesavailable</code> function.</p>
<div class="sourceCode" id="cb82" data-startFrom="2075"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2074;"><span id="cb82-2075"><a href="#cb82-2075"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readavailable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; timeout<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb82-2076"><a href="#cb82-2076"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb82-2077"><a href="#cb82-2077"></a>    <span class="cf">if</span> <span class="fu">Availability</span>(io.stream) <span class="op">==</span> <span class="fu">UnknownAvailability</span>()</span>
<span id="cb82-2078"><a href="#cb82-2078"></a>        n <span class="op">=</span> <span class="fu">default_buffer_size</span>(io.stream)</span>
<span id="cb82-2079"><a href="#cb82-2079"></a>    <span class="cf">else</span></span>
<span id="cb82-2080"><a href="#cb82-2080"></a>        n <span class="op">=</span> <span class="fu">bytesavailable</span>(io.stream)</span>
<span id="cb82-2081"><a href="#cb82-2081"></a>    <span class="cf">end</span></span>
<span id="cb82-2082"><a href="#cb82-2082"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb82-2083"><a href="#cb82-2083"></a>    n <span class="op">=</span> <span class="fu">transfer</span>(stream, buf, n; timeout)</span>
<span id="cb82-2084"><a href="#cb82-2084"></a>    <span class="fu">resize!</span>(buf, n)</span>
<span id="cb82-2085"><a href="#cb82-2085"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readline">Function <code>readline</code></h2>
<p><code>readline</code> is specialised based on the Read Fragmentation
trait.</p>
<div class="sourceCode" id="cb83" data-startFrom="2094"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2093;"><span id="cb83-2094"><a href="#cb83-2094"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readline</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; timeout<span class="op">=</span><span class="cn">Inf</span>, kw<span class="op">...</span>)</span>
<span id="cb83-2095"><a href="#cb83-2095"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb83-2096"><a href="#cb83-2096"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb83-2097"><a href="#cb83-2097"></a>    <span class="fu">_readline</span>(stream, <span class="fu">ReadFragmentation</span>(stream); kw<span class="op">...</span>)</span>
<span id="cb83-2098"><a href="#cb83-2098"></a><span class="kw">end</span></span></code></pre></div>
<p>If there is no special Read Fragmentation method, invoke the default
<code>Base.IO</code> method.</p>
<div class="sourceCode" id="cb84" data-startFrom="2104"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2103;"><span id="cb84-2104"><a href="#cb84-2104"></a><span class="fu">_readline</span>(stream, <span class="op">::</span><span class="dt">AnyReadFragmentation</span>; kw<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb84-2105"><a href="#cb84-2105"></a>    <span class="pp">@invoke</span> <span class="bu">Base</span>.<span class="fu">readline</span>(<span class="fu">BaseIO</span>(stream)<span class="op">::</span><span class="dt">IO</span>; kw<span class="op">...</span>)</span></code></pre></div>
<p>If Reads Lines is supported then simply calling <code>transfer</code>
once will read one line.</p>
<p>Character or Terminal devices (<code>S_IFCHR</code>) are often used
in “canonical mode” (<code>ICANON</code>).</p>
<blockquote>
<p>“In canonical mode: Input is made available line by line.” <a
href="https://man7.org/linux/man-pages/man3/termios.3.html">termios(3)</a>.</p>
</blockquote>
<p>For these devices calling <code>read(2)</code> will usually return
exactly one line. It will only ever return an incomplete line if length
exceeded <code>MAX_CANON</code>. Note that in canonical mode a line can
be terminated by <code>CEOF</code> rather than “”, but
<code>read(2)</code> does not return the <code>CEOF</code> character
(e.g. when the shell sends a “bash$” prompt without a newline).</p>
<div class="sourceCode" id="cb85" data-startFrom="2125"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2124;"><span id="cb85-2125"><a href="#cb85-2125"></a><span class="kw">function</span> <span class="fu">_readline</span>(stream, <span class="op">::</span><span class="dt">ReadsLines</span>; keep<span class="op">::</span><span class="dt">Bool</span>=<span class="cn">false</span>, kw<span class="op">...</span>)</span>
<span id="cb85-2126"><a href="#cb85-2126"></a></span>
<span id="cb85-2127"><a href="#cb85-2127"></a>    v <span class="op">=</span> <span class="bu">Base</span>.<span class="fu">StringVector</span>(max_line)</span>
<span id="cb85-2128"><a href="#cb85-2128"></a>    n <span class="op">=</span> <span class="fu">transfer</span>(stream <span class="op">=&gt;</span> v; kw<span class="op">...</span>)</span>
<span id="cb85-2129"><a href="#cb85-2129"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb85-2130"><a href="#cb85-2130"></a>        <span class="cf">return</span> <span class="st">&quot;&quot;</span></span>
<span id="cb85-2131"><a href="#cb85-2131"></a>    <span class="cf">end</span></span>
<span id="cb85-2132"><a href="#cb85-2132"></a></span>
<span id="cb85-2133"><a href="#cb85-2133"></a>    <span class="co"># Trim end of line characters.</span></span>
<span id="cb85-2134"><a href="#cb85-2134"></a>    <span class="cf">while</span> !keep <span class="op">&amp;&amp;</span> n <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> (v[n] <span class="op">==</span> <span class="fu">UInt8</span>(<span class="ch">&#39;\r&#39;</span>) <span class="op">||</span></span>
<span id="cb85-2135"><a href="#cb85-2135"></a>                             v[n] <span class="op">==</span> <span class="fu">UInt8</span>(<span class="ch">&#39;\n&#39;</span>))</span>
<span id="cb85-2136"><a href="#cb85-2136"></a>        n <span class="op">-=</span> <span class="fl">1</span></span>
<span id="cb85-2137"><a href="#cb85-2137"></a>    <span class="cf">end</span></span>
<span id="cb85-2138"><a href="#cb85-2138"></a></span>
<span id="cb85-2139"><a href="#cb85-2139"></a>    <span class="cf">return</span> <span class="fu">String</span>(<span class="fu">resize!</span>(v, n))</span>
<span id="cb85-2140"><a href="#cb85-2140"></a><span class="kw">end</span></span>
<span id="cb85-2141"><a href="#cb85-2141"></a></span>
<span id="cb85-2142"><a href="#cb85-2142"></a><span class="kw">const</span> max_line <span class="op">=</span> <span class="fl">1024</span> <span class="co"># UnixIO.C.MAX_CANON</span></span></code></pre></div>
<h2 id="function-readuntil">Function <code>readuntil</code></h2>
<div class="sourceCode" id="cb86" data-startFrom="2147"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2146;"><span id="cb86-2147"><a href="#cb86-2147"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readuntil</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, d<span class="op">::</span><span class="dt">AbstractChar</span>; timeout<span class="op">=</span><span class="cn">Inf</span>, kw<span class="op">...</span>)</span>
<span id="cb86-2148"><a href="#cb86-2148"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb86-2149"><a href="#cb86-2149"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb86-2150"><a href="#cb86-2150"></a>    <span class="pp">@invoke</span> <span class="bu">Base</span>.<span class="fu">readuntil</span>(<span class="fu">BaseIO</span>(stream)<span class="op">::</span><span class="dt">IO</span>, d; kw<span class="op">...</span>)</span>
<span id="cb86-2151"><a href="#cb86-2151"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="exports">Exports</h1>
<div class="sourceCode" id="cb87" data-startFrom="2157"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2156;"><span id="cb87-2157"><a href="#cb87-2157"></a><span class="kw">export</span> TraitsIO, TransferDirection, transfer, transferall, readall</span>
<span id="cb87-2158"><a href="#cb87-2158"></a></span>
<span id="cb87-2159"><a href="#cb87-2159"></a><span class="kw">export</span> BufferedInput, LazyBufferedInput</span>
<span id="cb87-2160"><a href="#cb87-2160"></a></span>
<span id="cb87-2161"><a href="#cb87-2161"></a><span class="kw">export</span> TotalSize,</span>
<span id="cb87-2162"><a href="#cb87-2162"></a>       UnknownTotalSize, InfiniteTotalSize, KnownTotalSize, VariableTotalSize,</span>
<span id="cb87-2163"><a href="#cb87-2163"></a>       FixedTotalSize</span>
<span id="cb87-2164"><a href="#cb87-2164"></a></span>
<span id="cb87-2165"><a href="#cb87-2165"></a><span class="kw">export</span> Availability,</span>
<span id="cb87-2166"><a href="#cb87-2166"></a>       AlwaysAvailable, PartiallyAvailable, UnknownAvailability</span>
<span id="cb87-2167"><a href="#cb87-2167"></a></span>
<span id="cb87-2168"><a href="#cb87-2168"></a><span class="kw">export</span> TransferSize,</span>
<span id="cb87-2169"><a href="#cb87-2169"></a>       UnlimitedTransferSize, LimitedTransferSize,</span>
<span id="cb87-2170"><a href="#cb87-2170"></a>       FixedTransferSize</span>
<span id="cb87-2171"><a href="#cb87-2171"></a></span>
<span id="cb87-2172"><a href="#cb87-2172"></a><span class="kw">export</span> TransferSizeMechanism,</span>
<span id="cb87-2173"><a href="#cb87-2173"></a>       NoSizeMechanism, SupportsFIONREAD, SupportsStatSize</span>
<span id="cb87-2174"><a href="#cb87-2174"></a></span>
<span id="cb87-2175"><a href="#cb87-2175"></a><span class="kw">export</span> ReadFragmentation,</span>
<span id="cb87-2176"><a href="#cb87-2176"></a>       ReadsBytes, ReadsLines, ReadsPackets, ReadsRequestedSize</span>
<span id="cb87-2177"><a href="#cb87-2177"></a></span>
<span id="cb87-2178"><a href="#cb87-2178"></a><span class="kw">export</span> WaitingMechanism,</span>
<span id="cb87-2179"><a href="#cb87-2179"></a>       WaitBySleeping, WaitUsingPosixPoll, WaitUsingEPoll, WaitUsingPidFD,</span>
<span id="cb87-2180"><a href="#cb87-2180"></a>       WaitUsingKQueue</span>
<span id="cb87-2181"><a href="#cb87-2181"></a></span>
<span id="cb87-2182"><a href="#cb87-2182"></a><span class="kw">export</span> CursorSupport, AbstractHasPosition,</span>
<span id="cb87-2183"><a href="#cb87-2183"></a>       NoCursors,</span>
<span id="cb87-2184"><a href="#cb87-2184"></a>       HasPosition,</span>
<span id="cb87-2185"><a href="#cb87-2185"></a>       Seekable,</span>
<span id="cb87-2186"><a href="#cb87-2186"></a>       Markable</span></code></pre></div>
<h2 id="possibly-related-issues">Possibly Related Issues</h2>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Issue</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/14747">14747</a></td>
<td>Intermittent deadlock in readbytes(open(echo $text)) on Linux ?</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/22832">22832</a></td>
<td>Deadlock in reading stdout from cmd.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/1970">1970</a></td>
<td>Serial Port support.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/2640">2640</a></td>
<td>Pseudo-tty support.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/10292">10292</a></td>
<td>write on IOBuffer with a maxsize</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/484">484</a></td>
<td>add uv_device_t as stream on windows and Linux to handle device
IO</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/3887">3887</a></td>
<td>refactor I/O to do more buffering</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/28975">28975</a></td>
<td>readline not working for ls</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24440">24440</a></td>
<td>Spawning turns IO race into process hang</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/20812">20812</a></td>
<td>Redirected STDOUT on macOS is hanging when more than 512 bytes are
written at once</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24717">24717</a></td>
<td>Pipe objects have lost their asyncness</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/36639">36639</a></td>
<td>slow printing in terminals</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/39727">39727</a></td>
<td>Bi-directional IOStream seems to mix input and output “Things work
fine when I replace open/read/write with ccall to open/read/write,
i.e. when I bypass julia IO.”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/17070">17070</a></td>
<td>Keyword argument docs for read are misleading. (all=true)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/40793">40793</a></td>
<td>readbytes!: support the all keyword for all methods. “I’ve
encountered cases where it doesn’t seems block.”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24526">24526</a></td>
<td>Review of IO blocking behaviour</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/33799">33799</a></td>
<td>Don’t export position. Position is zero-based.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/36954">36954</a></td>
<td>Rename <code>position</code> to <code>streampos</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/40500">40500</a></td>
<td><code>peek</code> breaks <code>mark</code>. “…any plans to publish a
proper interface for io one day?”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/41291">41291</a></td>
<td>PR: added docs for IO interface</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/40966">40966</a></td>
<td>sendfile: operation not supported error</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/35907">35907</a></td>
<td>Slow disk IO on MacOS</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/30044">30044</a></td>
<td>massive slowdowns using stdin/stdout “It seems like PipeEndpoint is
just really, really slow.”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24810">24810</a></td>
<td>Improve documentation for process interaction using pipes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24242">24242</a></td>
<td>Add isseekable to Stream/IO interface?</td>
</tr>
</tbody>
</table>
<h2 id="errors">Errors</h2>
<div class="sourceCode" id="cb88" data-startFrom="2258"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2257;"><span id="cb88-2258"><a href="#cb88-2258"></a><span class="kw">struct</span> IOTraitsError <span class="op">&lt;:</span><span class="dt"> Exception</span></span>
<span id="cb88-2259"><a href="#cb88-2259"></a>    stream<span class="op">::</span><span class="dt">Stream</span></span>
<span id="cb88-2260"><a href="#cb88-2260"></a>    message<span class="op">::</span><span class="dt">String</span></span>
<span id="cb88-2261"><a href="#cb88-2261"></a><span class="kw">end</span></span>
<span id="cb88-2262"><a href="#cb88-2262"></a></span>
<span id="cb88-2263"><a href="#cb88-2263"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">show</span>(io<span class="op">::</span><span class="dt">IO</span>, <span class="cn">e</span><span class="op">::</span><span class="dt">IOTraitsError</span>)</span>
<span id="cb88-2264"><a href="#cb88-2264"></a>    <span class="fu">print</span>(io, <span class="st">&quot;IOTraitsError: &quot;</span>, <span class="cn">e</span>.message)</span>
<span id="cb88-2265"><a href="#cb88-2265"></a><span class="kw">end</span></span>
<span id="cb88-2266"><a href="#cb88-2266"></a></span>
<span id="cb88-2267"><a href="#cb88-2267"></a></span>
<span id="cb88-2268"><a href="#cb88-2268"></a></span>
<span id="cb88-2269"><a href="#cb88-2269"></a><span class="im">using</span> <span class="bu">ReadmeDocs</span></span>
<span id="cb88-2270"><a href="#cb88-2270"></a></span>
<span id="cb88-2271"><a href="#cb88-2271"></a><span class="fu">include</span>(<span class="st">&quot;ioinfo.jl&quot;</span>) <span class="co"># Generate Method Resolution Info</span></span>
<span id="cb88-2272"><a href="#cb88-2272"></a></span>
<span id="cb88-2273"><a href="#cb88-2273"></a><span class="kw">end</span> <span class="co"># module IOTraits</span></span></code></pre></div>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
