<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Copyright Sam O'Connor." />
  <meta name="dcterms.date" content="2022-12-19" />
  <title>README</title>
  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/paper.css" />
  <link rel="stylesheet" href="../../css/skylighting-paper-theme.css" />
  <link rel="stylesheet" href="../../css/readmedocs.css" />
</head>
<body>

<header>

<table class="xrt_head">
  <tr><td>
  <b><a href="https://github.com/notinaboat/UnixIO.jl" style="white-space: pre">https://github.com/notinaboat/UnixIO.jl</a></b>
  <td width="100%" style="text-align: center">
  <b>Copyright OC Technology Pty Ltd</b>
  </td><td style="text-align: right">
  <font face="Helvetica">
  <font size="+2.5">
  <b><font color="#0080FF">oc</font><font color="#000000">tech</font></b>
  </font>
  </td></tr>
</table>
<hr style="margin-top: 0;">
<table class="xrt_head">
<tr><td><code>v0.3.3-32-ge3f234f</code></td><td style="text-align: right">2022-12-19</td></tr>
</table>

</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#iotraits.jl" id="toc-iotraits.jl">IOTraits.jl</a>
  <ul>
  <li><a href="#background" id="toc-background">Background</a></li>
  <li><a href="#overview" id="toc-overview">Overview</a></li>
  <li><a href="#the-io-interface-model"
  id="toc-the-io-interface-model">The IO Interface Model</a>
  <ul>
  <li><a href="#io-or-stream" id="toc-io-or-stream">IO or
  Stream?</a></li>
  <li><a href="#aspects-of-the-stream-interface"
  id="toc-aspects-of-the-stream-interface">Aspects of the Stream
  interface</a></li>
  <li><a href="#atomicity-of-transfers"
  id="toc-atomicity-of-transfers">Atomicity of Transfers</a></li>
  <li><a href="#generic-code-and-dependance-on-traits"
  id="toc-generic-code-and-dependance-on-traits">Generic Code and
  Dependance on Traits</a></li>
  <li><a href="#stream-interface-functions"
  id="toc-stream-interface-functions">Stream Interface
  Functions</a></li>
  <li><a href="#notes" id="toc-notes">Notes</a></li>
  <li><a href="#methods-of-base-functions-for-streams"
  id="toc-methods-of-base-functions-for-streams">Methods of Base
  Functions for Streams</a></li>
  <li><a href="#methods-of-base-functions-for-streams-1"
  id="toc-methods-of-base-functions-for-streams-1">Methods of Base
  Functions for Streams</a></li>
  <li><a href="#stream-delegation-wrappers"
  id="toc-stream-delegation-wrappers">Stream Delegation
  Wrappers</a></li>
  </ul></li>
  <li><a href="#unfiled-notes" id="toc-unfiled-notes">Unfiled
  Notes</a></li>
  </ul></li>
  <li><a href="#transfer-direction-trait"
  id="toc-transfer-direction-trait">Transfer Direction Trait</a></li>
  <li><a href="#io-indexing-trait" id="toc-io-indexing-trait">IO
  Indexing Trait</a></li>
  <li><a href="#data-transfer-function"
  id="toc-data-transfer-function">Data Transfer Function</a>
  <ul>
  <li><a href="#transfera-b"
  id="toc-transfera-b"><code>transfer!(a =&gt; b)</code></a></li>
  <li><a href="#waiting-for-the-deadline"
  id="toc-waiting-for-the-deadline">Waiting for the Deadline</a></li>
  </ul></li>
  <li><a href="#transfer-mode-trait"
  id="toc-transfer-mode-trait">Transfer Mode Trait</a></li>
  <li><a href="#transfer-interface-trait"
  id="toc-transfer-interface-trait">Transfer Interface Trait</a></li>
  <li><a href="#waiting-interface-trait"
  id="toc-waiting-interface-trait">Waiting Interface Trait</a>
  <ul>
  <li><a href="#preferred-polling-interface"
  id="toc-preferred-polling-interface">Preferred Polling
  Interface</a></li>
  <li><a href="#wait-by-sleeping-method"
  id="toc-wait-by-sleeping-method">Wait By Sleeping Method</a></li>
  <li><a href="#specialised-waiting-methods"
  id="toc-specialised-waiting-methods">Specialised Waiting
  Methods</a></li>
  </ul></li>
  <li><a href="#buffer-interface-traits"
  id="toc-buffer-interface-traits">Buffer Interface Traits</a></li>
  <li><a href="#total-data-size-trait"
  id="toc-total-data-size-trait">Total Data Size Trait</a></li>
  <li><a href="#transfer-size-trait"
  id="toc-transfer-size-trait">Transfer Size Trait</a></li>
  <li><a href="#data-availability-trait"
  id="toc-data-availability-trait">Data Availability Trait</a></li>
  <li><a href="#transfer-function-dispatch"
  id="toc-transfer-function-dispatch">Transfer Function Dispatch</a>
  <ul>
  <li><a
  href="#application-of-the-direction-and-buffer-interface-traits"
  id="toc-application-of-the-direction-and-buffer-interface-traits">Application
  of the Direction and Buffer Interface Traits</a></li>
  <li><a href="#low-level-byte-stream-methods"
  id="toc-low-level-byte-stream-methods">Low Level Byte-Stream
  Methods</a></li>
  <li><a href="#transfer-specialisations-for-indexable-buffers"
  id="toc-transfer-specialisations-for-indexable-buffers">Transfer
  Specialisations for Indexable Buffers</a></li>
  <li><a href="#transfer-specialisations-for-iterable-buffers"
  id="toc-transfer-specialisations-for-iterable-buffers">Transfer
  Specialisations for Iterable Buffers</a></li>
  <li><a href="#transfer-specialisations-for-collection-buffers"
  id="toc-transfer-specialisations-for-collection-buffers">Transfer
  Specialisations for Collection Buffers</a></li>
  <li><a href="#transfer-specialisations-for-io-buffers"
  id="toc-transfer-specialisations-for-io-buffers">Transfer
  Specialisations for IO Buffers</a></li>
  </ul></li>
  <li><a href="#data-fragmentation-trait"
  id="toc-data-fragmentation-trait">Data Fragmentation Trait</a></li>
  <li><a href="#performance-traits"
  id="toc-performance-traits">Performance Traits</a></li>
  <li><a href="#cursor-traits-mark-seek"
  id="toc-cursor-traits-mark-seek">Cursor Traits (Mark &amp;
  Seek)</a></li>
  <li><a href="#peekable-trait" id="toc-peekable-trait">Peekable
  Trait</a></li>
  <li><a href="#timeout-stream" id="toc-timeout-stream">Timeout
  Stream</a></li>
  <li><a href="#interface-functions"
  id="toc-interface-functions">Interface Functions</a></li>
  <li><a href="#first-isproxyunwrap" id="toc-first-isproxyunwrap">-
  first isproxy/unwrap</a></li>
  <li><a href="#then-apply-traits" id="toc-then-apply-traits">- then
  apply traits</a></li>
  <li><a href="#conveniance-interfcae-method"
  id="toc-conveniance-interfcae-method">- Conveniance interfcae
  method</a></li>
  <li><a href="#transforms-inputs-implements-default-values"
  id="toc-transforms-inputs-implements-default-values">- transforms
  inputs, implements default values</a></li>
  <li><a href="#no-side-effects-other-than-calling-a-core-method"
  id="toc-no-side-effects-other-than-calling-a-core-method">- no
  side-effects other than calling a core method</a></li>
  <li><a href="#main-interfcae-method" id="toc-main-interfcae-method">-
  Main interfcae method</a></li>
  <li><a href="#checks-preconditions" id="toc-checks-preconditions">-
  checks preconditions</a></li>
  <li><a href="#does-not-call-other-methods-of-same-function"
  id="toc-does-not-call-other-methods-of-same-function">- does not call
  other methods of same function</a></li>
  <li><a href="#calls-main-imeplemetation-method"
  id="toc-calls-main-imeplemetation-method">- calls Main imeplemetation
  method</a></li>
  <li><a href="#checks-postcondition" id="toc-checks-postcondition">-
  checks postcondition</a></li>
  <li><a href="#main-implementation-method"
  id="toc-main-implementation-method">- Main implementation
  method</a></li>
  <li><a href="#different-non-exported-name-to-interface-method"
  id="toc-different-non-exported-name-to-interface-method">- different
  non-exported name to interface method</a></li>
  <li><a
  href="#implements-trait-based-fan-out-to-other-implenentation-methods"
  id="toc-implements-trait-based-fan-out-to-other-implenentation-methods">-
  implements trait-based fan-out to other implenentation
  methods</a></li>
  <li><a href="#section" id="toc-section"></a></li>
  <li><a href="#null-streams" id="toc-null-streams">Null
  Streams</a></li>
  <li><a href="#buffered-streams" id="toc-buffered-streams">Buffered
  Streams</a>
  <ul>
  <li><a href="#buffered-input" id="toc-buffered-input">Buffered
  Input</a></li>
  <li><a href="#lazy-buffered-input" id="toc-lazy-buffered-input">Lazy
  Buffered Input</a></li>
  </ul></li>
  <li><a href="#base.io-interface" id="toc-base.io-interface">Base.IO
  Interface</a>
  <ul>
  <li><a href="#function-eof" id="toc-function-eof">Function
  <code>eof</code></a></li>
  </ul></li>
  <li><a href="#if-length_is_knowns-bytesremainings-0"
  id="toc-if-length_is_knowns-bytesremainings-0">if length_is_known(s)
  &amp;&amp; bytesremaining(s) == 0</a></li>
  <li><a href="#db-return-true" id="toc-db-return-true"><span
  class="citation" data-cites="db">@db</span> return true</a></li>
  <li><a href="#end" id="toc-end">end</a>
  <ul>
  <li><a href="#function-readio-t" id="toc-function-readio-t">Function
  <code>read(io, T)</code></a></li>
  </ul></li>
  <li><a href="#readio-a-deadline-time-timeout"
  id="toc-readio-a-deadline-time-timeout">read(io, a…; deadline = time()
  + timeout)</a>
  <ul>
  <li><a href="#function-readbytes" id="toc-function-readbytes">Function
  <code>readbytes!</code></a></li>
  <li><a href="#function-readstream"
  id="toc-function-readstream">Function
  <code>read(stream)</code></a></li>
  <li><a href="#function-readstream-n"
  id="toc-function-readstream-n">Function
  <code>read(stream, n)</code></a></li>
  <li><a href="#function-unsafe_read"
  id="toc-function-unsafe_read">Function
  <code>unsafe_read</code></a></li>
  <li><a href="#function-readavailable"
  id="toc-function-readavailable">Function
  <code>readavailable</code></a></li>
  <li><a href="#function-readline" id="toc-function-readline">Function
  <code>readline</code></a></li>
  <li><a href="#function-readuntil" id="toc-function-readuntil">Function
  <code>readuntil</code></a></li>
  <li><a href="#function-writestream-x"
  id="toc-function-writestream-x">Function
  <code>write(stream, x)</code></a></li>
  </ul></li>
  <li><a href="#exports" id="toc-exports">Exports</a>
  <ul>
  <li><a href="#possibly-related-issues"
  id="toc-possibly-related-issues">Possibly Related Issues</a></li>
  <li><a href="#errors" id="toc-errors">Errors</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<h1 id="iotraits.jl">IOTraits.jl</h1>
<p><a
href="https://www.juliabloggers.com/the-emergent-features-of-julialang-part-ii-traits/">Trait
types</a> for describing the capabilities and behaviour of IO
interfaces.</p>
<div class="sourceCode" id="cb1" data-startFrom="7"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 6;"><span id="cb1-7"><a href="#cb1-7"></a><span class="kw">module</span> IOTraits</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="im">using</span> <span class="bu">Preconditions</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="im">using</span> <span class="bu">Markdown</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="im">using</span> <span class="bu">Preferences</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="im">using</span> <span class="bu">Mmap</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="fu">include</span>(<span class="st">&quot;../../../src/macroutils.jl&quot;</span>)</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="im">using</span> <span class="bu">UnixIOHeaders</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="kw">const</span> C <span class="op">=</span> UnixIOHeaders</span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="fu">include</span>(<span class="st">&quot;../../../src/debug.jl&quot;</span>)</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>    <span class="pp">@db</span> <span class="kw">function</span> <span class="fu">__init__</span>()</span>
<span id="cb1-20"><a href="#cb1-20"></a>        <span class="pp">@ccall</span>(<span class="fu">jl_generating_output</span>()<span class="op">::</span><span class="dt">Cint</span>) <span class="op">==</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> <span class="cf">return</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>        <span class="fu">debug_init</span>()</span>
<span id="cb1-22"><a href="#cb1-22"></a>        <span class="pp">@db</span> <span class="fl">1</span> <span class="st">&quot;UnixIO.DEBUG_LEVEL = </span><span class="sc">$</span>DEBUG_LEVEL<span class="st">. See `src/debug.jl`.&quot;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="kw">end</span></span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="fu">include</span>(<span class="st">&quot;idoc.jl&quot;</span>)</span>
<span id="cb1-26"><a href="#cb1-26"></a></span>
<span id="cb1-27"><a href="#cb1-27"></a></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="co">#Allocation    | Termination             | Block   | </span></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co">#------------- | ----------------------- | ------- | </span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="co">#New `String`. | Current length of file. | Yes.    | </span></span></code></pre></div>
<p>FIXME<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">⚠️<br />
<br />
</span></span></p>
<p>Idea for table</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 30%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Intent</th>
<th style="text-align: left;">transfer! API</th>
<th style="text-align: left;">Base.IO API</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Write at most <code>n</code> bytes from a
byte-vector into a stream (<code>v::Vector{UInt8}</code>). Don’t wait
for the stream to be ready to accept all <code>n</code> bytes, just
transfer as much as the stream will immediately accept.</td>
<td
style="text-align: left;"><code>transfer!(v =&gt; s, n) -&gt; n</code></td>
<td style="text-align: left;">?</td>
</tr>
<tr class="even">
<td style="text-align: left;">Wait as long as it takes to Write entire
content of a byte-vector into a stream.
e.g. <code>v::Vector{UInt8}</code></td>
<td
style="text-align: left;"><code>transferall!(v =&gt; s) -&gt; n</code></td>
<td style="text-align: left;"><code>write(s, v)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read at most <code>n</code> bytes from a
file into a byte-vector: <code>v = Vector{UInt8}(undef, n)</code>.<br />
Read at least one byte (unless the file is empty). FIXME test cases
reading huge files over slow NFS. FIXME internally query block size and
do small async eads? use a timeout to return less than <code>n</code>?
or a heuristic value of bytes ?</td>
<td
style="text-align: left;"><code>transfer!(f =&gt; v, n) -&gt; n</code></td>
<td
style="text-align: left;"><code>open(i-&gt;readbytes!(i, v, n), f)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Wait as long as it takes to read all
<code>n</code> bytes from a file into a byte-vector (or all remaining
bytes if less than <code>n</code> remain).<br />
<code>v = Vector{UInt8}(undef, n)</code></td>
<td
style="text-align: left;"><code>transferall!(f =&gt; v, n)</code></td>
<td
style="text-align: left;"><code>open(i-&gt;readbytes!(i, v, n; all=true), f) -&gt; ::Int</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read at most <code>n</code> bytes from a
file into an abstract byte-vector.
e.g. <code>v::SubArray{UInt8}</code></td>
<td
style="text-align: left;"><code>transfer!(f =&gt; v, n) -&gt; n</code></td>
<td
style="text-align: left;"><code>open(i-&gt;readbytes!(i, v, n), f)</code><br />
💔 fails with “no method matching <code>resize!(::SubArray</code>…” if
`length(v) &lt; n.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read at least one and at most n pairs of
Int64 values from a file into a vector.
<code>v = Vector{Tuple{Int64,Int64}}(undef, n)</code></td>
<td
style="text-align: left;"><code>transfer!(f =&gt; v, n) -&gt; n</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read at most <code>n</code> bytes from a
socket into a byte-vector. Wait for at least one byte unless socket
shuts down.</td>
<td
style="text-align: left;"><code>transfer!(s =&gt; v, n) -&gt; n</code></td>
<td style="text-align: left;"><code>readbytes!(i, v, n)</code><br />
💔 for sockets this call blocks waiting for <code>n</code> bytes<br />
(<code>all=false</code> fails with “unsupported keyword argument”).</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read at least one and at most
<code>n</code> bytes from <code>stdin</code> into a byte-vector.</td>
<td
style="text-align: left;"><code>transfer!(s =&gt; v, n) -&gt; n</code></td>
<td style="text-align: left;"><code>readbytes!(i, v, n)</code><br />
💔 for sockets this call blocks waiting for <code>n</code> bytes<br />
(`all=false fails with “unsupported keyword argument”).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read at most <code>n</code> bytes from
<code>stdin</code> into a byte-vector. Return after 1 second if no bytes
are available.</td>
<td
style="text-align: left;"><code>transfer!(s =&gt; v, n; timeout=1) -&gt; n</code></td>
<td style="text-align: left;">?</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read at most <code>n</code> bytes from
<code>stdin</code> into a byte-vector, return immediatly if no bytes are
available.</td>
<td
style="text-align: left;"><code>transfer!(s =&gt; v, n; timeout=0) -&gt; n</code></td>
<td style="text-align: left;">💔 No way to read <code>stdin</code>
without waiting for at least one byte.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read at most <code>n</code> bytes from a
stream into a byte-vector at a specified index.</td>
<td
style="text-align: left;"><code>transfer!(s =&gt; v, n; buffer_i=7) -&gt; n</code></td>
<td style="text-align: left;">readbytes!(s, view(v, 7:length(v)),
n)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Read at most <code>n</code> bytes from a
specified file offset into a byte-vector.</td>
<td
style="text-align: left;"><code>transfer!(f =&gt; v, n; stream_i=7) -&gt; n</code></td>
<td style="text-align: left;"><code>@lock f try</code><br />
<code>p = position(i)</code><br />
<code>seek(f, 7)</code><br />
<code>readbytes!(s, v, n)</code><br />
<code>finally</code><br />
<code>seek(f, p)</code><br />
<code>end</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Find out how many bytes are immediatly
available to read from <code>stdin</code>, a socket or a file.</td>
<td
style="text-align: left;"><code>bytesavailable(x) -&gt; n</code></td>
<td style="text-align: left;"><code>bytesavailable(x)</code><br />
💔 Always returns zero for <code>stdin</code>, sockets and files.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Find out how many bytes will be available
to read before the stream is finished.</td>
<td
style="text-align: left;"><code>bytesremaining(x) -&gt; n</code></td>
<td style="text-align: left;">?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Find out if a stream is is finished.
i.e. the end of the file has been reached, or the stream has been shut
down and no more bytes will be available. (Note: a file may become
un-finished if more bytes are appended after the end of the file)</td>
<td style="text-align: left;"><code>isfinished(x)</code></td>
<td style="text-align: left;"><code>eof(x)</code><br />
💔 Sometimes blocks to wait for more bytes.<br />
💔 Sometimes returns true when more data might be available in the
future. <a
href="https://github.com/JuliaLang/julia/issues/24526">24526</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Read all <code>n</code> bytes from a
socket into a byte-vector (or fewer than <code>n</code> if the socket
shuts down). <code>v = Vector{UInt8}(undef, n)</code></td>
<td
style="text-align: left;"><code>transferall!(s =&gt; v, n)</code></td>
<td style="text-align: left;"><code>readbytes!(s, v, n; all=true)</code>
💔 for sockets fails with “no method matching
<code>readbytes!(::Base.PipeEndpoint</code>… unsupported keyword
argument ‘all’”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read entire content of a file into a new
string.<br />
<code>f = "myfile.txt"; v = Vector{UInt8}(undef, length(f))</code>.</td>
<td style="text-align: left;"><code>transferall!(f =&gt; v)</code><br />
<code>String(v)</code><br />
or readall!(f) |&gt; String</td>
<td
style="text-align: left;"><code>read(f, String) -&gt; ::String</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Read entire content of a file into a new
byte-vector-vector.<br />
<code>f = "myfile.txt"; v = Vector{Vector{UInt8}}()</code>.</td>
<td style="text-align: left;"><code>transferall!(f =&gt; v)</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read entire content of a socket into a
channel <code>c = Channel{Vector{UInt8}}()</code>.</td>
<td style="text-align: left;"><code>transferall!(s =&gt; c)</code></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="background">Background</h2>
<p>This collection of Trait types began as a tool for resolving method
selection issues in the UnixIO.jl package.</p>
<p>Everything in Unix is a file, but there are many different types of
file, a few different types of Unix, and many ways a file handle can be
configured.</p>
<p>Selection of correct (or most efficient) methods can often be
achieved with a simple type hierarchy. However traits seem to be useful
way to deal with variations in behaviour that depend file handle
configuration and platform.</p>
<p>In general <code>libc</code>’s <code>write(2)</code> and
<code>read(2)</code> can be used to transfer data to or from any Unix
file descriptor. However, the precise behaviour of these functions
depends on many factors.</p>
<p>Will <code>read</code> block?, if not, will it return less than the
requested number of bytes? Can I query the number of bytes available to
read first? How should I wait for more bytes? If more than one line is
buffered will <code>read</code> return all of them? Will read ever
return a partial line? Will every call to <code>write(2)</code> result
in a packet being transmitted? Is it efficient to write one byte at a
time? Does <code>lseek</code> work with this file? Does
<code>FIONREAD</code> work with this file?</p>
<p>The answers depend on combinations of file type, configuration and
platform.</p>
<p>IOTraits expands on the traits from UnixIO.jl in the hope of making
them more broadly useful. However, according to the <a
href="https://en.wikipedia.org/wiki/Law_of_the_hammer">law of the
hammer</a> some of this is probably overkill. The intention is to
consider the application of Trait types to various aspects of IO and to
see where it leads.</p>
<h2 id="overview">Overview</h2>
<p>The IOTraits interface is built around the function
<code>transfer!(stream, buffer)</code>. This function transfers data
between a stream and a buffer.</p>
<p>Traits are used to specify the behaviour of the stream and the
buffer.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Trait</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>TransferDirection</code></td>
<td style="text-align: left;">Which way is the transfer?<br />
(<code>In</code>, <code>Out</code> or <code>Exchange</code>).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>StreamIndexing</code></td>
<td style="text-align: left;">Is indexed stream access supported?
(e.g. <code>pread(2)</code>)<br />
(<code>NotIndexable</code>, <code>IndexableIO</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FromBufferInterface</code></td>
<td style="text-align: left;">How to get data from the buffer?<br />
(<code>FromIO</code>, <code>FromStream</code>, <code>UsingIndex</code>,
<code>FromIteration</code> or <code>UsingPtr</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ToBufferInterface</code></td>
<td style="text-align: left;">How to put data into the buffer?<br />
(<code>ToIO</code>, <code>ToStream</code>, <code>ToPush</code>,
<code>ToPut</code>, <code>UsingIndex</code> or
<code>UsingPtr</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>TotalSize{T}</code></td>
<td style="text-align: left;">How much data is available?<br />
(<code>T</code> = <code>:Zero</code>, <code>:Unknown</code>,
<code>:Variable</code>, <code>:Fixed</code>, or
<code>:Infinite</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>TransferSize{T}</code></td>
<td style="text-align: left;">How much data can be moved in a single
transfer?<br />
(<code>T</code> = <code>:Unlimited</code>, <code>:Limited</code> or
<code>:Fixed</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ReadUnit{T}</code></td>
<td style="text-align: left;">What guarantees are made about
fragmentation?<br />
(<code>T</code> = <code>:Byte</code>, <code>:Line</code>,
<code>:Packet</code> or <code>:RequestedSize</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Cursors{T}</code></td>
<td style="text-align: left;">Are <code>mark</code> and
<code>seek</code> supported?<br />
(<code>T</code> = <code>Missing</code>, <code>:Seekable</code> or
<code>:Markable</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>TransferAPI{T}</code></td>
<td style="text-align: left;">How to transfer bytes? (<code>T</code> =
<code>:LibC</code>, <code>:IOURing</code>, <code>:GSD</code>, or
<code>:AIO</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>WaitAPI{T}</code></td>
<td style="text-align: left;">How to wait for activity?<br />
(<code>T</code> = <code>:Sleep</code>, <code>:PosixPoll</code>,
<code>:EPoll</code>, <code>:IOUring</code>, <code>:PidFD</code>, or
<code>:KQueue</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FIXME update summaries</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="the-io-interface-model">The IO Interface Model</h2>
<div class="sourceCode" id="cb2"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>help?<span class="op">&gt;</span> <span class="bu">Base</span>.<span class="dt">IO</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  No documentation found.</span></code></pre></div>
<p>As things stand Julia doesn’t have a well defined generic interface
for IO.</p>
<p>It isn’t possible to write a generic library that accepts
<code>&lt;: IO</code> objects because specification of the
<code>IO</code> interface is not complete and the reference
implementations are inconsistent. <span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote">Issue <a
href="https://github.com/JuliaLang/julia/issues/24526">24526</a> “Review
of IO blocking behaviour” describes inconsistencies in blocking,
termination and allocation behaviour. There are both inconsistencies
between behaviour of different functions and between different methods
of the same functions.<br />
<br />
</span></span> There are also instances where <code>IO</code> behaviour
is well defined but function naming isn’t ideal, or default behaviour
can be surprising.<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="sidenote">e.g. <code>eof(io) -&gt; Bool</code> looks like a
simple query function but it actually blocks to wait for data.<br />
<br />
</span></span></p>
<h3 id="io-or-stream">IO or Stream?</h3>
<p>The Julia IO interface is built around the abstract type
<code>Base.IO</code>. The <code>IO</code> interface specifications refer
to <code>IO</code> objects as “stream” in some places and “io” in
others<span
class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span
class="sidenote">Examples from function signatures:
<code>close(stream)</code>, <code>bytesavailable(io)</code>,
<code>readavailable(stream)</code>, <code>isreadable(io)</code>,
<code>read(io::IO, String)</code>, <code>eof(stream)</code>.<br />
Examples from function descriptions: “The IO stream”, “the specified IO
object” “the given I/O stream”, “the stream <code>io</code>”, “the
stream or file”.<br />
(Also note: <code>Base.IOStream</code> is a concrete subtype of
<code>IO</code> that implements local file system IO. References to
“stream” and “IO stream” in existing <code>IO</code> interface
specifications are not related to <code>Base.IOStream</code>.)<br />
<br />
</span></span>.</p>
<p>The IOTraits interface defines <code>IOTraits.Stream</code> and uses
the word “stream” to refer to instances of this type. To avoid
ambiguity: instances of <code>IO</code> are referred to as “a
<code>Base.IO</code> object”.</p>
<p>The <code>Stream</code> type models byte-streams. Many common
operations involve transferring data to and from byte streams.
e.g. writing data to a local file; receiving data from a network server;
or typing commands into a terminal.</p>
<p>Note that <code>IOTraits.Stream</code> is not a subtype of
<code>Base.IO</code>.<span
class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span
class="sidenote">Similarities and differences between the
<code>Base.IO</code> model and the <code>IOTraits.Stream</code> model
can be seen by reading the <code>IOTraits.BaseIO</code> implementations
of the <code>Base.IO</code> functions below.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb3" data-startFrom="290"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 289;"><span id="cb3-290"><a href="#cb3-290"></a><span class="kw">abstract type</span> Stream <span class="kw">end</span></span></code></pre></div>
<p>The constructor <code>BaseIO(::Stream) -&gt; Base.IO</code> creates a
Base.IO compatible wrapper around a stream.</p>
<div class="sourceCode" id="cb4" data-startFrom="296"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 295;"><span id="cb4-296"><a href="#cb4-296"></a><span class="kw">struct</span> BaseIO{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> Base.IO</span></span>
<span id="cb4-297"><a href="#cb4-297"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb4-298"><a href="#cb4-298"></a><span class="kw">end</span></span>
<span id="cb4-299"><a href="#cb4-299"></a></span>
<span id="cb4-300"><a href="#cb4-300"></a></span>
<span id="cb4-301"><a href="#cb4-301"></a><span class="kw">struct</span> URI</span>
<span id="cb4-302"><a href="#cb4-302"></a>    uri<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-303"><a href="#cb4-303"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="aspects-of-the-stream-interface">Aspects of the Stream
interface</h3>
<p>Issue <a
href="https://github.com/JuliaLang/julia/issues/24526#issuecomment-431567472">24526</a>
identified three aspects of behaviour in the <code>Base.read*</code>
interface that, without precise specification, lead to ambiguity and
inconsistency:</p>
<ul>
<li>allocation: read into the caller’s buffer? (resize this buffer?) or
return a new buffer?</li>
<li>termination: read a specified size?, up to a delimiter? or read as
much as possible?</li>
<li>blocking: wait however long it takes for the termination condition
to be reached? or return early if insufficient data is available?</li>
</ul>
<p>The IOTraits interface attempts to limit the number of behavioural
permutations as much as possible by choosing a default behaviour for
each aspect and supporting other behaviours only by addition of clean
wrapper layers.</p>
<p><strong>Allocation:</strong> The <code>transfer!</code> function
never allocates buffers or resizes buffers it simply transfers bytes to
or from the buffer provided. Exceptions to this rule are possible
through the <a href="#buffer-interface-traits">Buffer Interface
Traits</a> <span
class="sidenote-wrapper"><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span
class="sidenote">e.g. if
<code>ToBufferInterface(buffer) == ToPush()</code> data is pushed into
the buffer, which may lead to resizing.<br />
<br />
</span></span>. The interface aims to support implementations that wish
to avoid unnecessary buffering. It should be simple to write a transfer
method that passes a supplied buffer directly to an OS system call.
Buffering can be added in wrapper layers as needed.</p>
<p><strong>Termination:</strong> The <code>transfer!</code> function is
specified to “transfer at most <code>n</code> items” and “Return the
number of items transferred”. i.e. if some amount of data is available,
return it right away rather than waiting for the entire requested
amount. This behaviour can easily be wrapped with a retry layer to
support cases where all <code>n</code> items are required.</p>
<p><strong>Blocking:</strong> By default the <code>transfer!</code>
function waits indefinitely for data to be available. Control over this
behaviour is provided by the optional <code>deadline=</code> argument.
The <code>transfer!</code> function stops waiting when
<code>deadline &gt; time()</code>. This interface allows non-blocking
transfers (<code>deadline=0</code>), blocking transfers
(<code>deadline=Inf</code>) or anything in between.<span
class="sidenote-wrapper"><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span
class="sidenote">Note that <code>transfer!</code> will always return
data that is immediately available irrespective of the deadline.
i.e. There is no race condition when
<code>deadline ~= time()</code>.<br />
<br />
</span></span></p>
<p>The combination of the chosen termination and blocking behavior leads
to two cases where <code>transfer!</code> returns zero: End of stream
(EOF), and deadline expired. This seems like a nice unification of the
treatment of streams that have a distinct end and those that don’t. The
caller can specify a deadline that makes sense for their application and
not have to worry about what type of underlying OS stream is
involved.<span
class="sidenote-wrapper"><label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle"/><span
class="sidenote">With the current <code>IO</code> interface, there are
inconsistencies. e.g. reading log messages from a pipe with
<code>readline(io)</code> will block and wait for a line to be
available, but reading log messages from a file will yield endless empty
stings at the end of the file. The empty strings can be avoided by
<code>while !eof(io) readline(io) ...</code>, but <code>eof(io)</code>
returns true when all the currently available lines have been read, so
to wait for more lines we would need an additional polling loop.<br />
<br />
</span></span></p>
<p>Another relevant aspect is transfer direction. Does a stream support
input?, output? or both? Most operating systems have a mixture of
bi-directional and uni-directional stream APIs.<span
class="sidenote-wrapper"><label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle"/><span
class="sidenote">In some places Unix uses bi-directional streams.
e.g. files can be opened for reading and writing and sockets are usually
bi-directional. However, in many instances Unix uses distinct streams
for input and output. e.g. STDIN and STDOUT are distinct streams and
<code>pipe(2)</code> returns the “read end” and the “write end” of a
one-way pipe. Even where Unix supports bi-directional streams there are
cases where is is best to use two seperate streams for a particular
resource. e.g. to eliminate ambiguity in <code>poll(2)</code>
events.<br />
<br />
</span></span> Streams that are both readable and writable can be
confusing<span
class="sidenote-wrapper"><label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle"/><span
class="sidenote">e.g. What does <code>close(::IO)</code> do for a
bi-directional stream? (<a
href="https://github.com/JuliaLang/julia/issues/41995">41995</a>) Does
<code>Base.position(io)</code> refer to the input position or the output
position?<br />
<br />
</span></span> and difficult to implement correctly.<span
class="sidenote-wrapper"><label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle"/><span
class="sidenote"><a
href="https://github.com/JuliaLang/julia/issues/39727">39727</a>
“Bi-directional IOStream seems to mix input and output”<br />
<br />
</span></span> It seems simpler and more general to use a model where
all streams are uni-directional.</p>
<p><strong>Direction:</strong> In general a stream supports input, or
output but not both. The <a href="#transfer-direction-trait">Transfer
Direction Trait</a> specifies which.<span
class="sidenote-wrapper"><label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle"/><span
class="sidenote">Note the <a href="#transfer-direction-trait">Transfer
Direction Trait</a> supports direction: <code>Exchange</code> for
interfaces like <a
href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
where data must be synchronously exchanged between a buffer and the
interface (i.e. input and output are not separable). This can be though
of as having exactly the same behavior as direction <code>Out</code>
except that incoming data appears in the output buffer after each output
transfer.<br />
<br />
</span></span> This restriction simplifies the specification of things
like <code>position</code>, <code>mark</code> and <code>seek</code>. It
also avoids the need for distinctions like <code>close</code> vs
<code>closewrite</code> (<a
href="https://github.com/JuliaLang/julia/issues/41995">41995</a>).
Bi-directonal streams can easily be added by a wrapper layer that
combines two streams e.g. see DuplexIO.jl.</p>
<h3 id="atomicity-of-transfers">Atomicity of Transfers</h3>
<p>FIXME - byte transfers always atomic - multi-byte items - return zero
if bytesavailable &lt; ioelsize ? - if Unknown Availability try a
transfer and error if not enough bytes - include the partial bytes in
the exception object - warning with suggestion to wrap with a buffer</p>
<h3 id="generic-code-and-dependance-on-traits">Generic Code and
Dependance on Traits</h3>
<p>FIXME - Generic code may rely on e.g. Low Transfer Cost, or Known
Transfer Size - Generic code should have assertions for these traits. -
Generic code could promote streams to have required traits as needed
(i.e. wrap with buffered stream).</p>
<h3 id="stream-interface-functions">Stream Interface Functions</h3>
<h4 id="stream-data-transfer-core-functions">Stream Data Transfer Core
Functions</h4>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: left;"><code>transfer!(stream, buf, [n])</code></td>
<td style="text-align: left;">Transfer at least one and at most
<code>n</code> items between <code>stream</code> and <code>buf</code>.
Return the number of items transferred. See
<code>TransferDirection</code>, <code>FromBufferInterface</code> and
<code>ToBufferInterface</code> traits.</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>wait(stream; timeout=Inf)</code></td>
<td style="text-align: left;">Wait until <code>stream</code> is ready to
transfer data. <code>transfer!</code> calls <code>wait</code> if there
are no items available. See <code>WaitAPI</code> trait and
<code>set_poll_interface</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>lock(stream)</code></td>
<td style="text-align: left;">Acquire a task-exclusive lock on
<code>stream</code>. A <code>Stream</code> must be locked before
<code>wait</code> is called.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unlock(stream)</code></td>
<td style="text-align: left;">Reverse the effect of
<code>lock</code>.</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>max_transfer_size(stream)</code></td>
<td style="text-align: left;">Maximum number of bytes per call to
<code>transfer!</code>. See <code>TransferSize</code> trait.</td>
</tr>
</tbody>
</table>
<h4 id="stream-data-transfer-conveniance-methods">Stream Data Transfer
Conveniance Methods</h4>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: left;"><code>transfer!(...; timeout=Inf)</code></td>
<td style="text-align: left;">Wait <code>timeout</code> seconds if no
items are available to transfer.</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>transfer!(stream =&gt; buf, [n])</code></td>
<td style="text-align: left;">Transfer data from <code>stream</code> to
<code>buf</code>.</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>transfer!(buf =&gt; stream, [n])</code></td>
<td style="text-align: left;">Transfer data from <code>buf</code> to
<code>stream</code>.</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>transfer!(stream, buf; buffer_i=i)</code></td>
<td style="text-align: left;">Transfer data starting at <code>buf</code>
index <code>i</code>.</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>transfer!(stream, buf; stream_i=i)</code></td>
<td style="text-align: left;">Transfer data starting at
<code>stream</code> byte-index <code>i</code>. See
<code>StreamIndexing</code> trait.</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>transferall!(stream, buf, [n])</code><br />
<code>transferall!(stream =&gt; buf, [n])</code><br />
<code>transferall!(buf =&gt; stream, [n])</code><br />
</td>
<td style="text-align: left;">Transfer all <code>n</code> items between
<code>stream</code> and <code>buf</code>.</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>transferall!(...; timeout=Inf)</code></td>
<td style="text-align: left;">Stop waiting for more items after
<code>timeout</code>.</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>readall!(stream) -&gt; Vector{UInt8}</code></td>
<td style="text-align: left;">Transfer all items from
<code>stream</code> into a new byte buffer.</td>
</tr>
</tbody>
</table>
<h4 id="stream-data-transfer-driver-api">Stream Data Transfer Driver
API</h4>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Function Description</td>
</tr>
</tbody>
</table>
<p><code>unsafe_transfer!(stream, p, n) -&gt; n</code> Transfer at least
<code>n</code> bytes between <code>stream</code> and
<code>p::Ptr{UInt8}</code>. Return the number of bytes transferred.</p>
<hr />
<h4 id="stream-lifecycle-state-functions">Stream Lifecycle State
Functions</h4>
<p>A <code>Stream</code> begins its life in “connected” and “open”
state. A <code>Stream</code> might be spontaneously “disconnected” by an
external event (e.g. when a peer a hangs up a connection). A
<code>Stream</code> can only be “closed” by the <code>close</code>
function.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>isconnected(stream)</code></td>
<td style="text-align: left;">True if the underlying data source/sink is
still available through <code>stream</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>isopen(stream)</code></td>
<td style="text-align: left;">True unless <code>close(stream)</code> is
called.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>close(stream)</code></td>
<td style="text-align: left;">Signal that the program is finished with
<code>stream</code>. If stream is an output, call
<code>flush(stream)</code>. Disconnect the underlying data
source/sink.<br />
After <code>close</code> is called, <code>isopen</code> and
<code>isconnected</code> are both False.<br />
Most <code>Stream</code> funtions have <code>isopen(stream)</code> as a
precondition, so calling other stream functions after <code>close</code>
is likely to cause an exception.</td>
</tr>
</tbody>
</table>
<h4 id="input-stream-query-functions">Input Stream Query Functions</h4>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>length_is_known(stream)</code></td>
<td style="text-align: left;">True if the total number of bytes
available from the stream is known. See <code>TotalSize</code>
trait.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>length(stream)</code></td>
<td style="text-align: left;">Total number of bytes available from the
stream. <code>missing</code> if unknown.</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>position_is_known(stream)</code></td>
<td style="text-align: left;">True if <code>position(stream)</code> is
known. See <code>Cursors</code> trait.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>position(stream)</code></td>
<td style="text-align: left;">Byte position relative to start of
<code>stream</code>. The first byte in <code>position</code> zero.
<code>missing</code> if unknown.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bytesremaining(stream)</code></td>
<td style="text-align: left;">Number of bytes remaining to be
transferred from the stream. <code>missing</code> if unknown. If
<code>length_is_known</code> this is the same as
<code>length(stream) - position(stream)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>isfinished(stream)</code></td>
<td style="text-align: left;">True if there are no bytes remaining to be
transferred from the stream.<br />
If <code>length_is_known</code> them this is the same as
<code>bytesremaining(stream) == 0</code>, otherwise
<code>isfinished</code> is only true when <code>isconnected</code> is
false and <code>bytesavailable(stream) == 0</code></td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>availability_is_known(stream)</code></td>
<td style="text-align: left;">True if the number of bytes immediately
available for transfer is known. See <code>Availability</code>
trait.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bytesavailable(stream)</code></td>
<td style="text-align: left;">Number of bytes immediately ready for
transfer. <code>missing</code> if unknown. See <code>ReadSizeAPI</code>
trait.</td>
</tr>
</tbody>
</table>
<p>Note that the query functions above are all side-effect free.</p>
<p>Failure to ensure that query methods for all stream types are
side-effect free can lead to subtle bugs.</p>
<p>Consider the following method:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">position</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>) <span class="op">=</span> <span class="fu">position</span>(s.stream) <span class="op">-</span> <span class="fu">bytesavailable</span>(s.buffer)</span></code></pre></div>
<p>The current position is the number of bytes that have been taken from
the stream, less the number of bytes buffered but not yet transferred to
the user. Imagine that <code>bytesavailable(s.buffer)</code> was
designed to refill the buffer from the stream on demand before returning
the number of buffered bytes. The
<code>position(s::BufferedInput)</code> method would return an invalid
result because the value of <code>position(s.stream)</code> is altered
by the side-effect in <code>bytesavailable(s.buffer)</code>.</p>
<h3 id="notes">Notes</h3>
<p>TODO: Note about back-pressure, the problem with reading too fast
into a big buffer</p>
<h3 id="methods-of-base-functions-for-streams">Methods of Base Functions
for Streams</h3>
<h3 id="methods-of-base-functions-for-streams-1">Methods of Base
Functions for Streams</h3>
<p>The IOTraits interface avoids defining methods of Base functions that
have incomplete or ambiguous specifications. It also avoids local
function names names that shadow Base functions. In some cases a similar
function name with an underscore prefix is used to differentiate local
functions.</p>
<p>The IOTraits interface defines methods for the following well defined
Base functions (the default methods for the generic <code>Stream</code>
type dispatch to a wrapped delegate stream if the
<code>StreamDelegation</code> trait is in effect).</p>
<div class="sourceCode" id="cb6" data-startFrom="608"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 607;"><span id="cb6-608"><a href="#cb6-608"></a><span class="bu">Base</span>.<span class="fu">isopen</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">isopen</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span> <span class="cn">false</span></span>
<span id="cb6-609"><a href="#cb6-609"></a></span>
<span id="cb6-610"><a href="#cb6-610"></a><span class="bu">Base</span>.<span class="fu">close</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">close</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span> <span class="cn">nothing</span></span>
<span id="cb6-611"><a href="#cb6-611"></a></span>
<span id="cb6-612"><a href="#cb6-612"></a><span class="bu">Base</span>.<span class="fu">islocked</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">islocked</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span></span>
<span id="cb6-613"><a href="#cb6-613"></a>    <span class="pp">@warn</span> <span class="st">&quot;Base.islocked(::</span><span class="sc">$</span>(<span class="fu">typeof</span>(s))<span class="st"> not defined!&quot;</span></span>
<span id="cb6-614"><a href="#cb6-614"></a></span>
<span id="cb6-615"><a href="#cb6-615"></a><span class="bu">Base</span>.<span class="fu">lock</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">lock</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span></span>
<span id="cb6-616"><a href="#cb6-616"></a>    <span class="pp">@warn</span> <span class="st">&quot;Base.lock(::</span><span class="sc">$</span>(<span class="fu">typeof</span>(s))<span class="st"> not defined!&quot;</span></span>
<span id="cb6-617"><a href="#cb6-617"></a></span>
<span id="cb6-618"><a href="#cb6-618"></a><span class="bu">Base</span>.<span class="fu">unlock</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">unlock</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span></span>
<span id="cb6-619"><a href="#cb6-619"></a>    <span class="pp">@warn</span> <span class="st">&quot;Base.unlock(::</span><span class="sc">$</span>(<span class="fu">typeof</span>(s))<span class="st"> not defined!&quot;</span></span>
<span id="cb6-620"><a href="#cb6-620"></a></span>
<span id="cb6-621"><a href="#cb6-621"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">wait</span>(s<span class="op">::</span><span class="dt">Stream</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb6-622"><a href="#cb6-622"></a>    deadline <span class="op">=</span> <span class="fu">deadline_or_timeout</span>(deadline, timeout)     ;<span class="pp">@db</span> deadline <span class="op">-</span> <span class="fu">time</span>()</span>
<span id="cb6-623"><a href="#cb6-623"></a>    <span class="fu">is_proxy</span>(s) ? <span class="fu">wait</span>(<span class="fu">unwrap</span>(s); deadline) <span class="op">:</span></span>
<span id="cb6-624"><a href="#cb6-624"></a>                 <span class="fu">_wait</span>(s, <span class="fu">WaitAPI</span>(s); deadline)</span>
<span id="cb6-625"><a href="#cb6-625"></a><span class="kw">end</span></span>
<span id="cb6-626"><a href="#cb6-626"></a></span>
<span id="cb6-627"><a href="#cb6-627"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">bytesavailable</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb6-628"><a href="#cb6-628"></a>    <span class="pp">@db_not_tested</span> <span class="fu">is_proxy</span>(s)</span>
<span id="cb6-629"><a href="#cb6-629"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb6-630"><a href="#cb6-630"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb6-631"><a href="#cb6-631"></a>    <span class="fu">is_proxy</span>(s) ? <span class="fu">bytesavailable</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span></span>
<span id="cb6-632"><a href="#cb6-632"></a>                  <span class="fu">_bytesavailable</span>(s, <span class="fu">Availability</span>(s), <span class="fu">TransferSize</span>(s))</span>
<span id="cb6-633"><a href="#cb6-633"></a><span class="kw">end</span></span>
<span id="cb6-634"><a href="#cb6-634"></a></span>
<span id="cb6-635"><a href="#cb6-635"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">length</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb6-636"><a href="#cb6-636"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb6-637"><a href="#cb6-637"></a>    <span class="pp">@require</span> <span class="fu">length_is_known</span>(s)</span>
<span id="cb6-638"><a href="#cb6-638"></a>    <span class="cf">if</span> <span class="fu">TotalSize</span>(s) <span class="op">==</span> <span class="fu">TotalSize</span><span class="dt">{:Zero}</span>()</span>
<span id="cb6-639"><a href="#cb6-639"></a>        <span class="cf">return</span> <span class="fl">0</span></span>
<span id="cb6-640"><a href="#cb6-640"></a>    <span class="cf">end</span></span>
<span id="cb6-641"><a href="#cb6-641"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb6-642"><a href="#cb6-642"></a>    <span class="fu">_length</span>(s, <span class="fu">LengthAPI</span>(s))</span>
<span id="cb6-643"><a href="#cb6-643"></a><span class="kw">end</span></span>
<span id="cb6-644"><a href="#cb6-644"></a></span>
<span id="cb6-645"><a href="#cb6-645"></a></span>
<span id="cb6-646"><a href="#cb6-646"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">position</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb6-647"><a href="#cb6-647"></a>    <span class="pp">@db_not_tested</span> <span class="fu">is_proxy</span>(s)</span>
<span id="cb6-648"><a href="#cb6-648"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb6-649"><a href="#cb6-649"></a>    <span class="pp">@require</span> <span class="fu">Cursors</span>(s) isa HasCursors</span>
<span id="cb6-650"><a href="#cb6-650"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb6-651"><a href="#cb6-651"></a>    <span class="fu">_position</span>(s, <span class="fu">Cursors</span>(s))</span>
<span id="cb6-652"><a href="#cb6-652"></a><span class="kw">end</span></span>
<span id="cb6-653"><a href="#cb6-653"></a></span>
<span id="cb6-654"><a href="#cb6-654"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readline</span>(s<span class="op">::</span><span class="dt">Stream</span>; keep<span class="op">=</span><span class="cn">false</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb6-655"><a href="#cb6-655"></a>    <span class="pp">@db_not_tested</span> <span class="fu">is_proxy</span>(s)</span>
<span id="cb6-656"><a href="#cb6-656"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb6-657"><a href="#cb6-657"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb6-658"><a href="#cb6-658"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s) <span class="co"># FIXME buffered input should not be unwrapped</span></span>
<span id="cb6-659"><a href="#cb6-659"></a>                  <span class="co"># but timeout stream should.</span></span>
<span id="cb6-660"><a href="#cb6-660"></a>                  <span class="co"># ensure that there are tests for this kind of thing</span></span>
<span id="cb6-661"><a href="#cb6-661"></a>                  <span class="co"># consider the need for different types of proxy / unwrap</span></span>
<span id="cb6-662"><a href="#cb6-662"></a>    <span class="fu">_readline</span>(s, <span class="fu">ReadUnit</span>(s); keep, timeout)</span>
<span id="cb6-663"><a href="#cb6-663"></a><span class="kw">end</span></span>
<span id="cb6-664"><a href="#cb6-664"></a></span>
<span id="cb6-665"><a href="#cb6-665"></a></span>
<span id="cb6-666"><a href="#cb6-666"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">eachline</span>(s<span class="op">::</span><span class="dt">Stream</span>; keep<span class="op">=</span><span class="cn">false</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb6-667"><a href="#cb6-667"></a>    <span class="pp">@db_not_tested</span> <span class="fu">is_proxy</span>(s)</span>
<span id="cb6-668"><a href="#cb6-668"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb6-669"><a href="#cb6-669"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb6-670"><a href="#cb6-670"></a>    s <span class="op">=</span> <span class="fu">timeout_stream</span>(s; timeout)</span>
<span id="cb6-671"><a href="#cb6-671"></a>    <span class="fu">eachline</span>(<span class="fu">BaseIO</span>(s); keep)</span>
<span id="cb6-672"><a href="#cb6-672"></a><span class="kw">end</span></span>
<span id="cb6-673"><a href="#cb6-673"></a></span>
<span id="cb6-674"><a href="#cb6-674"></a></span>
<span id="cb6-675"><a href="#cb6-675"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">peek</span>(s<span class="op">::</span><span class="dt">Stream</span>, <span class="op">::</span><span class="dt">Type{T}</span>; timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="kw">where</span> T</span>
<span id="cb6-676"><a href="#cb6-676"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb6-677"><a href="#cb6-677"></a>    <span class="pp">@db_not_tested</span> <span class="fu">is_proxy</span>(s)</span>
<span id="cb6-678"><a href="#cb6-678"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb6-679"><a href="#cb6-679"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb6-680"><a href="#cb6-680"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb6-681"><a href="#cb6-681"></a>    <span class="fu">_peek</span>(s, <span class="fu">PeekSupport</span>(s), T; timeout)</span>
<span id="cb6-682"><a href="#cb6-682"></a><span class="kw">end</span></span>
<span id="cb6-683"><a href="#cb6-683"></a></span>
<span id="cb6-684"><a href="#cb6-684"></a><span class="fu">pump!</span>(s<span class="op">::</span><span class="dt">Stream</span>; deadline) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">pump!</span>(<span class="fu">unwrap</span>(s); deadline) <span class="op">:</span> <span class="cn">nothing</span></span></code></pre></div>
<h3 id="stream-delegation-wrappers">Stream Delegation Wrappers</h3>
<p>The StreamDelegation trait allows a Stream subtype to delegate most
method calls to a wrapped substream while redefining other methods as
needed.</p>
<p>Wrappers are used to augment low level stream drivers with features
like buffering or defragmentation. Wrappers are also used to make
<code>Stream</code> objects compatible with <code>Base.IO</code>.</p>
<p><code>StreamDelegation(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>NotDelegated()</code></td>
<td style="text-align: left;">This stream has its own stream interface
methods.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DelegatedToSubStream()</code></td>
<td style="text-align: left;">This stream is a proxy for a sub
stream.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb7" data-startFrom="705"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 704;"><span id="cb7-705"><a href="#cb7-705"></a><span class="kw">abstract type</span> StreamDelegation <span class="kw">end</span></span>
<span id="cb7-706"><a href="#cb7-706"></a><span class="kw">struct</span> NotDelegated <span class="op">&lt;:</span><span class="dt"> StreamDelegation </span><span class="kw">end</span></span>
<span id="cb7-707"><a href="#cb7-707"></a><span class="kw">struct</span> DelegatedToSubStream <span class="op">&lt;:</span><span class="dt"> StreamDelegation </span><span class="kw">end</span></span>
<span id="cb7-708"><a href="#cb7-708"></a><span class="fu">StreamDelegation</span>(s) <span class="op">=</span> <span class="fu">StreamDelegation</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb7-709"><a href="#cb7-709"></a><span class="fu">StreamDelegation</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">NotDelegated</span>()</span>
<span id="cb7-710"><a href="#cb7-710"></a></span>
<span id="cb7-711"><a href="#cb7-711"></a><span class="fu">is_proxy</span>(s) <span class="op">=</span> <span class="fu">StreamDelegation</span>(s) <span class="op">!=</span> <span class="fu">NotDelegated</span>()</span></code></pre></div>
<p><code>unwrap(stream)</code> – Retrieves the underlying stream that is
wrapped by a proxy stream.</p>
<div class="sourceCode" id="cb8" data-startFrom="718"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 717;"><span id="cb8-718"><a href="#cb8-718"></a><span class="fu">unwrap</span>(s) <span class="op">=</span> <span class="fu">unwrap</span>(s, <span class="fu">StreamDelegation</span>(s))</span>
<span id="cb8-719"><a href="#cb8-719"></a><span class="fu">unwrap</span>(s, <span class="op">::</span><span class="dt">NotDelegated</span>) <span class="op">=</span> s</span>
<span id="cb8-720"><a href="#cb8-720"></a><span class="fu">unwrap</span>(s, <span class="op">::</span><span class="dt">DelegatedToSubStream</span>) <span class="op">=</span> s.stream</span>
<span id="cb8-721"><a href="#cb8-721"></a><span class="fu">unwrap</span>(T<span class="op">::</span><span class="dt">Type</span>, <span class="op">::</span><span class="dt">DelegatedToSubStream</span>) <span class="op">=</span> <span class="fu">fieldtype</span>(T, <span class="op">:</span>stream)</span></code></pre></div>
<h2 id="unfiled-notes">Unfiled Notes</h2>
<ul>
<li>How could <code>Base.isready</code> apply to IO? It’s definition is
nice and concise: “Determine whether a Channel has a value stored to it.
Returns immediately, does not block.”</li>
<li>Build <code>ReadlineMux &lt;: IOMux</code> and
<code>ReadlineDemux &lt;: IODemux</code> as an example of a traits aware
IO mechanism. e.g. merge multiple streams onto a single IO with a
mux/demux header.</li>
<li>Consider traits to select special purpose IO functions where
appropriate: <code>pread</code>, <code>readv</code>,
<code>writev</code>, <code>sendfile</code> ?</li>
<li>Consider using traits to identify inefficient access patterns.
<ul>
<li>Keep stats per file
<ul>
<li>No. tranfers, No. bytes, No. seeks.</li>
<li>Time between transfers (rolling avg?)</li>
<li>Warn if stats don’t align with traits</li>
<li>e.g. large number of small reads for high per-call overhead IO.</li>
</ul></li>
</ul></li>
<li>Consider trait to characterise access speed:
<ul>
<li>fast mmap - ok for small and large requests</li>
<li>fast local - but slow for small requests</li>
<li>fast network - but slow for small requests</li>
<li>slow serial - no problem with small requests</li>
</ul></li>
<li>content:
<ul>
<li>Has bytes</li>
<li>no content (links)</li>
<li>directory</li>
</ul></li>
<li>writing
<ul>
<li>needs flush?</li>
<li>efficient to write one byte at a time?</li>
<li>natural page size?</li>
</ul></li>
</ul>
<h1 id="transfer-direction-trait">Transfer Direction Trait</h1>
<p>The <code>TransferDirection</code> trait describes the direction of
data transfer supported by a stream.</p>
<p><code>TransferDirection(stream)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>In()</code></td>
<td style="text-align: left;">data is “read” from the <code>IO</code>
into a buffer.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Out()</code></td>
<td style="text-align: left;">data from a buffer is “written” to the
<code>IO</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Exchange()</code></td>
<td style="text-align: left;">data is exchanged between the
<code>IO</code> and a buffer.<span
class="sidenote-wrapper"><label for="sn-12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-12" class="margin-toggle"/><span
class="sidenote">e.g. a <a
href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface receives a byte for every byte transmitted.<br />
<br />
</span></span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb9" data-startFrom="778"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 777;"><span id="cb9-778"><a href="#cb9-778"></a><span class="kw">abstract type</span> TransferDirection <span class="kw">end</span></span>
<span id="cb9-779"><a href="#cb9-779"></a><span class="kw">struct</span> In <span class="op">&lt;:</span><span class="dt"> TransferDirection </span><span class="kw">end</span></span>
<span id="cb9-780"><a href="#cb9-780"></a><span class="kw">struct</span> Out <span class="op">&lt;:</span><span class="dt"> TransferDirection </span><span class="kw">end</span></span>
<span id="cb9-781"><a href="#cb9-781"></a><span class="kw">struct</span> Exchange <span class="op">&lt;:</span><span class="dt"> TransferDirection </span><span class="kw">end</span></span>
<span id="cb9-782"><a href="#cb9-782"></a><span class="kw">const</span> AnyDirection <span class="op">=</span> TransferDirection</span>
<span id="cb9-783"><a href="#cb9-783"></a><span class="fu">TransferDirection</span>(s) <span class="op">=</span> <span class="fu">TransferDirection</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb9-784"><a href="#cb9-784"></a><span class="fu">TransferDirection</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferDirection</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb9-785"><a href="#cb9-785"></a>                                           <span class="cn">nothing</span></span>
<span id="cb9-786"><a href="#cb9-786"></a></span>
<span id="cb9-787"><a href="#cb9-787"></a><span class="fu">is_input</span>(s) <span class="op">=</span> <span class="fu">TransferDirection</span>(s) <span class="op">!=</span> <span class="fu">Out</span>()</span>
<span id="cb9-788"><a href="#cb9-788"></a><span class="fu">is_output</span>(s) <span class="op">=</span> <span class="fu">TransferDirection</span>(s) <span class="op">!=</span> <span class="fu">In</span>()</span>
<span id="cb9-789"><a href="#cb9-789"></a></span>
<span id="cb9-790"><a href="#cb9-790"></a><span class="fu">verb</span>(<span class="op">::</span><span class="dt">In</span>) <span class="op">=</span> <span class="st">&quot;from&quot;</span></span>
<span id="cb9-791"><a href="#cb9-791"></a><span class="fu">verb</span>(<span class="op">::</span><span class="dt">Out</span>) <span class="op">=</span> <span class="st">&quot;to&quot;</span></span></code></pre></div>
<p>The constructor
<code>BaseIOStream(::Base.IO) -&gt; IOTraits.Stream</code> creates a
Stream compatible wrapper around a Base.IO.</p>
<div class="sourceCode" id="cb10" data-startFrom="798"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 797;"><span id="cb10-798"><a href="#cb10-798"></a><span class="kw">struct</span> BaseIOStream{T<span class="op">&lt;:</span><span class="dt">Base.IO</span>,D<span class="op">&lt;:</span><span class="dt">TransferDirection</span>} <span class="op">&lt;:</span><span class="dt"> Stream</span></span>
<span id="cb10-799"><a href="#cb10-799"></a>    io<span class="op">::</span><span class="dt">T</span></span>
<span id="cb10-800"><a href="#cb10-800"></a><span class="kw">end</span></span>
<span id="cb10-801"><a href="#cb10-801"></a></span>
<span id="cb10-802"><a href="#cb10-802"></a><span class="fu">TransferDirection</span>(<span class="op">::</span><span class="dt">Type{BaseIOStream{T, D}}</span>) <span class="kw">where</span> {T, D} <span class="op">=</span> <span class="fu">D</span>()</span>
<span id="cb10-803"><a href="#cb10-803"></a></span>
<span id="cb10-804"><a href="#cb10-804"></a><span class="bu">Base</span>.<span class="fu">isopen</span>(s<span class="op">::</span><span class="dt">BaseIOStream</span>) <span class="op">=</span> <span class="fu">isopen</span>(s.io)</span></code></pre></div>
<h1 id="io-indexing-trait">IO Indexing Trait</h1>
<p>Is indexing (e.g. <code>pread(2)</code>) supported?</p>
<div class="sourceCode" id="cb11" data-startFrom="812"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 811;"><span id="cb11-812"><a href="#cb11-812"></a><span class="kw">abstract type</span> StreamIndexing <span class="kw">end</span></span>
<span id="cb11-813"><a href="#cb11-813"></a><span class="kw">struct</span> NotIndexable <span class="op">&lt;:</span><span class="dt"> StreamIndexing </span><span class="kw">end</span></span>
<span id="cb11-814"><a href="#cb11-814"></a><span class="kw">struct</span> IndexableIO <span class="op">&lt;:</span><span class="dt"> StreamIndexing </span><span class="kw">end</span></span>
<span id="cb11-815"><a href="#cb11-815"></a><span class="fu">StreamIndexing</span>(s) <span class="op">=</span> <span class="fu">StreamIndexing</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb11-816"><a href="#cb11-816"></a><span class="fu">StreamIndexing</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">StreamIndexing</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb11-817"><a href="#cb11-817"></a>                                        <span class="fu">NotIndexable</span>()</span>
<span id="cb11-818"><a href="#cb11-818"></a></span>
<span id="cb11-819"><a href="#cb11-819"></a><span class="fu">stream_is_indexable</span>(s) <span class="op">=</span> <span class="fu">StreamIndexing</span>(s) <span class="op">==</span> <span class="fu">IndexableIO</span>()</span>
<span id="cb11-820"><a href="#cb11-820"></a></span>
<span id="cb11-821"><a href="#cb11-821"></a></span>
<span id="cb11-822"><a href="#cb11-822"></a><span class="fu">ioeltype</span>(s) <span class="op">=</span> <span class="fu">isabstracttype</span>(<span class="fu">eltype</span>(s)) ? <span class="dt">UInt8</span> <span class="op">:</span> <span class="fu">eltype</span>(s)</span>
<span id="cb11-823"><a href="#cb11-823"></a><span class="pp">@selfdoc</span> <span class="fu">ioelsize</span>(s) <span class="op">=</span> <span class="fu">sizeof</span>(<span class="fu">ioeltype</span>(s))</span></code></pre></div>
<h1 id="data-transfer-function">Data Transfer Function</h1>
<pre><code>transfer!(stream, buffer, [n]; buffer_i=1, deadline=Inf) -&gt; n_transfered</code></pre>
<p>Transfer at most <code>n</code> items between <code>stream</code> and
<code>buffer</code>.<span
class="sidenote-wrapper"><label for="sn-13" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-13" class="margin-toggle"/><span
class="sidenote">If <code>n</code> is not specified then the number of
items transferred depends on the number of items available and the
capacity of <code>buffer</code>.<br />
<br />
</span></span> Return the number of items transferred.</p>
<p>If no items are immediately available, wait until
<code>time() &gt; deadline</code> for at least one item to be
transferred.<span
class="sidenote-wrapper"><label for="sn-14" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-14" class="margin-toggle"/><span
class="sidenote">The <a
href="#waiting-interface-trait"><code>WaitAPI</code></a> trait
determines what polling mechamism is used.<br />
<br />
</span></span> If the optional <code>timeout=</code> argument is
provided then the deadline is <code>time() + timeout</code>.</p>
<p><code>buffer_i</code> specifies a buffer index at which the transfer
begins. If <code>stream</code> is indexable then <code>stream_i</code>
can be used to specify the stream byte-index at which the transfer
begins. A <code>stream</code> is indexable if
<code>Cursors(stream) &lt;: HasCursors</code>.</p>
<p>The direction of transfer depends on
<code>TransferDirection(stream) -&gt;</code> (<code>In</code>,
<code>Out</code> or <code>Exchange</code>).</p>
<p>The type of items transferred depends on
<code>ioeltype(buffer)</code>.<span
class="sidenote-wrapper"><label for="sn-15" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-15" class="margin-toggle"/><span
class="sidenote">By default <code>ioeltype(x) = eltype(x)</code>.<br />
<br />
</span></span></p>
<p>The <code>buffer</code> can be an <code>AbstractArray</code>, an
<code>AbstractChannel</code>, a <code>URI</code>, a
<code>Base.IO</code>, or another <code>Stream</code>. Or, the
<code>buffer</code> can be any collection that implements the Iteration
Interface, the Indexing Interface, the AbstractChannel interface, or the
<code>push!</code>/<code>pop!</code> interface.<span
class="sidenote-wrapper"><label for="sn-16" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-16" class="margin-toggle"/><span
class="sidenote">In some cases it is necessary to define a method of <a
href="#buffer-interface-traits"><code>ToBufferInterface</code> or
<code>FromBufferInterface</code></a> to specify the interface to use for
a particular buffer type (e.g. if a buffer implements more than one of
the supported interfaces). Defining these trait methods can also help to
ensure that the most efficient interface is used for a particular buffer
type.<br />
<br />
</span></span></p>
<p>If either the <code>stream</code> or the <code>buffer</code> is a
<code>URI</code> then items are transferred to (or from) the identified
resource. A transfer to a <code>URI</code> creates a new resource or
replaces the resource (i.e. HTTP PUT semantics).</p>
<div class="sourceCode" id="cb13" data-startFrom="875"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 874;"><span id="cb13-875"><a href="#cb13-875"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer!</span>(stream, buffer,</span>
<span id="cb13-876"><a href="#cb13-876"></a>                               n<span class="op">::</span><span class="dt">Union{Integer,Missing}</span>=<span class="cn">missing</span>;</span>
<span id="cb13-877"><a href="#cb13-877"></a>                               stream_i<span class="op">::</span><span class="dt">Union{Integer,Missing}</span>=<span class="cn">missing</span>,</span>
<span id="cb13-878"><a href="#cb13-878"></a>                               buffer_i<span class="op">::</span><span class="dt">Union{Integer,Missing}</span>=<span class="cn">missing</span>,</span>
<span id="cb13-879"><a href="#cb13-879"></a>                               deadline<span class="op">=</span><span class="cn">Inf</span>,</span>
<span id="cb13-880"><a href="#cb13-880"></a>                               timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb13-881"><a href="#cb13-881"></a></span>
<span id="cb13-882"><a href="#cb13-882"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(stream)</span>
<span id="cb13-883"><a href="#cb13-883"></a>    <span class="pp">@require</span> <span class="fu">ismissing</span>(n) <span class="op">||</span> n <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb13-884"><a href="#cb13-884"></a>    <span class="pp">@require</span> <span class="fu">ismissing</span>(stream_i) <span class="op">||</span> stream_i <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb13-885"><a href="#cb13-885"></a>    <span class="pp">@require</span> <span class="fu">ismissing</span>(stream_i) <span class="op">||</span></span>
<span id="cb13-886"><a href="#cb13-886"></a>             <span class="fu">StreamIndexing</span>(stream) <span class="op">==</span> <span class="fu">IndexableIO</span>() <span class="op">||</span></span>
<span id="cb13-887"><a href="#cb13-887"></a>             <span class="fu">Cursors</span>(stream) isa HasCursors</span>
<span id="cb13-888"><a href="#cb13-888"></a>    <span class="pp">@require</span> <span class="fu">ismissing</span>(buffer_i) <span class="op">||</span> buffer_i <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb13-889"><a href="#cb13-889"></a></span>
<span id="cb13-890"><a href="#cb13-890"></a>    <span class="pp">@db</span> <span class="fu">typeof</span>(stream) stream_i buffer_i deadline timeout</span>
<span id="cb13-891"><a href="#cb13-891"></a></span>
<span id="cb13-892"><a href="#cb13-892"></a>    n <span class="op">=</span> <span class="fu">missing_or_uint64</span>(n)</span>
<span id="cb13-893"><a href="#cb13-893"></a>    stream_i <span class="op">=</span> <span class="fu">missing_or_uint64</span>(stream_i)</span>
<span id="cb13-894"><a href="#cb13-894"></a>    buffer_i <span class="op">=</span> <span class="fu">missing_or_uint64</span>(buffer_i)</span>
<span id="cb13-895"><a href="#cb13-895"></a></span>
<span id="cb13-896"><a href="#cb13-896"></a>    r <span class="op">=</span> <span class="fu">_transfer!</span>(stream, buffer, (stream_i, buffer_i, n),</span>
<span id="cb13-897"><a href="#cb13-897"></a>                   <span class="fu">deadline_or_timeout</span>(deadline, timeout))</span>
<span id="cb13-898"><a href="#cb13-898"></a></span>
<span id="cb13-899"><a href="#cb13-899"></a>    <span class="fu">transfer_complete</span>(stream, buffer, r)</span>
<span id="cb13-900"><a href="#cb13-900"></a></span>
<span id="cb13-901"><a href="#cb13-901"></a>    <span class="pp">@ensure</span> r isa <span class="dt">UInt</span></span>
<span id="cb13-902"><a href="#cb13-902"></a>    <span class="pp">@ensure</span> <span class="fu">ismissing</span>(n) <span class="op">||</span> r <span class="op">&lt;=</span> n</span>
<span id="cb13-903"><a href="#cb13-903"></a>    <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb13-904"><a href="#cb13-904"></a><span class="kw">end</span></span>
<span id="cb13-905"><a href="#cb13-905"></a></span>
<span id="cb13-906"><a href="#cb13-906"></a><span class="fu">missing_or_uint64</span>(i) <span class="op">=</span> <span class="fu">ismissing</span>(i) ? i <span class="op">:</span> <span class="fu">UInt</span>(<span class="fu">unsigned</span>(i))</span>
<span id="cb13-907"><a href="#cb13-907"></a></span>
<span id="cb13-908"><a href="#cb13-908"></a><span class="kw">function</span> <span class="fu">deadline_or_timeout</span>(deadline, timeout)</span>
<span id="cb13-909"><a href="#cb13-909"></a>    <span class="fu">Float64</span>((timeout <span class="op">==</span> <span class="fl">0</span>)   ? <span class="fl">0</span> <span class="op">:</span></span>
<span id="cb13-910"><a href="#cb13-910"></a>            (timeout <span class="op">==</span> <span class="cn">Inf</span>) ? deadline <span class="op">:</span></span>
<span id="cb13-911"><a href="#cb13-911"></a>                               (<span class="fu">time</span>() <span class="op">+</span> timeout))</span>
<span id="cb13-912"><a href="#cb13-912"></a><span class="kw">end</span></span>
<span id="cb13-913"><a href="#cb13-913"></a></span>
<span id="cb13-914"><a href="#cb13-914"></a><span class="fu">transfer!</span>(a<span class="op">...</span>; timeout) <span class="op">=</span> <span class="fu">transfer!</span>(a<span class="op">...</span>; deadline<span class="op">=</span><span class="fu">time</span>() <span class="op">+</span> <span class="fu">Float64</span>(timeout))</span></code></pre></div>
<p><code>transfer_complete</code> is called at the end of the top-level
<code>transfer!</code> method. A single call to the top-level
<code>tansfer!</code> method may result in many calls to low level
driver methods. e.g. to transfer every item in a collection. The
<code>transfer_complete</code> hook can be used, for example, to flush
an output buffer at end of a transfer.</p>
<div class="sourceCode" id="cb14" data-startFrom="924"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 923;"><span id="cb14-924"><a href="#cb14-924"></a><span class="fu">transfer_complete</span>(stream, buf, n) <span class="op">=</span> <span class="cn">nothing</span></span></code></pre></div>
<h3 id="transfera-b"><code>transfer!(a =&gt; b)</code></h3>
<pre><code>transfer!(stream =&gt; buffer, [n]; start=(1 =&gt; 1), kw...) -&gt; n_transfered
transfer!(buffer =&gt; stream, [n]; start=(1 =&gt; 1), kw...) -&gt; n_transfered</code></pre>
<p><code>stream</code> and <code>buffer</code> can be passed to
<code>transfer!</code> as a pair. <code>In</code> streams must be on the
left. <code>Out</code> streams must be on the right.</p>
<div class="sourceCode" id="cb16" data-startFrom="937"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 936;"><span id="cb16-937"><a href="#cb16-937"></a><span class="pp">@inline</span> <span class="kw">function</span> <span class="fu">transfer!</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Stream,&lt;:Any}</span>, a<span class="op">...</span>;</span>
<span id="cb16-938"><a href="#cb16-938"></a>                           start<span class="op">::</span><span class="dt">Pair</span>=(<span class="cn">missing</span> <span class="op">=&gt;</span> <span class="cn">missing</span>), kw<span class="op">...</span>)</span>
<span id="cb16-939"><a href="#cb16-939"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">1</span>]) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb16-940"><a href="#cb16-940"></a>    stream_i, buffer_i <span class="op">=</span> start</span>
<span id="cb16-941"><a href="#cb16-941"></a>    <span class="fu">transfer!</span>(t[<span class="fl">1</span>], t[<span class="fl">2</span>], a<span class="op">...</span>; stream_i, buffer_i, kw<span class="op">...</span>)</span>
<span id="cb16-942"><a href="#cb16-942"></a><span class="kw">end</span></span>
<span id="cb16-943"><a href="#cb16-943"></a></span>
<span id="cb16-944"><a href="#cb16-944"></a><span class="pp">@inline</span> <span class="kw">function</span> <span class="fu">transfer!</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Any,&lt;:Stream}</span>, a<span class="op">...</span>;</span>
<span id="cb16-945"><a href="#cb16-945"></a>                           start<span class="op">::</span><span class="dt">Pair</span>=(<span class="cn">missing</span> <span class="op">=&gt;</span> <span class="cn">missing</span>), kw<span class="op">...</span>)</span>
<span id="cb16-946"><a href="#cb16-946"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">2</span>]) <span class="op">==</span> <span class="fu">Out</span>()</span>
<span id="cb16-947"><a href="#cb16-947"></a>    buffer_i, stream_i <span class="op">=</span> start</span>
<span id="cb16-948"><a href="#cb16-948"></a>    <span class="fu">transfer!</span>(t[<span class="fl">2</span>], t[<span class="fl">1</span>], a<span class="op">...</span>; stream_i, buffer_i, kw<span class="op">...</span>)</span>
<span id="cb16-949"><a href="#cb16-949"></a><span class="kw">end</span></span>
<span id="cb16-950"><a href="#cb16-950"></a></span>
<span id="cb16-951"><a href="#cb16-951"></a><span class="pp">@inline</span> <span class="kw">function</span> <span class="fu">transfer!</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Stream,&lt;:Stream}</span>, a<span class="op">...</span>;</span>
<span id="cb16-952"><a href="#cb16-952"></a>                           start<span class="op">::</span><span class="dt">Pair</span>=(<span class="cn">missing</span> <span class="op">=&gt;</span> <span class="cn">missing</span>), kw<span class="op">...</span>)</span>
<span id="cb16-953"><a href="#cb16-953"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">1</span>]) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb16-954"><a href="#cb16-954"></a>    <span class="pp">@require</span> <span class="fu">TransferDirection</span>(t[<span class="fl">2</span>]) <span class="op">==</span> <span class="fu">Out</span>()</span>
<span id="cb16-955"><a href="#cb16-955"></a>    stream_i, buffer_i <span class="op">=</span> start</span>
<span id="cb16-956"><a href="#cb16-956"></a>    <span class="fu">transfer!</span>(t[<span class="fl">1</span>], t[<span class="fl">2</span>], a<span class="op">...</span>; stream_i, buffer_i, kw<span class="op">...</span>)</span>
<span id="cb16-957"><a href="#cb16-957"></a><span class="kw">end</span></span>
<span id="cb16-958"><a href="#cb16-958"></a></span>
<span id="cb16-959"><a href="#cb16-959"></a><span class="kw">const</span> IOStreams <span class="op">=</span> <span class="dt">Tuple</span>{<span class="op">&lt;:</span><span class="dt">Stream</span>,<span class="op">&lt;:</span><span class="dt">Stream</span>}</span>
<span id="cb16-960"><a href="#cb16-960"></a><span class="fu">input</span>(io<span class="op">::</span><span class="dt">IOStreams</span>) <span class="op">=</span> (<span class="pp">@require</span> <span class="fu">is_input</span>(io[<span class="fl">1</span>]); io[<span class="fl">1</span>])</span>
<span id="cb16-961"><a href="#cb16-961"></a><span class="fu">output</span>(io<span class="op">::</span><span class="dt">IOStreams</span>) <span class="op">=</span> (<span class="pp">@require</span> <span class="fu">is_output</span>(io[<span class="fl">2</span>]); io[<span class="fl">2</span>])</span>
<span id="cb16-962"><a href="#cb16-962"></a></span>
<span id="cb16-963"><a href="#cb16-963"></a></span>
<span id="cb16-964"><a href="#cb16-964"></a><span class="fu">transfer!</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:Any,&lt;:IOStreams}</span>, a<span class="op">...</span>; kw<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb16-965"><a href="#cb16-965"></a>    <span class="fu">transfer!</span>(t[<span class="fl">1</span>] <span class="op">=&gt;</span> <span class="fu">output</span>(t[<span class="fl">2</span>]), a<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb16-966"><a href="#cb16-966"></a></span>
<span id="cb16-967"><a href="#cb16-967"></a><span class="fu">transfer!</span>(t<span class="op">::</span><span class="dt">Pair{&lt;:IOStreams,&lt;:Any}</span>, a<span class="op">...</span>; kw<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb16-968"><a href="#cb16-968"></a>    <span class="fu">transfer!</span>(<span class="fu">input</span>(t[<span class="fl">1</span>]) <span class="op">=&gt;</span> t[<span class="fl">2</span>], a<span class="op">...</span>; kw<span class="op">...</span>)</span></code></pre></div>
<h2 id="waiting-for-the-deadline">Waiting for the Deadline</h2>
<p>The specification for <code>transfer!</code> says: If no items are
immediately available, wait until <code>time() &gt; deadline</code> for
at least one item to be transferred.</p>
<p>The method below starts by simply attempting the transfer. This
avoids the overhead of locking and measuring the current time. If the
initial transfer attempt yields no data, the
<code>wait_for_transfer</code> method is selected based on Waiting
Interface trait.</p>
<p>If the buffer elements are larger than one byte and the stream has
Unknown Availability then <code>attempt_transfer</code> can end up with
a partial item in the buffer. In this situation a second attempt is
needed to transfer the missing bytes. A TimeoutStream wrapper is used to
ensure that the second transfer adheres to the specified deadline.</p>
<div class="sourceCode" id="cb17" data-startFrom="991"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 990;"><span id="cb17-991"><a href="#cb17-991"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_transfer!</span>(stream, buffer, indices, deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb17-992"><a href="#cb17-992"></a></span>
<span id="cb17-993"><a href="#cb17-993"></a>    <span class="cf">if</span> (<span class="fu">Availability</span>(stream) <span class="op">==</span> <span class="fu">Availability</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb17-994"><a href="#cb17-994"></a>    <span class="op">&amp;&amp;</span>  <span class="cf">try</span> <span class="fu">ioelsize</span>(buffer) <span class="op">!=</span> <span class="fl">1</span> <span class="cf">catch</span>; <span class="cn">false</span> <span class="cf">end</span></span>
<span id="cb17-995"><a href="#cb17-995"></a>    <span class="op">&amp;&amp;</span>  deadline <span class="op">!=</span> <span class="cn">Inf</span>)</span>
<span id="cb17-996"><a href="#cb17-996"></a>        stream <span class="op">=</span> <span class="fu">timeout_stream</span>(stream; deadline)</span>
<span id="cb17-997"><a href="#cb17-997"></a>    <span class="kw">end</span></span>
<span id="cb17-998"><a href="#cb17-998"></a></span>
<span id="cb17-999"><a href="#cb17-999"></a>    r <span class="op">=</span> <span class="fu">attempt_transfer</span>(stream, buffer, indices)</span>
<span id="cb17-1000"><a href="#cb17-1000"></a>    <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">||</span> <span class="fu">iszero</span>(deadline)</span>
<span id="cb17-1001"><a href="#cb17-1001"></a>        <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> r</span>
<span id="cb17-1002"><a href="#cb17-1002"></a>    <span class="cf">end</span></span>
<span id="cb17-1003"><a href="#cb17-1003"></a></span>
<span id="cb17-1004"><a href="#cb17-1004"></a>    <span class="fu">wait_for_transfer</span>(stream, <span class="fu">WaitAPI</span>(stream), buffer, indices, deadline)</span>
<span id="cb17-1005"><a href="#cb17-1005"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="transfer-mode-trait">Transfer Mode Trait</h1>
<div class="sourceCode" id="cb18" data-startFrom="1010"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1009;"><span id="cb18-1010"><a href="#cb18-1010"></a><span class="kw">struct</span> TransferMode{T} <span class="kw">end</span></span></code></pre></div>
<p>The <code>TransferMode</code> trait describes the blocking behaviour
of the underlying operating system calls used for a file descriptor.</p>
<p><code>TransferMode(stream)</code> returns
<code>TransferMode{T}()</code> where <code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Transfer Mode</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:Blocking</code></td>
<td style="text-align: left;">System call does not return until the
transfer is complete.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Immediate</code></td>
<td style="text-align: left;">System call transfers only as much data as
it can without blocking, then returns
(e.g. <code>O_NONBLOCK</code>).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Async</code></td>
<td style="text-align: left;">System call schedules transfer for
asynchronous execution, the returns (e.g. <a
href="https://manpages.debian.org/unstable/liburing-dev/io_uring.7.en.html"><code>io_uring</code></a>
or <a href="https://man7.org/linux/man-pages/man7/aio.7.html">POSIX
AIO</a>).</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb19" data-startFrom="1032"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1031;"><span id="cb19-1032"><a href="#cb19-1032"></a><span class="fu">TransferMode</span>(x) <span class="op">=</span> <span class="fu">TransferMode</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb19-1033"><a href="#cb19-1033"></a><span class="fu">TransferMode</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferMode</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb19-1034"><a href="#cb19-1034"></a>                                      <span class="fu">TransferMode</span><span class="dt">{:Immediate}</span>()</span></code></pre></div>
<h1 id="transfer-interface-trait">Transfer Interface Trait</h1>
<div class="sourceCode" id="cb20" data-startFrom="1039"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1038;"><span id="cb20-1039"><a href="#cb20-1039"></a><span class="kw">struct</span> TransferAPI{T} <span class="kw">end</span></span></code></pre></div>
<p>The <code>TransferAPI</code> trait describes ways transferring bytes
to/from a file descriptor.</p>
<p><code>TransferAPI(stream)</code> returns <code>TransferAPI{T}</code>
where <code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:LibC</code></td>
<td style="text-align: left;">Transfer bytes using <a
href="https://man7.org/linux/man-pages/man2/read.2.html"><code>read(2)</code></a>
and <a
href="https://man7.org/linux/man-pages/man2/write.2.html"><code>write(2)</code></a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:IOURing</code></td>
<td style="text-align: left;">Transfer bytes using <a
href="https://manpages.debian.org/unstable/liburing-dev/io_uring_prep_read.3.en.html"><code>io_uring_prep_read(3)</code></a>,
<a
href="https://manpages.debian.org/unstable/liburing-dev/io_uring_prep_write.3.en.html"><code>io_uring_prep_write(3)</code></a>
and <a
href="https://manpages.debian.org/unstable/liburing-dev/io_uring_wait_cqe.3.en.html"><code>io_uring_wait_cqe(3)</code></a>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:AIO</code></td>
<td style="text-align: left;">Transfer bytes using <a
href="https://man7.org/linux/man-pages/man7/aio.7.html">AIO</a> POSIX
asynchronous I/O.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:GSD</code></td>
<td style="text-align: left;">Transfer bytes using <a
href="https://developer.apple.com/documentation/dispatch?language=objc">Grand
Central Dispatch</a>.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb21" data-startFrom="1072"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1071;"><span id="cb21-1072"><a href="#cb21-1072"></a><span class="fu">TransferAPI</span>(x) <span class="op">=</span> <span class="fu">TransferAPI</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb21-1073"><a href="#cb21-1073"></a><span class="fu">TransferAPI</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferAPI</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb21-1074"><a href="#cb21-1074"></a>                                     <span class="fu">TransferAPI</span><span class="dt">{:LibC}</span>()</span>
<span id="cb21-1075"><a href="#cb21-1075"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">TransferAPI</span>) <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb21-1076"><a href="#cb21-1076"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">TransferAPI{:IOURing}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">islinux</span>()</span>
<span id="cb21-1077"><a href="#cb21-1077"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">TransferAPI{:AIO}</span>) <span class="op">=</span> <span class="cn">false</span></span>
<span id="cb21-1078"><a href="#cb21-1078"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">TransferAPI{:GSD}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">isapple</span>()</span></code></pre></div>
<h1 id="waiting-interface-trait">Waiting Interface Trait</h1>
<div class="sourceCode" id="cb22" data-startFrom="1083"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1082;"><span id="cb22-1083"><a href="#cb22-1083"></a><span class="kw">struct</span> WaitAPI{T} <span class="kw">end</span></span>
<span id="cb22-1084"><a href="#cb22-1084"></a><span class="kw">const</span> AnyWaitAPI <span class="op">=</span> WaitAPI</span></code></pre></div>
<p>The <code>WaitAPI</code> trait describes ways of waiting for OS
resources that are not immediately available. e.g. when
<code>read(2)</code> returns <code>EAGAIN</code>
(<code>EWOULDBLOCK</code>), or when <code>waitpid(2)</code> returns
<code>0</code>.</p>
<p>Resource types, <code>R</code>, that have a special waiting interface
<code>T</code> define a method of
<code>Base.wait(::WaitAPI{T}, r::R)</code>. <code>WaitAPI{:Sleep}</code>
is the default.<span
class="sidenote-wrapper"><label for="sn-17" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-17" class="margin-toggle"/><span
class="sidenote">Sleeping may be the most efficient mechanism for small
systems with simple IO requirements, for large systems where throughput
is more important than latency, or for systems that simply do not spend
a lot of time waiting for IO. Sleeping allows other Julia tasks to run
immediately, whereas the other polling mechanisms all have some amount
of book-keeping and system call overhead.<br />
<br />
</span></span></p>
<p>If a waiting interface <code>T</code>, is not available on a
particular OS then <code>Base.isvalid(::WaitAPI{T})</code> should be
defined to return <code>false</code>.</p>
<p><code>WaitAPI(stream)</code> returns <code>WaitAPI{T}()</code> where
<code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Waiting Mechanism</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:Sleep</code></td>
<td style="text-align: left;">Wait using a dumb retry/sleep loop.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:PosixPoll</code></td>
<td style="text-align: left;">Wait using the POSIX <code>poll</code>
interface. Wait for activity on a set of file descriptors. Applicable to
FIFO pipes, sockets and character devices (but not local files). See <a
href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll(2)</code></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:EPoll</code></td>
<td style="text-align: left;">Wait using the Linux <code>epoll</code>
interface. Like <code>poll</code> but scales better for workloads with a
large number of waiting streams. See <a
href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code>epoll(7)</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:IOURing</code></td>
<td style="text-align: left;">Wait using the Linux <code>io_uring</code>
interface. Works with local disk files. See <a
href="https://manpages.debian.org/unstable/liburing-dev/io_uring.7.en.html"><code>io_uring(7)</code></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:KQueue</code></td>
<td style="text-align: left;">Wait using the BSD <code>kqueue</code>
interface. Like <code>epoll</code> but can also wait for files,
processes, signals etc. See <a
href="https://www.freebsd.org/cgi/man.cgi?kqueue"><code>kqueue(2)</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:PidFD()</code></td>
<td style="text-align: left;">Wait for process termination using the
Linux <code>pidfd</code> interface. A <code>pidfd</code> is a special
process monitoring file descriptor that can in turn be monitored by
<code>poll</code> or <code>epoll</code>. See <a
href="http://man7.org/linux/man-pages/man2/pidfd_open.2.html"><code>pidfd_open(2)</code></a></td>
</tr>
</tbody>
</table>
<p>FIXME: Conditer WaitWithoutYeilding – Block calling thread. - Might
be useful where low latency is important.</p>
<div class="sourceCode" id="cb23" data-startFrom="1146"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1145;"><span id="cb23-1146"><a href="#cb23-1146"></a><span class="fu">WaitAPI</span>(x) <span class="op">=</span> <span class="fu">WaitAPI</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb23-1147"><a href="#cb23-1147"></a><span class="fu">WaitAPI</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">WaitAPI</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb23-1148"><a href="#cb23-1148"></a>                                          <span class="fu">WaitAPI</span><span class="dt">{:Sleep}</span>()</span>
<span id="cb23-1149"><a href="#cb23-1149"></a></span>
<span id="cb23-1150"><a href="#cb23-1150"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI</span>) <span class="op">=</span> <span class="cn">false</span></span>
<span id="cb23-1151"><a href="#cb23-1151"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI{:Sleep}</span>) <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb23-1152"><a href="#cb23-1152"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI{:PosixPoll}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">isunix</span>()</span>
<span id="cb23-1153"><a href="#cb23-1153"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI{:EPoll}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">islinux</span>()</span>
<span id="cb23-1154"><a href="#cb23-1154"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI{:PidFD}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">islinux</span>()</span>
<span id="cb23-1155"><a href="#cb23-1155"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI{:IOURing}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">islinux</span>()</span>
<span id="cb23-1156"><a href="#cb23-1156"></a><span class="bu">Base</span>.<span class="fu">isvalid</span>(<span class="op">::</span><span class="dt">WaitAPI{:KQueue}</span>) <span class="op">=</span> <span class="bu">Sys</span>.<span class="fu">isbsd</span>() <span class="op">&amp;&amp;</span> <span class="cn">false</span> <span class="co"># not yet implemented.</span></span>
<span id="cb23-1157"><a href="#cb23-1157"></a></span>
<span id="cb23-1158"><a href="#cb23-1158"></a><span class="fu">firstvalid</span>(x, xs<span class="op">...</span>) <span class="op">=</span> <span class="fu">isvalid</span>(x) ? x <span class="op">:</span> <span class="fu">firstvalid</span>(xs<span class="op">...</span>)</span>
<span id="cb23-1159"><a href="#cb23-1159"></a><span class="fu">firstvalid</span>() <span class="op">=</span> <span class="cn">nothing</span></span>
<span id="cb23-1160"><a href="#cb23-1160"></a></span>
<span id="cb23-1161"><a href="#cb23-1161"></a><span class="kw">const</span> default_poll_interface <span class="op">=</span> <span class="fu">firstvalid</span>(<span class="fu">WaitAPI</span><span class="dt">{:KQueue}</span>(),</span>
<span id="cb23-1162"><a href="#cb23-1162"></a>                                          <span class="fu">WaitAPI</span><span class="dt">{:IOURing}</span>(),</span>
<span id="cb23-1163"><a href="#cb23-1163"></a>                                          <span class="fu">WaitAPI</span><span class="dt">{:EPoll}</span>(),</span>
<span id="cb23-1164"><a href="#cb23-1164"></a>                                          <span class="fu">WaitAPI</span><span class="dt">{:PosixPoll}</span>(),</span>
<span id="cb23-1165"><a href="#cb23-1165"></a>                                          <span class="fu">WaitAPI</span><span class="dt">{:Sleep}</span>())</span>
<span id="cb23-1166"><a href="#cb23-1166"></a></span>
<span id="cb23-1167"><a href="#cb23-1167"></a><span class="fu">_wait</span>(x, <span class="op">::</span><span class="dt">WaitAPI{:Sleep}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span> <span class="fu">sleep</span>(<span class="fl">0.1</span>)</span>
<span id="cb23-1168"><a href="#cb23-1168"></a></span>
<span id="cb23-1169"><a href="#cb23-1169"></a></span>
<span id="cb23-1170"><a href="#cb23-1170"></a><span class="pp">@static</span> <span class="cf">if</span> <span class="cn">VERSION</span> <span class="op">&gt;</span> <span class="st">v&quot;1.6&quot;</span></span></code></pre></div>
<h2 id="preferred-polling-interface">Preferred Polling Interface</h2>
<pre><code>set_poll_interface(name)</code></pre>
<p>Configure the preferred event polling interface: “kqueue”,
“io_uring”, “epoll”, “poll”, or “sleep”.<span
class="sidenote-wrapper"><label for="sn-18" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-18" class="margin-toggle"/><span
class="sidenote">This setting applies only to
<code>poll(2)</code>-compatible file descriptors (i.e. it does not apply
to local disk files).<br />
<br />
</span></span> This setting is persistently stored through <a
href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p>
<p>By default, IOTraits will try to choose the best available interface
(see <code>default_poll_interface</code>).</p>
<p>To find out what interface is used for a particular <code>FD</code>
call: <code>WaitAPI(fd)</code></p>
<div class="sourceCode" id="cb25" data-startFrom="1192"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1191;"><span id="cb25-1192"><a href="#cb25-1192"></a><span class="kw">function</span> <span class="fu">set_poll_interface</span>(x)</span>
<span id="cb25-1193"><a href="#cb25-1193"></a>    <span class="pp">@require</span> <span class="fu">isvalid</span>(<span class="fu">poll_interface</span>(x))</span>
<span id="cb25-1194"><a href="#cb25-1194"></a>    <span class="pp">@set_preferences</span>!(<span class="st">&quot;poll_interface&quot;</span> <span class="op">=&gt;</span> x)</span>
<span id="cb25-1195"><a href="#cb25-1195"></a>    <span class="pp">@warn</span> <span class="st">&quot;Preferred IOTraits.WaitAPI{:Poll} set to </span><span class="sc">$</span>(<span class="fu">poll_interface</span>(x))<span class="st">.&quot;</span> <span class="op">*</span></span>
<span id="cb25-1196"><a href="#cb25-1196"></a>          <span class="st">&quot;UnixIO must be recompiled for this setting to take effect.&quot;</span></span>
<span id="cb25-1197"><a href="#cb25-1197"></a><span class="kw">end</span></span>
<span id="cb25-1198"><a href="#cb25-1198"></a></span>
<span id="cb25-1199"><a href="#cb25-1199"></a><span class="kw">const</span> preferred_poll_interface <span class="op">=</span> <span class="cf">begin</span></span>
<span id="cb25-1200"><a href="#cb25-1200"></a>    api <span class="op">=</span> <span class="fu">WaitAPI</span><span class="dt">{Symbol(@load_preference(&quot;poll_interface&quot;))}</span>()</span>
<span id="cb25-1201"><a href="#cb25-1201"></a>    <span class="fu">isvalid</span>(api) ? api <span class="op">:</span> default_poll_interface</span>
<span id="cb25-1202"><a href="#cb25-1202"></a><span class="cf">end</span></span>
<span id="cb25-1203"><a href="#cb25-1203"></a>else</span>
<span id="cb25-1204"><a href="#cb25-1204"></a><span class="kw">const</span> preferred_poll_interface <span class="op">=</span> default_poll_interface</span>
<span id="cb25-1205"><a href="#cb25-1205"></a><span class="kw">end</span></span>
<span id="cb25-1206"><a href="#cb25-1206"></a><span class="fu">WaitAPI</span><span class="dt">{:Poll}</span>() <span class="op">=</span> IOTraits.preferred_poll_interface</span></code></pre></div>
<h2 id="wait-by-sleeping-method">Wait By Sleeping Method</h2>
<p>The Wait By Sleeping method for <code>wait_for_transfer</code> calls
<code>attempt_transfer</code> in a loop until data is available or the
deadline is reached.</p>
<p>An exponentially increasing sleep delay minimises latency for short
waits and limits CPU use for longer waits.</p>
<div class="sourceCode" id="cb26" data-startFrom="1219"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1218;"><span id="cb26-1219"><a href="#cb26-1219"></a><span class="kw">const</span> delay_sequence <span class="op">=</span></span>
<span id="cb26-1220"><a href="#cb26-1220"></a>    <span class="fu">ExponentialBackOff</span>(;n <span class="op">=</span> <span class="fu">typemax</span>(<span class="dt">Int</span>),</span>
<span id="cb26-1221"><a href="#cb26-1221"></a>                        first_delay <span class="op">=</span> <span class="fl">0.01</span>, factor <span class="op">=</span> <span class="fl">1.2</span>, max_delay <span class="op">=</span> <span class="fl">0.25</span>)</span>
<span id="cb26-1222"><a href="#cb26-1222"></a></span>
<span id="cb26-1223"><a href="#cb26-1223"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">wait_for_transfer</span>(stream, <span class="op">::</span><span class="dt">WaitAPI{:Sleep}</span>,</span>
<span id="cb26-1224"><a href="#cb26-1224"></a>                               buf, indices, deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb26-1225"><a href="#cb26-1225"></a>    <span class="cf">for</span> delay <span class="kw">in</span> delay_sequence</span>
<span id="cb26-1226"><a href="#cb26-1226"></a>        <span class="cf">if</span> <span class="fu">isfinished</span>(stream)</span>
<span id="cb26-1227"><a href="#cb26-1227"></a>            <span class="cf">return</span> <span class="fu">UInt</span>(<span class="fl">0</span>)</span>
<span id="cb26-1228"><a href="#cb26-1228"></a>        <span class="cf">end</span></span>
<span id="cb26-1229"><a href="#cb26-1229"></a>        r <span class="op">=</span> <span class="fu">attempt_transfer</span>(stream, buf, indices);</span>
<span id="cb26-1230"><a href="#cb26-1230"></a>        <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb26-1231"><a href="#cb26-1231"></a>            <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb26-1232"><a href="#cb26-1232"></a>        <span class="cf">end</span></span>
<span id="cb26-1233"><a href="#cb26-1233"></a>        <span class="cf">if</span> <span class="fu">time</span>() <span class="op">&gt;=</span> deadline</span>
<span id="cb26-1234"><a href="#cb26-1234"></a>            <span class="pp">@db</span> <span class="cf">return</span> <span class="fu">UInt</span>(<span class="fl">0</span>)</span>
<span id="cb26-1235"><a href="#cb26-1235"></a>        <span class="cf">end</span></span>
<span id="cb26-1236"><a href="#cb26-1236"></a>        <span class="fu">sleep</span>(delay)</span>
<span id="cb26-1237"><a href="#cb26-1237"></a>    <span class="cf">end</span></span>
<span id="cb26-1238"><a href="#cb26-1238"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="specialised-waiting-methods">Specialised Waiting Methods</h2>
<p>In the default waiting method, <code>wait</code> is called in a loop
until data is available or the deadline is reached. The appropriate
<code>wait</code> method will be selected according to Waiting
Mechanism.</p>
<p><code>Base.lock</code> and <code>Base.unlock</code> must be
implemented for each stream type.<span
class="sidenote-wrapper"><label for="sn-19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-19" class="margin-toggle"/><span
class="sidenote">These methods should do whatever is necessary to avoid
race conditions between <code>Base.wait</code> and
<code>attempt_transfer</code>. (FIXME, … and
<code>bytesavailable</code>) In UnixIO.jl <code>Base.wait</code> waits
for a <code>ThreadSynchronizer</code> and the underlying polling
mechanism notifies the <code>ThreadSynchronizer</code> to wake up the
waiting task.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb27" data-startFrom="1255"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1254;"><span id="cb27-1255"><a href="#cb27-1255"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">wait_for_transfer</span>(stream, <span class="op">::</span><span class="dt">AnyWaitAPI</span>,</span>
<span id="cb27-1256"><a href="#cb27-1256"></a>                               buf, indices, deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb27-1257"><a href="#cb27-1257"></a>    <span class="pp">@db</span> deadline <span class="op">-</span> <span class="fu">time</span>()</span>
<span id="cb27-1258"><a href="#cb27-1258"></a>    <span class="pp">@dblock</span> stream <span class="cf">begin</span></span>
<span id="cb27-1259"><a href="#cb27-1259"></a>        <span class="cf">while</span> !<span class="fu">isfinished</span>(stream)</span>
<span id="cb27-1260"><a href="#cb27-1260"></a>            <span class="fu">pump!</span>(stream; deadline)</span>
<span id="cb27-1261"><a href="#cb27-1261"></a>            <span class="fu">wait</span>(stream; deadline)</span>
<span id="cb27-1262"><a href="#cb27-1262"></a>            r <span class="op">=</span> <span class="fu">attempt_transfer</span>(stream, buf, indices)</span>
<span id="cb27-1263"><a href="#cb27-1263"></a>            <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb27-1264"><a href="#cb27-1264"></a>                <span class="pp">@db</span> <span class="cf">return</span> r</span>
<span id="cb27-1265"><a href="#cb27-1265"></a>            <span class="cf">end</span></span>
<span id="cb27-1266"><a href="#cb27-1266"></a>            <span class="cf">if</span> <span class="fu">time</span>() <span class="op">&gt;=</span> deadline</span>
<span id="cb27-1267"><a href="#cb27-1267"></a>                <span class="cf">break</span></span>
<span id="cb27-1268"><a href="#cb27-1268"></a>            <span class="cf">end</span></span>
<span id="cb27-1269"><a href="#cb27-1269"></a>            <span class="cf">if</span> !<span class="fu">isconnected</span>(stream) <span class="op">&amp;&amp;</span></span>
<span id="cb27-1270"><a href="#cb27-1270"></a>            <span class="fu">availability_is_known</span>(stream) <span class="op">&amp;&amp;</span></span>
<span id="cb27-1271"><a href="#cb27-1271"></a>            <span class="fu">bytesavailable</span>(stream) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb27-1272"><a href="#cb27-1272"></a>                <span class="pp">@warn</span> <span class="st">&quot;wait_for_transfer() </span><span class="sc">$</span>(<span class="fu">verb</span>(<span class="fu">TransferDirection</span>(stream)))<span class="st"> &quot;</span> <span class="op">*</span></span>
<span id="cb27-1273"><a href="#cb27-1273"></a>                      <span class="st">&quot;</span><span class="sc">$</span>stream<span class="st"> aborted by disconnect!</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">*</span></span>
<span id="cb27-1274"><a href="#cb27-1274"></a>                      <span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">bytesavailable</span>(stream))<span class="st"> bytes are buffered &quot;</span> <span class="op">*</span></span>
<span id="cb27-1275"><a href="#cb27-1275"></a>                      <span class="st">&quot;but </span><span class="sc">$</span>(<span class="fu">typeof</span>(buf))<span class="st"> requires at least </span><span class="sc">$</span>(<span class="fu">ioelsize</span>(buf))<span class="st"> &quot;</span> <span class="op">*</span></span>
<span id="cb27-1276"><a href="#cb27-1276"></a>                      <span class="st">&quot;bytes.&quot;</span></span>
<span id="cb27-1277"><a href="#cb27-1277"></a>                <span class="cf">break</span></span>
<span id="cb27-1278"><a href="#cb27-1278"></a>            <span class="cf">end</span></span>
<span id="cb27-1279"><a href="#cb27-1279"></a>        <span class="cf">end</span></span>
<span id="cb27-1280"><a href="#cb27-1280"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="fu">UInt</span>(<span class="fl">0</span>)</span>
<span id="cb27-1281"><a href="#cb27-1281"></a>    <span class="cf">end</span></span>
<span id="cb27-1282"><a href="#cb27-1282"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="buffer-interface-traits">Buffer Interface Traits</h1>
<div class="sourceCode" id="cb28" data-startFrom="1288"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1287;"><span id="cb28-1288"><a href="#cb28-1288"></a><span class="kw">abstract type</span> BufferInterface <span class="kw">end</span></span>
<span id="cb28-1289"><a href="#cb28-1289"></a><span class="kw">struct</span> UsingIndex <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1290"><a href="#cb28-1290"></a><span class="kw">struct</span> UsingPtr <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1291"><a href="#cb28-1291"></a><span class="kw">struct</span> IsItemPtr <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1292"><a href="#cb28-1292"></a><span class="kw">struct</span> IsBytePtr <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1293"><a href="#cb28-1293"></a><span class="kw">struct</span> FromIO <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1294"><a href="#cb28-1294"></a><span class="kw">struct</span> FromStream <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1295"><a href="#cb28-1295"></a><span class="kw">struct</span> FromString <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1296"><a href="#cb28-1296"></a><span class="kw">struct</span> FromIteration <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1297"><a href="#cb28-1297"></a><span class="kw">struct</span> ToIO <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1298"><a href="#cb28-1298"></a><span class="kw">struct</span> ToStream <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1299"><a href="#cb28-1299"></a><span class="kw">struct</span> ToPush <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1300"><a href="#cb28-1300"></a><span class="kw">struct</span> ToPut <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span>
<span id="cb28-1301"><a href="#cb28-1301"></a><span class="kw">struct</span> ToRef <span class="op">&lt;:</span><span class="dt"> BufferInterface </span><span class="kw">end</span></span></code></pre></div>
<p>The <code>FromBufferInterface</code> trait defines what interface is
used to take data from a particular buffer type (or what interface is
preferred for best performance).</p>
<p><code>FromBufferInterface(buffer)</code> returns one of:</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>FromIO()</code></td>
<td style="text-align: left;">Take data from the buffer using the
<code>Base.IO</code> interface.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FromStream()</code></td>
<td style="text-align: left;">Take data from the
<code>IOTraits.Stream</code> interface.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FromString()</code></td>
<td style="text-align: left;">Use
<code>codeunits(buffer::AbstractString).                  | |</code>FromIteration()<code>| Use</code>for
x in
buffer…<code>.                                | |</code>UsingIndex()<code>| Use</code>buffer[i]<code>(the default).                           | |</code>UsingPtr()<code>| Use</code>unsafe_copyto!(x,
pointer(buffer),
n)<code>.             |  |</code>IsItemPtr()<code>| Use</code>unsafe_copyto!(x,
buffer,
n)<code>.                      |  |</code>IsBytePtr()<code>| Special case of</code>IsItemPtr<code>for</code>ioelsize(buffer)
== 1`.</td>
</tr>
</tbody>
</table>
<p>Default <code>FromBufferInterface</code> methods are built-in for
common buffer types:</p>
<div class="sourceCode" id="cb29" data-startFrom="1324"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1323;"><span id="cb29-1324"><a href="#cb29-1324"></a><span class="fu">FromBufferInterface</span>(x) <span class="op">=</span> <span class="fu">FromBufferInterface</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb29-1325"><a href="#cb29-1325"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">FromIteration</span>()</span>
<span id="cb29-1326"><a href="#cb29-1326"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:IO}</span>) <span class="op">=</span> <span class="fu">FromIO</span>()</span>
<span id="cb29-1327"><a href="#cb29-1327"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Stream}</span>) <span class="op">=</span> <span class="fu">FromStream</span>()</span>
<span id="cb29-1328"><a href="#cb29-1328"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:AbstractString}</span>) <span class="op">=</span> <span class="fu">FromString</span>()</span>
<span id="cb29-1329"><a href="#cb29-1329"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ref}</span>) <span class="op">=</span> <span class="fu">UsingPtr</span>()</span>
<span id="cb29-1330"><a href="#cb29-1330"></a><span class="fu">FromBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ptr{T}}</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">sizeof</span>(T) <span class="op">==</span> <span class="fl">1</span> ? <span class="fu">IsBytePtr</span>() <span class="op">:</span></span>
<span id="cb29-1331"><a href="#cb29-1331"></a>                                                                 <span class="fu">IsItemPtr</span>()</span></code></pre></div>
<p>Pointers can be used for <code>AbstractArray</code> buffers of Bits
types.</p>
<div class="sourceCode" id="cb30" data-startFrom="1337"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1336;"><span id="cb30-1337"><a href="#cb30-1337"></a><span class="fu">FromBufferInterface</span>(T<span class="op">::</span><span class="dt">Type{&lt;:AbstractArray}</span>) <span class="op">=</span> <span class="fu">ArrayIOInterface</span>(T)</span>
<span id="cb30-1338"><a href="#cb30-1338"></a></span>
<span id="cb30-1339"><a href="#cb30-1339"></a><span class="fu">ArrayIOInterface</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">UsingIndex</span>()</span>
<span id="cb30-1340"><a href="#cb30-1340"></a></span>
<span id="cb30-1341"><a href="#cb30-1341"></a><span class="fu">ArrayIOInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Array{T}}</span>) <span class="kw">where</span> T <span class="op">=</span></span>
<span id="cb30-1342"><a href="#cb30-1342"></a>    <span class="fu">isbitstype</span>(T) ? <span class="fu">UsingPtr</span>() <span class="op">:</span> <span class="fu">UsingIndex</span>()</span>
<span id="cb30-1343"><a href="#cb30-1343"></a></span>
<span id="cb30-1344"><a href="#cb30-1344"></a><span class="fu">ArrayIOInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Base.FastContiguousSubArray{T,&lt;:Any,&lt;:Array{T}}}</span>) <span class="kw">where</span> T <span class="op">=</span></span>
<span id="cb30-1345"><a href="#cb30-1345"></a>    <span class="fu">isbitstype</span>(T) ? <span class="fu">UsingPtr</span>() <span class="op">:</span> <span class="fu">UsingIndex</span>()</span></code></pre></div>
<p>FIXME<span
class="sidenote-wrapper"><label for="sn-20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-20" class="margin-toggle"/><span
class="sidenote">⚠️ hook in an interface to <code>writev()</code> here
?<br />
<br />
</span></span></p>
<p>The <code>ToBufferInterface</code> trait defines what interface is
used to store data in a particular type of buffer (or what interface is
preferred for best performance).</p>
<p><code>ToBufferInterface(buffer)</code> one of:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Interface</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ToIO</code></td>
<td style="text-align: left;">Write data to the buffer using the
<code>Base.IO</code> interface.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ToStream</code></td>
<td style="text-align: left;">Write data using the
<code>IOTraits.Stream</code> interface.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ToPush</code></td>
<td style="text-align: left;">Use <code>push!(buffer, data)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ToPut</code></td>
<td style="text-align: left;">Use <code>put!(buffer, data)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ToRef</code></td>
<td style="text-align: left;">Use <code>buffer[] = data</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>UsingIndex</code></td>
<td style="text-align: left;">Use
<code>buffer[i] = data (the default)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>UsingPtr</code></td>
<td style="text-align: left;">Use
<code>unsafe_copyto!(pointer(buffer), x, n)</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IsItemPtr</code></td>
<td style="text-align: left;">Use
<code>unsafe_copyto!(buffer, x, n)</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IsBytePtr</code></td>
<td style="text-align: left;">Special case of <code>IsItemPtr</code> for
<code>ioelsize(buffer) == 1</code>.</td>
</tr>
</tbody>
</table>
<p>Default <code>ToBufferInterface</code> methods are built-in for
common buffer types.</p>
<div class="sourceCode" id="cb31" data-startFrom="1372"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1371;"><span id="cb31-1372"><a href="#cb31-1372"></a><span class="fu">ToBufferInterface</span>(x) <span class="op">=</span> <span class="fu">ToBufferInterface</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb31-1373"><a href="#cb31-1373"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">ToPush</span>()</span>
<span id="cb31-1374"><a href="#cb31-1374"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:AbstractArray{&lt;:AbstractArray}}</span>) <span class="op">=</span> <span class="fu">ToPush</span>()</span>
<span id="cb31-1375"><a href="#cb31-1375"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:AbstractArray{&lt;:AbstractString}}</span>) <span class="op">=</span> <span class="fu">ToPush</span>()</span>
<span id="cb31-1376"><a href="#cb31-1376"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ref{&lt;:AbstractArray}}</span>) <span class="op">=</span> <span class="fu">ToRef</span>()</span>
<span id="cb31-1377"><a href="#cb31-1377"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ref{&lt;:AbstractString}}</span>) <span class="op">=</span> <span class="fu">ToRef</span>()</span>
<span id="cb31-1378"><a href="#cb31-1378"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:IO}</span>) <span class="op">=</span> <span class="fu">ToIO</span>()</span>
<span id="cb31-1379"><a href="#cb31-1379"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Stream}</span>) <span class="op">=</span> <span class="fu">ToStream</span>()</span>
<span id="cb31-1380"><a href="#cb31-1380"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:AbstractChannel}</span>) <span class="op">=</span> <span class="fu">ToPut</span>()</span>
<span id="cb31-1381"><a href="#cb31-1381"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ref}</span>) <span class="op">=</span> <span class="fu">UsingPtr</span>()</span>
<span id="cb31-1382"><a href="#cb31-1382"></a><span class="fu">ToBufferInterface</span>(T<span class="op">::</span><span class="dt">Type{&lt;:AbstractArray}</span>) <span class="op">=</span> <span class="fu">ArrayIOInterface</span>(T)</span>
<span id="cb31-1383"><a href="#cb31-1383"></a><span class="fu">ToBufferInterface</span>(<span class="op">::</span><span class="dt">Type{&lt;:Ptr{T}}</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">sizeof</span>(T) <span class="op">==</span> <span class="fl">1</span> ? <span class="fu">IsBytePtr</span>() <span class="op">:</span></span>
<span id="cb31-1384"><a href="#cb31-1384"></a>                                                               <span class="fu">IsItemPtr</span>()</span>
<span id="cb31-1385"><a href="#cb31-1385"></a></span>
<span id="cb31-1386"><a href="#cb31-1386"></a><span class="fu">buffer_is_indexed</span>(stream, buf) <span class="op">=</span> <span class="fu">is_input</span>(stream) ?</span>
<span id="cb31-1387"><a href="#cb31-1387"></a>    <span class="fu">ToBufferInterface</span>(buf) <span class="op">∉</span> (<span class="fu">ToPush</span>(), <span class="fu">ToIO</span>(), <span class="fu">ToStream</span>(), <span class="fu">ToPut</span>(), <span class="fu">ToRef</span>()) <span class="op">:</span></span>
<span id="cb31-1388"><a href="#cb31-1388"></a>    <span class="fu">FromBufferInterface</span>(buf) <span class="op">∉</span> (<span class="fu">FromIO</span>(), <span class="fu">FromStream</span>())</span></code></pre></div>
<h1 id="total-data-size-trait">Total Data Size Trait</h1>
<div class="sourceCode" id="cb32" data-startFrom="1393"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1392;"><span id="cb32-1393"><a href="#cb32-1393"></a><span class="kw">struct</span> TotalSize{T} <span class="kw">end</span></span>
<span id="cb32-1394"><a href="#cb32-1394"></a><span class="kw">const</span> AnyTotalSize <span class="op">=</span> TotalSize</span>
<span id="cb32-1395"><a href="#cb32-1395"></a><span class="kw">const</span> KnownTotalSize <span class="op">=</span> <span class="dt">Union</span>{TotalSize{<span class="op">:</span>Zero},</span>
<span id="cb32-1396"><a href="#cb32-1396"></a>                             TotalSize{<span class="op">:</span>Variable},</span>
<span id="cb32-1397"><a href="#cb32-1397"></a>                             TotalSize{<span class="op">:</span>Fixed}}</span></code></pre></div>
<p>The <code>TotalSize</code> trait describes how much data is available
from a stream.</p>
<p><code>TotalSize(stream)</code> returns <code>TotalSize{T}()</code>
where <code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Total Size</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:Zero</code></td>
<td style="text-align: left;">The <code>length</code> function always
returns zero. e.g. <code>S_IFLNK</code> or fd from <a
href="https://man7.org/linux/man-pages/man2/pidfd_open.2.html"><code>pidfd_open(2)</code></a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Variable</code></td>
<td style="text-align: left;">The total amount of data available can be
queried using the <code>length</code> function. Note: the total size can
change. e.g. new lines might be appended to a log file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Fixed</code></td>
<td style="text-align: left;">The amount of data is known and will not
change. Applicable to block devices. Applicable to some network streams.
e.g. a HTTP Message where Content-Length is known.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Infinite</code></td>
<td style="text-align: left;">End of file will never be reached.
Applicable to some device files.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Unknown</code></td>
<td style="text-align: left;">No known data size limit. But end of file
may be reached. e.g. if the other end is closed.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb33" data-startFrom="1428"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1427;"><span id="cb33-1428"><a href="#cb33-1428"></a><span class="fu">TotalSize</span>(x) <span class="op">=</span> <span class="fu">TotalSize</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb33-1429"><a href="#cb33-1429"></a><span class="fu">TotalSize</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TotalSize</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb33-1430"><a href="#cb33-1430"></a>                                   <span class="fu">TotalSize</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb33-1431"><a href="#cb33-1431"></a><span class="fu">length_is_known</span>(x) <span class="op">=</span> <span class="fu">TotalSize</span>(x) isa KnownTotalSize</span>
<span id="cb33-1432"><a href="#cb33-1432"></a></span>
<span id="cb33-1433"><a href="#cb33-1433"></a></span>
<span id="cb33-1434"><a href="#cb33-1434"></a><span class="kw">struct</span> LengthAPI{T} <span class="kw">end</span></span>
<span id="cb33-1435"><a href="#cb33-1435"></a><span class="fu">LengthAPI</span>(x) <span class="op">=</span> <span class="fu">LengthAPI</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb33-1436"><a href="#cb33-1436"></a><span class="fu">LengthAPI</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">LengthAPI</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb33-1437"><a href="#cb33-1437"></a>                                   <span class="fu">LengthAPI</span><span class="dt">{Missing}</span>()</span>
<span id="cb33-1438"><a href="#cb33-1438"></a></span>
<span id="cb33-1439"><a href="#cb33-1439"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_length</span>(stream, <span class="op">::</span><span class="dt">LengthAPI{:FStat}</span>)</span>
<span id="cb33-1440"><a href="#cb33-1440"></a>    <span class="fu">stat</span>(stream).size</span>
<span id="cb33-1441"><a href="#cb33-1441"></a><span class="kw">end</span></span>
<span id="cb33-1442"><a href="#cb33-1442"></a></span>
<span id="cb33-1443"><a href="#cb33-1443"></a></span>
<span id="cb33-1444"><a href="#cb33-1444"></a><span class="kw">struct</span> BlockSizeAPI{T} <span class="kw">end</span></span>
<span id="cb33-1445"><a href="#cb33-1445"></a><span class="fu">BlockSizeAPI</span>(x) <span class="op">=</span> <span class="fu">BlockSizeAPI</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb33-1446"><a href="#cb33-1446"></a><span class="fu">BlockSizeAPI</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">BlockSizeAPI</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb33-1447"><a href="#cb33-1447"></a>                                      <span class="fu">BlockSizeAPI</span><span class="dt">{Missing}</span>()</span>
<span id="cb33-1448"><a href="#cb33-1448"></a></span>
<span id="cb33-1449"><a href="#cb33-1449"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">blocksize</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb33-1450"><a href="#cb33-1450"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb33-1451"><a href="#cb33-1451"></a>    s <span class="op">=</span> <span class="fu">unwrap</span>(s)</span>
<span id="cb33-1452"><a href="#cb33-1452"></a>    <span class="fu">_blocksize</span>(s, <span class="fu">BlockSizeAPI</span>(s))</span>
<span id="cb33-1453"><a href="#cb33-1453"></a><span class="kw">end</span></span>
<span id="cb33-1454"><a href="#cb33-1454"></a></span>
<span id="cb33-1455"><a href="#cb33-1455"></a><span class="kw">function</span> _blocksize <span class="kw">end</span></span></code></pre></div>
<h1 id="transfer-size-trait">Transfer Size Trait</h1>
<div class="sourceCode" id="cb34" data-startFrom="1461"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1460;"><span id="cb34-1461"><a href="#cb34-1461"></a><span class="kw">struct</span> TransferSize{T} <span class="kw">end</span></span>
<span id="cb34-1462"><a href="#cb34-1462"></a><span class="kw">const</span> AnyTransferSize <span class="op">=</span> TransferSize</span></code></pre></div>
<p>The <code>TransferSize</code> trait describes how much data can be
moved in a single transfer.</p>
<p><code>TransferSize(stream)</code> returns
<code>TransferSize{T}</code> where <code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Transfer Size</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:Unlimited</code></td>
<td style="text-align: left;">No known transfer size limit.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Limited</code></td>
<td style="text-align: left;">The amount of data that can be moved in a
single transfer is limited. e.g. by a device block size or buffer size.
The maximum transfer size can queried using the
<code>max_transfer_size</code> function.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Fixed</code></td>
<td style="text-align: left;">The amount of data moved by a single
transfer is fixed. e.g. <code>/dev/input/event0</code> device always
transfers <code>sizeof(input_event)</code> bytes.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb35" data-startFrom="1485"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1484;"><span id="cb35-1485"><a href="#cb35-1485"></a><span class="fu">TransferSize</span>(s) <span class="op">=</span> <span class="fu">TransferSize</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb35-1486"><a href="#cb35-1486"></a><span class="fu">TransferSize</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferSize</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb35-1487"><a href="#cb35-1487"></a>                                      <span class="fu">TransferSize</span><span class="dt">{:Unlimited}</span>()</span>
<span id="cb35-1488"><a href="#cb35-1488"></a></span>
<span id="cb35-1489"><a href="#cb35-1489"></a><span class="fu">max_transfer_size</span>(s) <span class="op">=</span> <span class="fu">max_transfer_size</span>(s, <span class="fu">TransferSize</span>(s), <span class="fu">TotalSize</span>(s))</span>
<span id="cb35-1490"><a href="#cb35-1490"></a><span class="fu">max_transfer_size</span>(s, <span class="op">::</span><span class="dt">AnyTransferSize</span>, <span class="op">::</span><span class="dt">AnyTotalSize</span>) <span class="op">=</span> <span class="fu">typemax</span>(<span class="dt">UInt</span>)</span>
<span id="cb35-1491"><a href="#cb35-1491"></a><span class="fu">max_transfer_size</span>(s, <span class="op">::</span><span class="dt">TransferSize{:Unlimited}</span>, <span class="op">::</span><span class="dt">KnownTotalSize</span>) <span class="op">=</span> <span class="fu">length</span>(s)</span>
<span id="cb35-1492"><a href="#cb35-1492"></a><span class="fu">max_transfer_size</span>(s, <span class="op">::</span><span class="dt">TransferSize{:Limited}</span>, <span class="op">::</span><span class="dt">AnyTotalSize</span>) <span class="op">=</span> </span>
<span id="cb35-1493"><a href="#cb35-1493"></a>    <span class="fu">max_transfer_size</span>(s, <span class="fu">MaxReadAPI</span>(s))</span>
<span id="cb35-1494"><a href="#cb35-1494"></a></span>
<span id="cb35-1495"><a href="#cb35-1495"></a></span>
<span id="cb35-1496"><a href="#cb35-1496"></a><span class="kw">struct</span> ReadSizeAPI{T} <span class="kw">end</span></span></code></pre></div>
<p><code>ReadSizeAPI(stream)</code> returns <code>ReadSizeAPI{T}</code>
where <code>T</code> is one of:</p>
<p>FIXME look at <code>F_GETPIPE_SZ</code> and <code>SO_RCVBUF</code>,
<code>SO_SNDBUF</code></p>
<ul>
<li><code>:FIONREAD</code> – The underlying device supports
<code>ioctl(2), FIONREAD</code>.</li>
<li><code>:FStat</code> – The underlying device supports
<code>fstat(2), st_size</code>.</li>
</ul>
<div class="sourceCode" id="cb36" data-startFrom="1506"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1505;"><span id="cb36-1506"><a href="#cb36-1506"></a><span class="fu">ReadSizeAPI</span>(s) <span class="op">=</span> <span class="fu">ReadSizeAPI</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb36-1507"><a href="#cb36-1507"></a><span class="fu">ReadSizeAPI</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">ReadSizeAPI</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb36-1508"><a href="#cb36-1508"></a>                                     ReadSizeAPI{<span class="dt">Missing</span>}</span>
<span id="cb36-1509"><a href="#cb36-1509"></a></span>
<span id="cb36-1510"><a href="#cb36-1510"></a><span class="kw">struct</span> MaxReadAPI{T} <span class="kw">end</span></span>
<span id="cb36-1511"><a href="#cb36-1511"></a></span>
<span id="cb36-1512"><a href="#cb36-1512"></a><span class="fu">MaxReadAPI</span>(s) <span class="op">=</span> <span class="fu">MaxReadAPI</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb36-1513"><a href="#cb36-1513"></a><span class="fu">MaxReadAPI</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">MaxReadAPI</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb36-1514"><a href="#cb36-1514"></a>                                    MaxReadAPI{<span class="dt">Missing</span>}</span></code></pre></div>
<h1 id="data-availability-trait">Data Availability Trait</h1>
<div class="sourceCode" id="cb37" data-startFrom="1519"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1518;"><span id="cb37-1519"><a href="#cb37-1519"></a><span class="kw">struct</span> Availability{T} <span class="kw">end</span></span>
<span id="cb37-1520"><a href="#cb37-1520"></a><span class="kw">const</span> AnyAvailability <span class="op">=</span> Availability</span></code></pre></div>
<p>The <code>Availability</code> trait describes when data is available
from a stream.</p>
<p><code>Availability(stream)</code> returns
<code>Availabilty{T}()</code> where <code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Availability</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:Always</code></td>
<td style="text-align: left;">Data is always immediately available.
i.e. <code>bytesavailable</code> === <code>bytesremaining</code>.
Applicable to some device files (dev/event, /dev/zero). Applicable to
local disk files.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Partial</code></td>
<td style="text-align: left;">Some data may be immediately available
from a buffer, but <code>bytesavailable</code> can be less than
<code>bytesremaining</code>. <code>bytesavailable</code> may be 0
(e.g. when a buffer is empty) even if a subsequent transfer would yeild
more data.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Unknown</code></td>
<td style="text-align: left;">There is no mechanism for determining data
availability. The only way to know how much data is available is to
attempt a transfer. i.e. <code>bytesavailable</code> is always 0.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb38" data-startFrom="1547"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1546;"><span id="cb38-1547"><a href="#cb38-1547"></a><span class="fu">Availability</span>(x) <span class="op">=</span> <span class="fu">Availability</span>(<span class="fu">typeof</span>(x))</span>
<span id="cb38-1548"><a href="#cb38-1548"></a><span class="fu">Availability</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">Availability</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb38-1549"><a href="#cb38-1549"></a>                                      <span class="fu">Availability</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb38-1550"><a href="#cb38-1550"></a></span>
<span id="cb38-1551"><a href="#cb38-1551"></a><span class="fu">availability_is_unknown</span>(x) <span class="op">=</span> <span class="fu">Availability</span>(x) <span class="op">==</span> <span class="fu">Availability</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb38-1552"><a href="#cb38-1552"></a><span class="fu">availability_is_known</span>(x) <span class="op">=</span> !<span class="fu">availability_is_unknown</span>(x)</span>
<span id="cb38-1553"><a href="#cb38-1553"></a></span>
<span id="cb38-1554"><a href="#cb38-1554"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">Availability{:Unknown}</span>, <span class="op">::</span><span class="dt">AnyTransferSize</span>)</span>
<span id="cb38-1555"><a href="#cb38-1555"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb38-1556"><a href="#cb38-1556"></a>    <span class="cn">missing</span></span>
<span id="cb38-1557"><a href="#cb38-1557"></a><span class="kw">end</span></span>
<span id="cb38-1558"><a href="#cb38-1558"></a></span>
<span id="cb38-1559"><a href="#cb38-1559"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">Availability{:Always}</span>, <span class="op">::</span><span class="dt">TransferSize{:Unlimited}</span>)</span>
<span id="cb38-1560"><a href="#cb38-1560"></a>    <span class="fu">bytesremaining</span>(s)</span>
<span id="cb38-1561"><a href="#cb38-1561"></a><span class="kw">end</span></span>
<span id="cb38-1562"><a href="#cb38-1562"></a></span>
<span id="cb38-1563"><a href="#cb38-1563"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">Availability{:Always}</span>, <span class="op">::</span><span class="dt">TransferSize{:Fixed}</span>)</span>
<span id="cb38-1564"><a href="#cb38-1564"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb38-1565"><a href="#cb38-1565"></a>    <span class="fu">max_transfer_size</span>(s)</span>
<span id="cb38-1566"><a href="#cb38-1566"></a><span class="kw">end</span></span>
<span id="cb38-1567"><a href="#cb38-1567"></a></span>
<span id="cb38-1568"><a href="#cb38-1568"></a></span>
<span id="cb38-1569"><a href="#cb38-1569"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_bytesavailable</span>(s, <span class="op">::</span><span class="dt">Availability{:Partial}</span>, <span class="op">::</span><span class="dt">AnyTransferSize</span>)</span>
<span id="cb38-1570"><a href="#cb38-1570"></a>    <span class="fu">_bytesavailable</span>(s, <span class="fu">ReadSizeAPI</span>(s))</span>
<span id="cb38-1571"><a href="#cb38-1571"></a><span class="kw">end</span></span>
<span id="cb38-1572"><a href="#cb38-1572"></a></span>
<span id="cb38-1573"><a href="#cb38-1573"></a></span>
<span id="cb38-1574"><a href="#cb38-1574"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">wait_for_n_bytes</span>(s, n; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb38-1575"><a href="#cb38-1575"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb38-1576"><a href="#cb38-1576"></a>    <span class="pp">@require</span> <span class="fu">availability_is_known</span>(s)</span>
<span id="cb38-1577"><a href="#cb38-1577"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&gt;=</span> n</span>
<span id="cb38-1578"><a href="#cb38-1578"></a>        <span class="pp">@db</span> <span class="cf">return</span></span>
<span id="cb38-1579"><a href="#cb38-1579"></a>    <span class="cf">end</span></span>
<span id="cb38-1580"><a href="#cb38-1580"></a></span>
<span id="cb38-1581"><a href="#cb38-1581"></a>    <span class="cf">while</span> <span class="fu">time</span>() <span class="op">&lt;</span> deadline</span>
<span id="cb38-1582"><a href="#cb38-1582"></a>        <span class="fu">pump!</span>(s; deadline)</span>
<span id="cb38-1583"><a href="#cb38-1583"></a>        <span class="pp">@dblock</span> s <span class="cf">begin</span></span>
<span id="cb38-1584"><a href="#cb38-1584"></a>            <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&gt;=</span> n</span>
<span id="cb38-1585"><a href="#cb38-1585"></a>                <span class="pp">@db</span> <span class="cf">return</span></span>
<span id="cb38-1586"><a href="#cb38-1586"></a>            <span class="cf">end</span></span>
<span id="cb38-1587"><a href="#cb38-1587"></a>            <span class="fu">wait</span>(s; deadline)</span>
<span id="cb38-1588"><a href="#cb38-1588"></a>        <span class="cf">end</span></span>
<span id="cb38-1589"><a href="#cb38-1589"></a>    <span class="cf">end</span></span>
<span id="cb38-1590"><a href="#cb38-1590"></a>    <span class="cn">nothing</span></span>
<span id="cb38-1591"><a href="#cb38-1591"></a><span class="kw">end</span></span>
<span id="cb38-1592"><a href="#cb38-1592"></a></span>
<span id="cb38-1593"><a href="#cb38-1593"></a></span>
<span id="cb38-1594"><a href="#cb38-1594"></a><span class="fu">wait_for_n_bytes</span>(a<span class="op">...</span>; timeout) <span class="op">=</span></span>
<span id="cb38-1595"><a href="#cb38-1595"></a>    <span class="fu">wait_for_n_bytes</span>(a<span class="op">...</span>; deadline <span class="op">=</span> <span class="fu">time</span>() <span class="op">+</span> timeout)</span></code></pre></div>
<h1 id="transfer-function-dispatch">Transfer Function Dispatch</h1>
<pre><code>attempt_transfer(stream, buffer, (stream_i, buffer_i, n))</code></pre>
<p>Transfer at most <code>n</code> items between <code>stream</code> and
<code>buffer</code>. Return the number of items transferred.</p>
<div class="sourceCode" id="cb40" data-startFrom="1606"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1605;"><span id="cb40-1606"><a href="#cb40-1606"></a><span class="kw">function</span> attempt_transfer <span class="kw">end</span></span></code></pre></div>
<h2
id="application-of-the-direction-and-buffer-interface-traits">Application
of the Direction and Buffer Interface Traits</h2>
<p>Next, the <code>BufferInterface</code> trait is inserted into the
argument list.<span
class="sidenote-wrapper"><label for="sn-21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-21" class="margin-toggle"/><span
class="sidenote">Note that premature specialisation on direction is
avoided. Eventually most transfers will end up calling an OS
<code>read</code> or <code>write</code> function. However, much of the
transfer logic is the same irrespective of direction. For example, the
methods for <code>UsingPtr</code> and <code>UsingIndex</code> below work
for both input and output. (Another consideration is supporting
interfaces with <code>TransferDirection</code>
<code>Exchange</code>).<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb41" data-startFrom="1620"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1619;"><span id="cb41-1620"><a href="#cb41-1620"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="kw">function</span> <span class="fu">attempt_transfer</span>(stream, buf, indices)</span>
<span id="cb41-1621"><a href="#cb41-1621"></a>    buf_api <span class="op">=</span> <span class="fu">is_input</span>(stream)  ? <span class="fu">ToBufferInterface</span>(buf) <span class="op">:</span></span>
<span id="cb41-1622"><a href="#cb41-1622"></a>              <span class="fu">is_output</span>(stream) ? <span class="fu">FromBufferInterface</span>(buf) <span class="op">:</span></span>
<span id="cb41-1623"><a href="#cb41-1623"></a>                                  <span class="fu">ExchangeBufferInterface</span>(buf)</span>
<span id="cb41-1624"><a href="#cb41-1624"></a>    <span class="fu">_attempt_transfer</span>(stream, buf, buf_api, indices<span class="op">...</span>)</span>
<span id="cb41-1625"><a href="#cb41-1625"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="low-level-byte-stream-methods">Low Level Byte-Stream
Methods</h2>
<p>The specialised methods for various Buffer Interfaces eventually call
this this IsBytePtr method, which in turn calls the low level
<code>unsafe_transfer!</code> implementation methods.</p>
<div class="sourceCode" id="cb42" data-startFrom="1636"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1635;"><span id="cb42-1636"><a href="#cb42-1636"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream,</span>
<span id="cb42-1637"><a href="#cb42-1637"></a>                                         buffer<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, <span class="op">::</span><span class="dt">IsBytePtr</span>,</span>
<span id="cb42-1638"><a href="#cb42-1638"></a>                                         stream_i, buffer_i, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb42-1639"><a href="#cb42-1639"></a>    <span class="pp">@ensure</span> <span class="fu">ismissing</span>(stream_i) <span class="op">||</span> stream_i <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb42-1640"><a href="#cb42-1640"></a>    <span class="cf">if</span> !<span class="fu">ismissing</span>(buffer_i)</span>
<span id="cb42-1641"><a href="#cb42-1641"></a>        buffer <span class="op">+=</span> (buffer_i<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb42-1642"><a href="#cb42-1642"></a>    <span class="cf">end</span></span>
<span id="cb42-1643"><a href="#cb42-1643"></a>    r <span class="op">=</span> <span class="fu">unsafe_transfer!</span>(stream, buffer, stream_i<span class="op">-</span><span class="fl">1</span>, n)</span>
<span id="cb42-1644"><a href="#cb42-1644"></a>    <span class="pp">@ensure</span> r isa <span class="dt">UInt</span></span>
<span id="cb42-1645"><a href="#cb42-1645"></a>    <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> r</span>
<span id="cb42-1646"><a href="#cb42-1646"></a><span class="kw">end</span></span></code></pre></div>
<p>This method handles items larger than one byte. It returns zero if
there are not enough bytes available for a whole item. For streams with
Unknown Transfer Size the requested transfer is attempted but an error
is thrown if a partial item is transferred.</p>
<div class="sourceCode" id="cb43" data-startFrom="1655"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1654;"><span id="cb43-1655"><a href="#cb43-1655"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream,</span>
<span id="cb43-1656"><a href="#cb43-1656"></a>                                 buf, <span class="op">::</span><span class="dt">IsItemPtr</span>,</span>
<span id="cb43-1657"><a href="#cb43-1657"></a>                                 stream_i, buffer_i<span class="op">::</span><span class="dt">UInt</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb43-1658"><a href="#cb43-1658"></a>    sz <span class="op">=</span> <span class="fu">ioelsize</span>(buf)</span>
<span id="cb43-1659"><a href="#cb43-1659"></a>    <span class="pp">@assert</span> sz <span class="op">&gt;</span> <span class="fl">1</span></span>
<span id="cb43-1660"><a href="#cb43-1660"></a>    <span class="cf">if</span> <span class="fu">Availability</span>(stream) <span class="op">!=</span> <span class="fu">Availability</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb43-1661"><a href="#cb43-1661"></a>        n<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fu">min</span>(n, <span class="fu">bytesavailable</span>(stream) <span class="op">÷</span> sz)</span>
<span id="cb43-1662"><a href="#cb43-1662"></a>        n <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">||</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> <span class="fu">UInt</span>(<span class="fl">0</span>)</span>
<span id="cb43-1663"><a href="#cb43-1663"></a>    <span class="cf">end</span></span>
<span id="cb43-1664"><a href="#cb43-1664"></a></span>
<span id="cb43-1665"><a href="#cb43-1665"></a>    buf <span class="op">=</span> <span class="fu">Ptr</span><span class="dt">{UInt8}</span>(buf)</span>
<span id="cb43-1666"><a href="#cb43-1666"></a>    buffer_i <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> ((buffer_i<span class="op">-</span><span class="fl">1</span>) <span class="op">*</span> sz)</span>
<span id="cb43-1667"><a href="#cb43-1667"></a></span>
<span id="cb43-1668"><a href="#cb43-1668"></a>    r <span class="op">=</span> <span class="fu">_attempt_transfer</span>(stream, buf, <span class="fu">IsBytePtr</span>(),</span>
<span id="cb43-1669"><a href="#cb43-1669"></a>                          stream_i, buffer_i, n <span class="op">*</span> sz)</span>
<span id="cb43-1670"><a href="#cb43-1670"></a>    <span class="pp">@ensure</span> r isa <span class="dt">UInt</span></span>
<span id="cb43-1671"><a href="#cb43-1671"></a>    stream_i <span class="op">+=</span> r</span>
<span id="cb43-1672"><a href="#cb43-1672"></a></span>
<span id="cb43-1673"><a href="#cb43-1673"></a>    <span class="cf">if</span> r <span class="op">%</span> sz <span class="op">!=</span> <span class="fl">0</span></span>
<span id="cb43-1674"><a href="#cb43-1674"></a>        <span class="pp">@assert</span> <span class="fu">Availability</span>(stream) <span class="op">==</span> <span class="fu">Availability</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb43-1675"><a href="#cb43-1675"></a>        r <span class="op">+=</span> <span class="fu">transferall!</span>(stream, buf <span class="op">+</span> (buffer_i<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> r, r <span class="op">%</span> sz; stream_i)</span>
<span id="cb43-1676"><a href="#cb43-1676"></a>    <span class="cf">end</span></span>
<span id="cb43-1677"><a href="#cb43-1677"></a>    <span class="cf">if</span> r <span class="op">%</span> sz <span class="op">!=</span> <span class="fl">0</span></span>
<span id="cb43-1678"><a href="#cb43-1678"></a>        <span class="fu">throw</span>(<span class="fu">IOTraitsError</span>(stream,</span>
<span id="cb43-1679"><a href="#cb43-1679"></a>              <span class="st">&quot;Partial Transfer Error: &quot;</span> <span class="op">*</span></span>
<span id="cb43-1680"><a href="#cb43-1680"></a>              <span class="st">&quot;Transfer </span><span class="sc">$</span>(<span class="fu">verb</span>(direction))<span class="st"> </span><span class="sc">$</span>stream<span class="st"> returned </span><span class="sc">$</span>r<span class="st"> bytes &quot;</span> <span class="op">*</span></span>
<span id="cb43-1681"><a href="#cb43-1681"></a>              <span class="st">&quot;but </span><span class="sc">$</span>(<span class="fu">typeof</span>(buf))<span class="st"> has </span><span class="sc">$</span>sz<span class="st">-byte elements &quot;</span> <span class="op">*</span></span>
<span id="cb43-1682"><a href="#cb43-1682"></a>              <span class="st">&quot;(</span><span class="sc">$</span>r<span class="st"> % </span><span class="sc">$</span>sz<span class="st"> = </span><span class="sc">$</span>(r <span class="op">%</span> sz)<span class="st">).</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">*</span></span>
<span id="cb43-1683"><a href="#cb43-1683"></a>              <span class="st">&quot;Consider using BufferedInput(stream) to ensure that &quot;</span> <span class="op">*</span></span>
<span id="cb43-1684"><a href="#cb43-1684"></a>              <span class="st">&quot;`Availability(stream) != Availability{:Unknown}`.&quot;</span>))</span>
<span id="cb43-1685"><a href="#cb43-1685"></a>    <span class="cf">end</span></span>
<span id="cb43-1686"><a href="#cb43-1686"></a>    r <span class="op">÷=</span> sz</span>
<span id="cb43-1687"><a href="#cb43-1687"></a>    <span class="pp">@ensure</span> r <span class="op">&lt;=</span> n</span>
<span id="cb43-1688"><a href="#cb43-1688"></a>    <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> r</span>
<span id="cb43-1689"><a href="#cb43-1689"></a><span class="kw">end</span></span></code></pre></div>
<p>At least one of the following <code>unsafe_transfer!</code> methods
must be implemented for each type
<code>T &lt;: IOTraits.Stream</code>:</p>
<pre><code>unsafe_transfer!(s::T, ::IOTraits.In,           buffer::Ptr{UInt8}, n::UInt)
unsafe_transfer!(s::T, ::IOTraits.Out,          buffer::Ptr{UInt8}, n::UInt)
unsafe_transfer!(s::T, ::IOTraits.Exchange,     buffer::Ptr{UInt8}, n::UInt)
unsafe_transfer!(s::T, ::IOTraits.AnyDirection, buffer::Ptr{UInt8}, n::UInt)</code></pre>
<p><code>unsafe_transfer!</code> should transfer at most <code>n</code>
bytes between <code>stream</code> and <code>buffer</code> and return the
number of items transferred (or zero if no bytes are immediately
available)<span
class="sidenote-wrapper"><label for="sn-22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-22" class="margin-toggle"/><span
class="sidenote">⚠️ Note that the <code>BaseIOStream</code> methods
defined here do not properly implement the specification because
<code>unsafe_read</code> and <code>unsafe_write</code> may block to wait
for data. These methods are intended for testing purposes only. The
transfer timeout feature will not work properly for
<code>BaseIOStream</code>.<br />
<br />
</span></span>.</p>
<div class="sourceCode" id="cb45" data-startFrom="1711"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1710;"><span id="cb45-1711"><a href="#cb45-1711"></a><span class="kw">function</span> unsafe_transfer! <span class="kw">end</span></span>
<span id="cb45-1712"><a href="#cb45-1712"></a></span>
<span id="cb45-1713"><a href="#cb45-1713"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="kw">function</span> <span class="fu">unsafe_transfer!</span>(s<span class="op">::</span><span class="dt">BaseIOStream</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>,</span>
<span id="cb45-1714"><a href="#cb45-1714"></a>                                      stream_offset<span class="op">::</span><span class="dt">Missing</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb45-1715"><a href="#cb45-1715"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb45-1716"><a href="#cb45-1716"></a>    <span class="fu">is_input</span>(s) ? <span class="fu">UInt</span>(<span class="fu">unsafe_read</span>(s.io, buf, n)) <span class="op">:</span></span>
<span id="cb45-1717"><a href="#cb45-1717"></a>                  <span class="fu">UInt</span>(<span class="fu">unsafe_write</span>(s.io, buf, n))</span>
<span id="cb45-1718"><a href="#cb45-1718"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="transfer-specialisations-for-indexable-buffers">Transfer
Specialisations for Indexable Buffers</h2>
<p>If <code>n</code> is missing, use the whole length of the buffer.</p>
<p>After this both <code>buffer_i</code> and <code>n</code> are always
<code>UInt</code>s.</p>
<div class="sourceCode" id="cb46" data-startFrom="1728"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1727;"><span id="cb46-1728"><a href="#cb46-1728"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buf,</span>
<span id="cb46-1729"><a href="#cb46-1729"></a>                                         interface<span class="op">::</span><span class="dt">Union{UsingPtr, UsingIndex}</span>,</span>
<span id="cb46-1730"><a href="#cb46-1730"></a>                                         stream_i, buffer_i, n<span class="op">::</span><span class="dt">Missing</span>)</span>
<span id="cb46-1731"><a href="#cb46-1731"></a>    <span class="pp">@require</span> <span class="fu">length</span>(buf) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb46-1732"><a href="#cb46-1732"></a>    <span class="pp">@require</span> <span class="fu">ismissing</span>(buffer_i) <span class="op">||</span> buffer_i <span class="op">&lt;</span> <span class="fu">length</span>(buf)</span>
<span id="cb46-1733"><a href="#cb46-1733"></a>    n <span class="op">=</span> <span class="fu">length</span>(buf)</span>
<span id="cb46-1734"><a href="#cb46-1734"></a>    <span class="cf">if</span> !<span class="fu">ismissing</span>(buffer_i)</span>
<span id="cb46-1735"><a href="#cb46-1735"></a>        n <span class="op">-=</span> (buffer_i <span class="op">-</span> <span class="fl">1</span>)</span>
<span id="cb46-1736"><a href="#cb46-1736"></a>    <span class="cf">end</span></span>
<span id="cb46-1737"><a href="#cb46-1737"></a>    <span class="fu">_attempt_transfer</span>(stream, buf, interface, stream_i, buffer_i, <span class="fu">UInt</span>(n))</span>
<span id="cb46-1738"><a href="#cb46-1738"></a><span class="kw">end</span></span>
<span id="cb46-1739"><a href="#cb46-1739"></a></span>
<span id="cb46-1740"><a href="#cb46-1740"></a></span>
<span id="cb46-1741"><a href="#cb46-1741"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buffer, interface<span class="op">::</span><span class="dt">FromString</span>,</span>
<span id="cb46-1742"><a href="#cb46-1742"></a>                                         stream_i, buffer_i, n<span class="op">::</span><span class="dt">Missing</span>)</span>
<span id="cb46-1743"><a href="#cb46-1743"></a>    n <span class="op">=</span> <span class="fu">ncodeunits</span>(buffer)</span>
<span id="cb46-1744"><a href="#cb46-1744"></a>    <span class="cf">if</span> !<span class="fu">ismissing</span>(buffer_i)</span>
<span id="cb46-1745"><a href="#cb46-1745"></a>        n <span class="op">-=</span> (buffer_i <span class="op">-</span> <span class="fl">1</span>)</span>
<span id="cb46-1746"><a href="#cb46-1746"></a>    <span class="cf">end</span></span>
<span id="cb46-1747"><a href="#cb46-1747"></a>    <span class="fu">_attempt_transfer</span>(stream, buffer, interface, stream_i, buffer_i, <span class="fu">UInt</span>(n))</span>
<span id="cb46-1748"><a href="#cb46-1748"></a><span class="kw">end</span></span>
<span id="cb46-1749"><a href="#cb46-1749"></a></span>
<span id="cb46-1750"><a href="#cb46-1750"></a></span>
<span id="cb46-1751"><a href="#cb46-1751"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buffer, <span class="op">::</span><span class="dt">FromString</span>,</span>
<span id="cb46-1752"><a href="#cb46-1752"></a>                                         stream_i, buffer_i, n)</span>
<span id="cb46-1753"><a href="#cb46-1753"></a>    <span class="cf">if</span> <span class="fu">ismissing</span>(buffer_i)</span>
<span id="cb46-1754"><a href="#cb46-1754"></a>        buffer_i <span class="op">=</span> <span class="fu">UInt</span>(<span class="fl">1</span>)</span>
<span id="cb46-1755"><a href="#cb46-1755"></a>    <span class="cf">end</span></span>
<span id="cb46-1756"><a href="#cb46-1756"></a>    <span class="pp">@require</span> (buffer_i<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> n <span class="op">&lt;=</span> <span class="fu">ncodeunits</span>(buffer)</span>
<span id="cb46-1757"><a href="#cb46-1757"></a>    <span class="fu">_attempt_transfer</span>(stream, <span class="fu">pointer</span>(buffer), <span class="fu">IsBytePtr</span>(),</span>
<span id="cb46-1758"><a href="#cb46-1758"></a>                      stream_i, buffer_i, n)</span>
<span id="cb46-1759"><a href="#cb46-1759"></a><span class="kw">end</span></span>
<span id="cb46-1760"><a href="#cb46-1760"></a></span>
<span id="cb46-1761"><a href="#cb46-1761"></a></span>
<span id="cb46-1762"><a href="#cb46-1762"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buf,</span>
<span id="cb46-1763"><a href="#cb46-1763"></a>                                         interface,</span>
<span id="cb46-1764"><a href="#cb46-1764"></a>                                         stream_i, buffer_i, n<span class="op">::</span><span class="dt">Missing</span>)</span>
<span id="cb46-1765"><a href="#cb46-1765"></a>    <span class="fu">_attempt_transfer</span>(stream, buf, interface, stream_i, buffer_i, <span class="fu">typemax</span>(<span class="dt">UInt</span>))</span>
<span id="cb46-1766"><a href="#cb46-1766"></a><span class="kw">end</span></span></code></pre></div>
<p>If the buffer is pointer-compatible convert it to a pointer.</p>
<div class="sourceCode" id="cb47" data-startFrom="1772"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1771;"><span id="cb47-1772"><a href="#cb47-1772"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buf, <span class="op">::</span><span class="dt">UsingPtr</span>,</span>
<span id="cb47-1773"><a href="#cb47-1773"></a>                                         stream_i, buffer_i, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb47-1774"><a href="#cb47-1774"></a>    <span class="cf">if</span> <span class="fu">ismissing</span>(buffer_i)</span>
<span id="cb47-1775"><a href="#cb47-1775"></a>        buffer_i <span class="op">=</span> <span class="fu">UInt</span>(<span class="fl">1</span>)</span>
<span id="cb47-1776"><a href="#cb47-1776"></a>    <span class="cf">end</span></span>
<span id="cb47-1777"><a href="#cb47-1777"></a>    <span class="fu">checkbounds</span>(buf, (buffer_i<span class="op">-</span><span class="fl">1</span>) <span class="op">+</span> n)</span>
<span id="cb47-1778"><a href="#cb47-1778"></a>    GC.<span class="pp">@preserve</span> buf <span class="fu">attempt_transfer</span>(stream, <span class="fu">pointer</span>(buf, buffer_i),</span>
<span id="cb47-1779"><a href="#cb47-1779"></a>                                      (stream_i, <span class="fu">UInt</span>(<span class="fl">1</span>), n))</span>
<span id="cb47-1780"><a href="#cb47-1780"></a><span class="kw">end</span></span>
<span id="cb47-1781"><a href="#cb47-1781"></a></span>
<span id="cb47-1782"><a href="#cb47-1782"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buf<span class="op">::</span><span class="dt">Ref</span>, <span class="op">::</span><span class="dt">UsingPtr</span>,</span>
<span id="cb47-1783"><a href="#cb47-1783"></a>                                         stream_i, buffer_i<span class="op">::</span><span class="dt">Missing</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb47-1784"><a href="#cb47-1784"></a>    p <span class="op">=</span> <span class="bu">Base</span>.<span class="fu">unsafe_convert</span>(<span class="dt">Ptr</span>{<span class="fu">eltype</span>(buf)}, buf)</span>
<span id="cb47-1785"><a href="#cb47-1785"></a>    GC.<span class="pp">@preserve</span> buf <span class="fu">attempt_transfer</span>(stream, p, (stream_i, <span class="fu">UInt</span>(<span class="fl">1</span>), n))</span>
<span id="cb47-1786"><a href="#cb47-1786"></a><span class="kw">end</span></span></code></pre></div>
<p>If the buffer is not pointer-compatible, transfer one item at a
time.</p>
<div class="sourceCode" id="cb48" data-startFrom="1792"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1791;"><span id="cb48-1792"><a href="#cb48-1792"></a><span class="pp">@inline</span> <span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buf, <span class="op">::</span><span class="dt">UsingIndex</span>,</span>
<span id="cb48-1793"><a href="#cb48-1793"></a>                                         stream_i, buffer_i, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb48-1794"><a href="#cb48-1794"></a>    <span class="cf">if</span> <span class="fu">ismissing</span>(buffer_i)</span>
<span id="cb48-1795"><a href="#cb48-1795"></a>        buffer_i <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb48-1796"><a href="#cb48-1796"></a>    <span class="cf">end</span></span>
<span id="cb48-1797"><a href="#cb48-1797"></a>    T <span class="op">=</span> <span class="fu">ioeltype</span>(buf)</span>
<span id="cb48-1798"><a href="#cb48-1798"></a>    <span class="co">#sz = ioelsize(buf)</span></span>
<span id="cb48-1799"><a href="#cb48-1799"></a>    x <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{T}</span>(<span class="cn">undef</span>, <span class="fl">1</span>)</span>
<span id="cb48-1800"><a href="#cb48-1800"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb48-1801"><a href="#cb48-1801"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">eachindex</span>(<span class="fu">view</span>(buf, buffer_i<span class="op">:</span>(buffer_i<span class="op">-</span><span class="fl">1</span>)<span class="op">+</span>n))</span>
<span id="cb48-1802"><a href="#cb48-1802"></a>        <span class="cf">if</span> <span class="fu">is_output</span>(stream)</span>
<span id="cb48-1803"><a href="#cb48-1803"></a>            x[<span class="fl">1</span>] <span class="op">=</span> buf[i]</span>
<span id="cb48-1804"><a href="#cb48-1804"></a>        <span class="cf">end</span></span>
<span id="cb48-1805"><a href="#cb48-1805"></a>        r <span class="op">=</span> <span class="fu">transfer!</span>(stream, x; deadline<span class="op">=</span><span class="fl">0</span>, stream_i)</span>
<span id="cb48-1806"><a href="#cb48-1806"></a>        stream_i <span class="op">+=</span> r <span class="op">*</span> <span class="fu">sizeof</span>(x[<span class="fl">1</span>])</span>
<span id="cb48-1807"><a href="#cb48-1807"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb48-1808"><a href="#cb48-1808"></a>            <span class="pp">@db_not_tested</span></span>
<span id="cb48-1809"><a href="#cb48-1809"></a>            <span class="cf">break</span></span>
<span id="cb48-1810"><a href="#cb48-1810"></a>        <span class="cf">end</span></span>
<span id="cb48-1811"><a href="#cb48-1811"></a>        <span class="cf">if</span> <span class="fu">is_input</span>(stream)</span>
<span id="cb48-1812"><a href="#cb48-1812"></a>            buf[i] <span class="op">=</span> x[<span class="fl">1</span>]</span>
<span id="cb48-1813"><a href="#cb48-1813"></a>        <span class="cf">end</span></span>
<span id="cb48-1814"><a href="#cb48-1814"></a>        count <span class="op">+=</span> r</span>
<span id="cb48-1815"><a href="#cb48-1815"></a>    <span class="cf">end</span></span>
<span id="cb48-1816"><a href="#cb48-1816"></a>    <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> count</span>
<span id="cb48-1817"><a href="#cb48-1817"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="transfer-specialisations-for-iterable-buffers">Transfer
Specialisations for Iterable Buffers</h2>
<p>Iterate over <code>buf</code> (skip items until <code>buffer_i</code>
index is reached). Transfer each item one at a time.</p>
<div class="sourceCode" id="cb49" data-startFrom="1826"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1825;"><span id="cb49-1826"><a href="#cb49-1826"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(stream, buf, <span class="op">::</span><span class="dt">FromIteration</span>,</span>
<span id="cb49-1827"><a href="#cb49-1827"></a>                                 stream_i, buffer_i, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb49-1828"><a href="#cb49-1828"></a>    <span class="pp">@require</span> <span class="fu">is_output</span>(stream)</span>
<span id="cb49-1829"><a href="#cb49-1829"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb49-1830"><a href="#cb49-1830"></a>    T <span class="op">=</span> <span class="fu">ioeltype</span>(buf)</span>
<span id="cb49-1831"><a href="#cb49-1831"></a>    <span class="cf">if</span> T <span class="op">&lt;:</span><span class="dt"> Union{Vector{UInt8}, AbstractString}</span></span>
<span id="cb49-1832"><a href="#cb49-1832"></a>        <span class="pp">@require</span> <span class="fu">ismissing</span>(stream_i)</span>
<span id="cb49-1833"><a href="#cb49-1833"></a>        <span class="cf">for</span> x <span class="kw">in</span> buf</span>
<span id="cb49-1834"><a href="#cb49-1834"></a>            sz <span class="op">=</span> x isa <span class="dt">AbstractString</span> ? <span class="fu">ncodeunits</span>(x) <span class="op">:</span> <span class="fu">length</span>(x)</span>
<span id="cb49-1835"><a href="#cb49-1835"></a>            r <span class="op">=</span> <span class="fu">transferall!</span>(stream, x, sz)</span>
<span id="cb49-1836"><a href="#cb49-1836"></a>            <span class="pp">@assert</span> r <span class="op">==</span> sz</span>
<span id="cb49-1837"><a href="#cb49-1837"></a>            count <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb49-1838"><a href="#cb49-1838"></a>            <span class="cf">if</span> count <span class="op">==</span> n</span>
<span id="cb49-1839"><a href="#cb49-1839"></a>                <span class="cf">break</span></span>
<span id="cb49-1840"><a href="#cb49-1840"></a>            <span class="cf">end</span></span>
<span id="cb49-1841"><a href="#cb49-1841"></a>        <span class="cf">end</span></span>
<span id="cb49-1842"><a href="#cb49-1842"></a>        <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> count</span>
<span id="cb49-1843"><a href="#cb49-1843"></a>    <span class="cf">end</span></span>
<span id="cb49-1844"><a href="#cb49-1844"></a>    <span class="cf">for</span> x <span class="kw">in</span> buf</span>
<span id="cb49-1845"><a href="#cb49-1845"></a>        <span class="cf">if</span> !<span class="fu">ismissing</span>(buffer_i) <span class="op">&amp;&amp;</span> buffer_i <span class="op">&gt;</span> <span class="fl">1</span></span>
<span id="cb49-1846"><a href="#cb49-1846"></a>            buffer_i <span class="op">-=</span> <span class="fl">1</span></span>
<span id="cb49-1847"><a href="#cb49-1847"></a>            <span class="pp">@db_not_tested</span></span>
<span id="cb49-1848"><a href="#cb49-1848"></a>            <span class="cf">continue</span></span>
<span id="cb49-1849"><a href="#cb49-1849"></a>        <span class="cf">end</span></span>
<span id="cb49-1850"><a href="#cb49-1850"></a>        r <span class="op">=</span> <span class="fu">transfer!</span>(stream, [x]; deadline<span class="op">=</span><span class="fl">0</span>, stream_i)</span>
<span id="cb49-1851"><a href="#cb49-1851"></a>        stream_i <span class="op">+=</span> r <span class="op">*</span> <span class="fu">sizeof</span>(x)</span>
<span id="cb49-1852"><a href="#cb49-1852"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb49-1853"><a href="#cb49-1853"></a>            <span class="pp">@db_not_tested</span></span>
<span id="cb49-1854"><a href="#cb49-1854"></a>            <span class="cf">break</span></span>
<span id="cb49-1855"><a href="#cb49-1855"></a>        <span class="cf">end</span></span>
<span id="cb49-1856"><a href="#cb49-1856"></a>        <span class="pp">@assert</span> r <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb49-1857"><a href="#cb49-1857"></a>        count <span class="op">+=</span> r</span>
<span id="cb49-1858"><a href="#cb49-1858"></a>        <span class="cf">if</span> count <span class="op">==</span> n</span>
<span id="cb49-1859"><a href="#cb49-1859"></a>            <span class="cf">break</span></span>
<span id="cb49-1860"><a href="#cb49-1860"></a>        <span class="cf">end</span></span>
<span id="cb49-1861"><a href="#cb49-1861"></a>    <span class="cf">end</span></span>
<span id="cb49-1862"><a href="#cb49-1862"></a>    <span class="cf">return</span> count</span>
<span id="cb49-1863"><a href="#cb49-1863"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="transfer-specialisations-for-collection-buffers">Transfer
Specialisations for Collection Buffers</h2>
<div class="sourceCode" id="cb50" data-startFrom="1869"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1868;"><span id="cb50-1869"><a href="#cb50-1869"></a><span class="cf">for</span> (T, f) <span class="kw">in</span> [ToPut <span class="op">=&gt;</span> put!,</span>
<span id="cb50-1870"><a href="#cb50-1870"></a>              ToPush <span class="op">=&gt;</span> push!,</span>
<span id="cb50-1871"><a href="#cb50-1871"></a>              ToRef <span class="op">=&gt;</span> setindex!]</span>
<span id="cb50-1872"><a href="#cb50-1872"></a>    <span class="fu">eval</span>(<span class="op">:</span>(<span class="fu">_attempt_transfer</span>(s, buf, <span class="op">::</span><span class="dt">$T</span>, si, bi, n<span class="op">::</span><span class="dt">UInt</span>) <span class="op">=</span></span>
<span id="cb50-1873"><a href="#cb50-1873"></a>           <span class="fu">_attempt_transfer_f</span>(s, buf, <span class="op">$</span>f, si, bi, n)))</span>
<span id="cb50-1874"><a href="#cb50-1874"></a><span class="cf">end</span></span>
<span id="cb50-1875"><a href="#cb50-1875"></a></span>
<span id="cb50-1876"><a href="#cb50-1876"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer_f</span>(stream, buf, f<span class="op">::</span><span class="dt">Function</span>,</span>
<span id="cb50-1877"><a href="#cb50-1877"></a>                                   stream_i, buffer_i<span class="op">::</span><span class="dt">Missing</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb50-1878"><a href="#cb50-1878"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(stream)</span>
<span id="cb50-1879"><a href="#cb50-1879"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb50-1880"><a href="#cb50-1880"></a>    T <span class="op">=</span> <span class="fu">ioeltype</span>(buf)</span>
<span id="cb50-1881"><a href="#cb50-1881"></a>    <span class="cf">if</span> T <span class="op">&lt;:</span><span class="dt"> Union{Vector{UInt8}, String}</span></span>
<span id="cb50-1882"><a href="#cb50-1882"></a>        <span class="pp">@require</span> <span class="fu">ismissing</span>(stream_i)</span>
<span id="cb50-1883"><a href="#cb50-1883"></a>        <span class="cf">while</span> count <span class="op">&lt;</span> n</span>
<span id="cb50-1884"><a href="#cb50-1884"></a>            <span class="cf">if</span> <span class="fu">is_input</span>(stream)</span>
<span id="cb50-1885"><a href="#cb50-1885"></a>                x <span class="op">=</span> <span class="fu">readavailable</span>(stream)</span>
<span id="cb50-1886"><a href="#cb50-1886"></a>                <span class="cf">if</span> <span class="fu">isempty</span>(x)</span>
<span id="cb50-1887"><a href="#cb50-1887"></a>                    <span class="cf">break</span></span>
<span id="cb50-1888"><a href="#cb50-1888"></a>                <span class="cf">end</span></span>
<span id="cb50-1889"><a href="#cb50-1889"></a>                <span class="fu">f</span>(buf, <span class="fu">T</span>(x))</span>
<span id="cb50-1890"><a href="#cb50-1890"></a>            <span class="cf">end</span></span>
<span id="cb50-1891"><a href="#cb50-1891"></a>            count <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb50-1892"><a href="#cb50-1892"></a>        <span class="cf">end</span></span>
<span id="cb50-1893"><a href="#cb50-1893"></a>        <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> count</span>
<span id="cb50-1894"><a href="#cb50-1894"></a>    <span class="cf">end</span></span>
<span id="cb50-1895"><a href="#cb50-1895"></a>    x <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{T}</span>(<span class="cn">undef</span>, <span class="fl">1</span>)</span>
<span id="cb50-1896"><a href="#cb50-1896"></a>    <span class="cf">while</span> count <span class="op">&lt;</span> n</span>
<span id="cb50-1897"><a href="#cb50-1897"></a>        r <span class="op">=</span> <span class="fu">transfer!</span>(stream, x; stream_i, deadline<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb50-1898"><a href="#cb50-1898"></a>        stream_i <span class="op">+=</span> r <span class="op">*</span> <span class="fu">sizeof</span>(x[<span class="fl">1</span>])</span>
<span id="cb50-1899"><a href="#cb50-1899"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb50-1900"><a href="#cb50-1900"></a>            <span class="cf">break</span></span>
<span id="cb50-1901"><a href="#cb50-1901"></a>        <span class="cf">end</span></span>
<span id="cb50-1902"><a href="#cb50-1902"></a>        <span class="fu">f</span>(buf, x[<span class="fl">1</span>])</span>
<span id="cb50-1903"><a href="#cb50-1903"></a>        <span class="pp">@assert</span> r <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb50-1904"><a href="#cb50-1904"></a>        count <span class="op">+=</span> r</span>
<span id="cb50-1905"><a href="#cb50-1905"></a>        <span class="cf">if</span> count <span class="op">==</span> n</span>
<span id="cb50-1906"><a href="#cb50-1906"></a>            <span class="cf">break</span></span>
<span id="cb50-1907"><a href="#cb50-1907"></a>        <span class="cf">end</span></span>
<span id="cb50-1908"><a href="#cb50-1908"></a>    <span class="cf">end</span></span>
<span id="cb50-1909"><a href="#cb50-1909"></a>    <span class="pp">@db</span> <span class="fl">2</span> <span class="cf">return</span> count</span>
<span id="cb50-1910"><a href="#cb50-1910"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="transfer-specialisations-for-io-buffers">Transfer
Specialisations for IO Buffers</h2>
<div class="sourceCode" id="cb51" data-startFrom="1916"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1915;"><span id="cb51-1916"><a href="#cb51-1916"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(s1, s2, <span class="op">::</span><span class="dt">ToStream</span>,</span>
<span id="cb51-1917"><a href="#cb51-1917"></a>                                 stream_i, buffer_i, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb51-1918"><a href="#cb51-1918"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s1)</span>
<span id="cb51-1919"><a href="#cb51-1919"></a>    <span class="pp">@require</span> <span class="fu">is_output</span>(s2)</span>
<span id="cb51-1920"><a href="#cb51-1920"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, <span class="fu">min</span>(n, <span class="fu">max</span>(<span class="fu">default_buffer_size</span>(s1),</span>
<span id="cb51-1921"><a href="#cb51-1921"></a>                                          <span class="fu">default_buffer_size</span>(s2))))</span>
<span id="cb51-1922"><a href="#cb51-1922"></a>    count<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb51-1923"><a href="#cb51-1923"></a>    <span class="cf">while</span> count <span class="op">&lt;</span> n</span>
<span id="cb51-1924"><a href="#cb51-1924"></a>        r <span class="op">=</span> <span class="fu">transfer!</span>(s1 <span class="op">=&gt;</span> buf; deadline<span class="op">=</span><span class="fl">0</span>, start<span class="op">=</span>(stream_i <span class="op">=&gt;</span> <span class="fl">1</span>))</span>
<span id="cb51-1925"><a href="#cb51-1925"></a>        stream_i <span class="op">+=</span> r</span>
<span id="cb51-1926"><a href="#cb51-1926"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb51-1927"><a href="#cb51-1927"></a>            <span class="cf">break</span></span>
<span id="cb51-1928"><a href="#cb51-1928"></a>        <span class="cf">end</span></span>
<span id="cb51-1929"><a href="#cb51-1929"></a>        r2 <span class="op">=</span> <span class="fu">transferall!</span>(buf <span class="op">=&gt;</span> s2, r; start<span class="op">=</span>(<span class="fl">1</span> <span class="op">=&gt;</span> buffer_i))</span>
<span id="cb51-1930"><a href="#cb51-1930"></a>        buffer_i <span class="op">+=</span> r2</span>
<span id="cb51-1931"><a href="#cb51-1931"></a>        <span class="pp">@assert</span> r2 <span class="op">==</span> r</span>
<span id="cb51-1932"><a href="#cb51-1932"></a>        <span class="co"># FIXME should query available capacity and not read more than that?</span></span>
<span id="cb51-1933"><a href="#cb51-1933"></a>        <span class="co">#</span></span>
<span id="cb51-1934"><a href="#cb51-1934"></a>        <span class="co"># FIXME https://man7.org/linux/man-pages/man2/sendfile.2.html</span></span>
<span id="cb51-1935"><a href="#cb51-1935"></a>        count <span class="op">+=</span> r</span>
<span id="cb51-1936"><a href="#cb51-1936"></a>    <span class="cf">end</span></span>
<span id="cb51-1937"><a href="#cb51-1937"></a>    <span class="cf">return</span> count</span>
<span id="cb51-1938"><a href="#cb51-1938"></a><span class="kw">end</span></span>
<span id="cb51-1939"><a href="#cb51-1939"></a></span>
<span id="cb51-1940"><a href="#cb51-1940"></a></span>
<span id="cb51-1941"><a href="#cb51-1941"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(s1, s2, <span class="op">::</span><span class="dt">FromStream</span>,</span>
<span id="cb51-1942"><a href="#cb51-1942"></a>                                 stream_i, buffer_i<span class="op">::</span><span class="dt">UInt</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb51-1943"><a href="#cb51-1943"></a>    <span class="pp">@require</span> <span class="fu">is_output</span>(s1)</span>
<span id="cb51-1944"><a href="#cb51-1944"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s2)</span>
<span id="cb51-1945"><a href="#cb51-1945"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb51-1946"><a href="#cb51-1946"></a>    <span class="fu">_attempt_transfer</span>(s2, <span class="fu">In</span>(), s1, <span class="fu">ToStream</span>(), stream_i, buffer_i, n)</span>
<span id="cb51-1947"><a href="#cb51-1947"></a><span class="kw">end</span></span>
<span id="cb51-1948"><a href="#cb51-1948"></a></span>
<span id="cb51-1949"><a href="#cb51-1949"></a></span>
<span id="cb51-1950"><a href="#cb51-1950"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(s, io<span class="op">::</span><span class="dt">T</span>, <span class="op">::</span><span class="dt">ToIO</span>,</span>
<span id="cb51-1951"><a href="#cb51-1951"></a>                                 stream_i, buffer_i<span class="op">::</span><span class="dt">UInt</span>, n<span class="op">::</span><span class="dt">UInt</span>) <span class="kw">where</span> T</span>
<span id="cb51-1952"><a href="#cb51-1952"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb51-1953"><a href="#cb51-1953"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb51-1954"><a href="#cb51-1954"></a>    <span class="fu">_attempt_transfer</span>(s, <span class="fu">BaseIOStream</span><span class="dt">{T, Out}</span>(io), <span class="fu">ToStream</span>(),</span>
<span id="cb51-1955"><a href="#cb51-1955"></a>                      stream_i, buffer_i, n)</span>
<span id="cb51-1956"><a href="#cb51-1956"></a><span class="kw">end</span></span>
<span id="cb51-1957"><a href="#cb51-1957"></a></span>
<span id="cb51-1958"><a href="#cb51-1958"></a></span>
<span id="cb51-1959"><a href="#cb51-1959"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(s, io<span class="op">::</span><span class="dt">T</span>, <span class="op">::</span><span class="dt">FromIO</span>,</span>
<span id="cb51-1960"><a href="#cb51-1960"></a>                                 stream_i, buffer_i<span class="op">::</span><span class="dt">UInt</span>, n<span class="op">::</span><span class="dt">UInt</span>) <span class="kw">where</span> T</span>
<span id="cb51-1961"><a href="#cb51-1961"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb51-1962"><a href="#cb51-1962"></a>    <span class="pp">@require</span> <span class="fu">is_output</span>(s)</span>
<span id="cb51-1963"><a href="#cb51-1963"></a>    <span class="fu">_attempt_transfer</span>(s, <span class="fu">BaseIOStream</span><span class="dt">{T, In}</span>(io), <span class="fu">FromStream</span>(),</span>
<span id="cb51-1964"><a href="#cb51-1964"></a>                      stream_i, buffer_i, n)</span>
<span id="cb51-1965"><a href="#cb51-1965"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="data-fragmentation-trait">Data Fragmentation Trait</h1>
<div class="sourceCode" id="cb52" data-startFrom="1972"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 1971;"><span id="cb52-1972"><a href="#cb52-1972"></a><span class="kw">struct</span> ReadUnit{T} <span class="kw">end</span></span>
<span id="cb52-1973"><a href="#cb52-1973"></a><span class="kw">const</span> AnyReadUnit <span class="op">=</span> ReadUnit </span></code></pre></div>
<p>The <code>ReadUnit</code> trait describes what guarantees a stream
makes about fragmentation of data returned by the underlying
<code>read(2)</code> system call.</p>
<p><code>ReadUnit(stream)</code> returns <code>ReadUnit{T}()</code>
where <code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Data Fragmentation</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:Byte</code></td>
<td style="text-align: left;">No special guarantees about what is
returned by <code>read(2)</code>. This is the default.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Line</code></td>
<td style="text-align: left;"><code>read(2)</code> returns exactly one
line at a time. Does not return partially buffered lines unless an
explicit <code>EOL</code> or <code>EOF</code> control character is
received. Applicable to Character devices in canonical mode. See <a
href="https://man7.org/linux/man-pages/man3/termios.3.html">termios(3)</a>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Packet</code></td>
<td style="text-align: left;"><code>read(2)</code> returns exactly one
packet at a time. Does not return partially buffered packets. Applicable
to some sockets and pipes depending on configuration. e.g. See the
<code>O_DIRECT</code> flag in <a
href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe(2)</a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:RequestedSize</code></td>
<td style="text-align: left;"><code>read(2)</code> returns exactly the
number of elements requested. Applicable to local files and some virtual
files (e.g. <code>/dev/random</code>, <code>/dev/null</code>).</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb53" data-startFrom="2005"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2004;"><span id="cb53-2005"><a href="#cb53-2005"></a><span class="fu">ReadUnit</span>(s) <span class="op">=</span> <span class="fu">ReadUnit</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb53-2006"><a href="#cb53-2006"></a><span class="fu">ReadUnit</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">ReadUnit</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb53-2007"><a href="#cb53-2007"></a>                                  <span class="fu">ReadUnit</span><span class="dt">{:Byte}</span>()</span></code></pre></div>
<h1 id="performance-traits">Performance Traits</h1>
<div class="sourceCode" id="cb54" data-startFrom="2012"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2011;"><span id="cb54-2012"><a href="#cb54-2012"></a><span class="kw">abstract type</span> TransferCost <span class="kw">end</span></span>
<span id="cb54-2013"><a href="#cb54-2013"></a><span class="kw">struct</span> HighTransferCost <span class="op">&lt;:</span><span class="dt"> TransferCost </span><span class="kw">end</span></span>
<span id="cb54-2014"><a href="#cb54-2014"></a><span class="kw">struct</span> LowTransferCost <span class="op">&lt;:</span><span class="dt"> TransferCost </span><span class="kw">end</span></span>
<span id="cb54-2015"><a href="#cb54-2015"></a><span class="fu">TransferCost</span>(s) <span class="op">=</span> <span class="fu">TransferCost</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb54-2016"><a href="#cb54-2016"></a><span class="fu">TransferCost</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">TransferCost</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb54-2017"><a href="#cb54-2017"></a>                                      <span class="fu">HighTransferCost</span>()</span>
<span id="cb54-2018"><a href="#cb54-2018"></a></span>
<span id="cb54-2019"><a href="#cb54-2019"></a></span>
<span id="cb54-2020"><a href="#cb54-2020"></a><span class="kw">const</span> kBytesPerSecond <span class="op">=</span> <span class="fu">Int</span>(<span class="fl">1e3</span>)</span>
<span id="cb54-2021"><a href="#cb54-2021"></a><span class="kw">const</span> MBytesPerSecond <span class="op">=</span> <span class="fu">Int</span>(<span class="fl">1e6</span>)</span>
<span id="cb54-2022"><a href="#cb54-2022"></a><span class="kw">const</span> GBytesPerSecond <span class="op">=</span> <span class="fu">Int</span>(<span class="fl">1e9</span>)</span>
<span id="cb54-2023"><a href="#cb54-2023"></a><span class="fu">DataRate</span>(s) <span class="op">=</span> <span class="fu">DataRate</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb54-2024"><a href="#cb54-2024"></a><span class="fu">DataRate</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">DataRate</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb54-2025"><a href="#cb54-2025"></a>                                  MBytesPerSecond</span></code></pre></div>
<h1 id="cursor-traits-mark-seek">Cursor Traits (Mark &amp; Seek)</h1>
<div class="sourceCode" id="cb55" data-startFrom="2030"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2029;"><span id="cb55-2030"><a href="#cb55-2030"></a><span class="kw">struct</span> Cursors{T} <span class="kw">end</span></span></code></pre></div>
<p>The <code>Cursors</code> trait describes mark and seek
capabilities.</p>
<p><code>Cursors(stream)</code> returns <code>Cursors{T}()</code> where
<code>T</code> is one of:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Cursor Support</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Missing</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:Seekable</code></td>
<td style="text-align: left;">Supports <code>seek</code>,
<code>skip</code>, <code>seekstart</code> and <code>seekend</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:Markable</code></td>
<td style="text-align: left;">Is seekable, and also supports
<code>mark</code>, <code>ismarked</code>, <code>unmark</code>,
<code>reset</code>.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb56" data-startFrom="2048"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2047;"><span id="cb56-2048"><a href="#cb56-2048"></a><span class="fu">Cursors</span>(s) <span class="op">=</span> <span class="fu">Cursors</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb56-2049"><a href="#cb56-2049"></a><span class="fu">Cursors</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">Cursors</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb56-2050"><a href="#cb56-2050"></a>                                 <span class="fu">Cursors</span><span class="dt">{Missing}</span>()</span>
<span id="cb56-2051"><a href="#cb56-2051"></a></span>
<span id="cb56-2052"><a href="#cb56-2052"></a><span class="kw">const</span> HasCursors <span class="op">=</span> <span class="dt">Union</span>{Cursors{<span class="op">:</span>Markable}, Cursors{<span class="op">:</span>Seekable}}</span>
<span id="cb56-2053"><a href="#cb56-2053"></a><span class="kw">const</span> NotMarkable <span class="op">=</span> <span class="dt">Union</span>{Cursors{<span class="dt">Missing</span>}, Cursors{<span class="op">:</span>Seekable}}</span>
<span id="cb56-2054"><a href="#cb56-2054"></a></span>
<span id="cb56-2055"><a href="#cb56-2055"></a><span class="fu">trait_error</span>(s, trait) <span class="op">=</span></span>
<span id="cb56-2056"><a href="#cb56-2056"></a>    <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">typeof</span>(s))<span class="st"> does not implement </span><span class="sc">$</span>trait<span class="st">&quot;</span>))</span>
<span id="cb56-2057"><a href="#cb56-2057"></a></span>
<span id="cb56-2058"><a href="#cb56-2058"></a><span class="bu">Base</span>.<span class="fu">seek</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, pos) <span class="op">=</span> <span class="fu">seek</span>(io.stream, <span class="fu">Cursors</span>(io.stream), pos)</span>
<span id="cb56-2059"><a href="#cb56-2059"></a><span class="fu">_seek</span>(s, <span class="op">::</span><span class="dt">Cursors{Missing}</span>, pos) <span class="op">=</span> <span class="fu">trait_error</span>(s, <span class="op">:</span>Seekable)</span>
<span id="cb56-2060"><a href="#cb56-2060"></a></span>
<span id="cb56-2061"><a href="#cb56-2061"></a><span class="bu">Base</span>.<span class="fu">skip</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, offset) <span class="op">=</span> <span class="fu">_skip</span>(io.stream, <span class="fu">Cursors</span>(io.stream), offset)</span>
<span id="cb56-2062"><a href="#cb56-2062"></a><span class="fu">_skip</span>(s, <span class="op">::</span><span class="dt">Cursors{Missing}</span>, offset) <span class="op">=</span> <span class="fu">trait_error</span>(s, <span class="op">:</span>Seekable)</span></code></pre></div>
<p>FIXME<span
class="sidenote-wrapper"><label for="sn-23" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-23" class="margin-toggle"/><span
class="sidenote">⚠️<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb57" data-startFrom="2065"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2064;"><span id="cb57-2065"><a href="#cb57-2065"></a><span class="co">#Base.position(io::BaseIO) = _position(io.stream, Cursors(io.stream))</span></span>
<span id="cb57-2066"><a href="#cb57-2066"></a><span class="fu">_position</span>(s, <span class="op">::</span><span class="dt">Cursors{Missing}</span>) <span class="op">=</span> <span class="cn">nothing</span></span>
<span id="cb57-2067"><a href="#cb57-2067"></a></span>
<span id="cb57-2068"><a href="#cb57-2068"></a><span class="bu">Base</span>.<span class="fu">seekend</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_seekend</span>(io.stream, <span class="fu">Cursors</span>(io.stream))</span>
<span id="cb57-2069"><a href="#cb57-2069"></a><span class="fu">_seekend</span>(s, <span class="op">::</span><span class="dt">Cursors{Missing}</span>) <span class="op">=</span> <span class="cn">nothing</span></span>
<span id="cb57-2070"><a href="#cb57-2070"></a></span>
<span id="cb57-2071"><a href="#cb57-2071"></a><span class="bu">Base</span>.<span class="fu">mark</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_mark</span>(io.stream, <span class="fu">Cursors</span>(io.stream))</span>
<span id="cb57-2072"><a href="#cb57-2072"></a><span class="fu">_mark</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, <span class="op">:</span>Markable)</span>
<span id="cb57-2073"><a href="#cb57-2073"></a></span>
<span id="cb57-2074"><a href="#cb57-2074"></a><span class="bu">Base</span>.<span class="fu">unmark</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_unmark</span>(io.stream, <span class="fu">Cursors</span>(io.stream))</span>
<span id="cb57-2075"><a href="#cb57-2075"></a><span class="fu">_unmark</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, <span class="op">:</span>Markable)</span>
<span id="cb57-2076"><a href="#cb57-2076"></a></span>
<span id="cb57-2077"><a href="#cb57-2077"></a><span class="bu">Base</span>.<span class="fu">reset</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_reset</span>(io.stream, <span class="fu">Cursors</span>(io.stream))</span>
<span id="cb57-2078"><a href="#cb57-2078"></a><span class="fu">_reset</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, <span class="op">:</span>Markable)</span>
<span id="cb57-2079"><a href="#cb57-2079"></a></span>
<span id="cb57-2080"><a href="#cb57-2080"></a><span class="bu">Base</span>.<span class="fu">ismarked</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">_ismarked</span>(io.stream, <span class="fu">Cursors</span>(io.stream))</span>
<span id="cb57-2081"><a href="#cb57-2081"></a><span class="fu">_ismarked</span>(s, <span class="op">::</span><span class="dt">NotMarkable</span>) <span class="op">=</span> <span class="fu">trait_error</span>(s, <span class="op">:</span>Markable)</span></code></pre></div>
<h1 id="peekable-trait">Peekable Trait</h1>
<div class="sourceCode" id="cb58" data-startFrom="2087"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2086;"><span id="cb58-2087"><a href="#cb58-2087"></a><span class="kw">abstract type</span> PeekSupport <span class="kw">end</span></span>
<span id="cb58-2088"><a href="#cb58-2088"></a><span class="kw">struct</span> Peekable <span class="op">&lt;:</span><span class="dt"> PeekSupport </span><span class="kw">end</span></span>
<span id="cb58-2089"><a href="#cb58-2089"></a><span class="kw">struct</span> NotPeekable <span class="op">&lt;:</span><span class="dt"> PeekSupport </span><span class="kw">end</span></span>
<span id="cb58-2090"><a href="#cb58-2090"></a><span class="fu">PeekSupport</span>(s) <span class="op">=</span> <span class="fu">PeekSupport</span>(<span class="fu">typeof</span>(s))</span>
<span id="cb58-2091"><a href="#cb58-2091"></a><span class="fu">PeekSupport</span>(T<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(T) ? <span class="fu">PeekSupport</span>(<span class="fu">unwrap</span>(T)) <span class="op">:</span></span>
<span id="cb58-2092"><a href="#cb58-2092"></a>                                     <span class="fu">NotPeekable</span>()</span>
<span id="cb58-2093"><a href="#cb58-2093"></a></span>
<span id="cb58-2094"><a href="#cb58-2094"></a><span class="fu">_peek</span>(s, <span class="op">::</span><span class="dt">NotPeekable</span>, T) <span class="op">=</span> <span class="fu">trait_error</span>(s, Peekable)</span></code></pre></div>
<h1 id="timeout-stream">Timeout Stream</h1>
<pre><code>TimeoutStream(stream; timeout, deadline) -&gt; TimeoutStream
timeout_stream(stream; timeout=Inf, deadline=Inf) -&gt; Stream</code></pre>
<p>The temporary <code>TimeoutStream</code> wrapper adds an immutable
transfer deadline to a stream. It is used in cases where a stream
interface function needs to make multiple calls to
<code>transfer!</code> (e.g. <code>readall!</code>).</p>
<p>Note that the <code>timeout_stream</code> function simply returns
<code>stream</code> if <code>timeout</code> and <code>deadline</code>
are both <code>Inf</code>.</p>
<div class="sourceCode" id="cb60" data-startFrom="2111"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2110;"><span id="cb60-2111"><a href="#cb60-2111"></a><span class="kw">struct</span> TimeoutStream{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> Stream</span></span>
<span id="cb60-2112"><a href="#cb60-2112"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb60-2113"><a href="#cb60-2113"></a>    deadline<span class="op">::</span><span class="dt">Float64</span></span>
<span id="cb60-2114"><a href="#cb60-2114"></a>    <span class="kw">function</span> <span class="fu">TimeoutStream</span>(stream<span class="op">::</span><span class="dt">T</span>; timeout, deadline) <span class="kw">where</span> T</span>
<span id="cb60-2115"><a href="#cb60-2115"></a>        <span class="pp">@require</span> (timeout <span class="op">==</span> <span class="cn">Inf</span>) <span class="op">⊻</span> (deadline <span class="op">==</span> <span class="cn">Inf</span>)</span>
<span id="cb60-2116"><a href="#cb60-2116"></a>        <span class="cf">if</span> timeout <span class="op">&lt;</span> <span class="cn">Inf</span></span>
<span id="cb60-2117"><a href="#cb60-2117"></a>            deadline <span class="op">=</span> <span class="fu">time</span>() <span class="op">+</span> timeout</span>
<span id="cb60-2118"><a href="#cb60-2118"></a>        <span class="cf">end</span></span>
<span id="cb60-2119"><a href="#cb60-2119"></a>        <span class="fu">new</span><span class="dt">{T}</span>(stream, deadline)</span>
<span id="cb60-2120"><a href="#cb60-2120"></a>    <span class="kw">end</span></span>
<span id="cb60-2121"><a href="#cb60-2121"></a><span class="kw">end</span></span>
<span id="cb60-2122"><a href="#cb60-2122"></a></span>
<span id="cb60-2123"><a href="#cb60-2123"></a><span class="fu">timeout_stream</span>(s<span class="op">::</span><span class="dt">TimeoutStream</span>; kw<span class="op">...</span>) <span class="op">=</span> <span class="fu">timeout_stream</span>(s.stream; kw<span class="op">...</span>)</span>
<span id="cb60-2124"><a href="#cb60-2124"></a></span>
<span id="cb60-2125"><a href="#cb60-2125"></a><span class="fu">timeout_stream</span>(s; timeout<span class="op">=</span><span class="cn">Inf</span>, deadline<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span></span>
<span id="cb60-2126"><a href="#cb60-2126"></a>    timeout <span class="op">==</span> <span class="cn">Inf</span> <span class="op">&amp;&amp;</span> deadline <span class="op">==</span> <span class="cn">Inf</span> ? s <span class="op">:</span> <span class="fu">TimeoutStream</span>(s; timeout, deadline)</span>
<span id="cb60-2127"><a href="#cb60-2127"></a></span>
<span id="cb60-2128"><a href="#cb60-2128"></a><span class="fu">StreamDelegation</span>(<span class="op">::</span><span class="dt">Type{&lt;:TimeoutStream}</span>) <span class="op">=</span> <span class="fu">DelegatedToSubStream</span>()</span>
<span id="cb60-2129"><a href="#cb60-2129"></a></span>
<span id="cb60-2130"><a href="#cb60-2130"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transfer!</span>(s<span class="op">::</span><span class="dt">TimeoutStream{T}</span>, buffer,</span>
<span id="cb60-2131"><a href="#cb60-2131"></a>                       n<span class="op">::</span><span class="dt">Union{Missing, Integer}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, kw<span class="op">...</span>) <span class="kw">where</span> T</span>
<span id="cb60-2132"><a href="#cb60-2132"></a>    <span class="pp">@db</span> s.deadline <span class="op">-</span> <span class="fu">time</span>()</span>
<span id="cb60-2133"><a href="#cb60-2133"></a>    <span class="fu">transfer!</span>(s.stream, buffer, n; deadline <span class="op">=</span> <span class="fu">min</span>(deadline, s.deadline), kw<span class="op">...</span>)</span>
<span id="cb60-2134"><a href="#cb60-2134"></a><span class="kw">end</span></span>
<span id="cb60-2135"><a href="#cb60-2135"></a></span>
<span id="cb60-2136"><a href="#cb60-2136"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">pump!</span>(s<span class="op">::</span><span class="dt">TimeoutStream{T}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="kw">where</span> T</span>
<span id="cb60-2137"><a href="#cb60-2137"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb60-2138"><a href="#cb60-2138"></a>    deadline <span class="op">=</span> <span class="fu">deadline_or_timeout</span>(deadline, timeout)</span>
<span id="cb60-2139"><a href="#cb60-2139"></a>    <span class="fu">pump!</span>(s.stream; deadline <span class="op">=</span> <span class="fu">min</span>(deadline, s.deadline))</span>
<span id="cb60-2140"><a href="#cb60-2140"></a><span class="kw">end</span></span>
<span id="cb60-2141"><a href="#cb60-2141"></a></span>
<span id="cb60-2142"><a href="#cb60-2142"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">wait</span>(s<span class="op">::</span><span class="dt">TimeoutStream{T}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="kw">where</span> T</span>
<span id="cb60-2143"><a href="#cb60-2143"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb60-2144"><a href="#cb60-2144"></a>    deadline <span class="op">=</span> <span class="fu">deadline_or_timeout</span>(deadline, timeout)</span>
<span id="cb60-2145"><a href="#cb60-2145"></a>    <span class="fu">wait</span>(s.stream; deadline <span class="op">=</span> <span class="fu">min</span>(deadline, s.deadline))</span>
<span id="cb60-2146"><a href="#cb60-2146"></a><span class="kw">end</span></span>
<span id="cb60-2147"><a href="#cb60-2147"></a></span>
<span id="cb60-2148"><a href="#cb60-2148"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">eof</span>(s<span class="op">::</span><span class="dt">TimeoutStream{T}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="kw">where</span> T</span>
<span id="cb60-2149"><a href="#cb60-2149"></a>    deadline <span class="op">=</span> <span class="fu">deadline_or_timeout</span>(deadline, timeout)</span>
<span id="cb60-2150"><a href="#cb60-2150"></a>    <span class="fu">eof</span>(s.stream; deadline <span class="op">=</span> <span class="fu">min</span>(deadline, s.deadline))</span>
<span id="cb60-2151"><a href="#cb60-2151"></a><span class="kw">end</span></span>
<span id="cb60-2152"><a href="#cb60-2152"></a></span>
<span id="cb60-2153"><a href="#cb60-2153"></a><span class="fu">unsafe_transfer!</span>(s<span class="op">::</span><span class="dt">TimeoutStream</span>, args<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb60-2154"><a href="#cb60-2154"></a>    <span class="fu">unsafe_transfer!</span>(s.stream, args<span class="op">...</span>)</span></code></pre></div>
<h1 id="interface-functions">Interface Functions</h1>
<p>How many bytes remain before the end of <code>stream</code>?</p>
<div class="sourceCode" id="cb61" data-startFrom="2163"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2162;"><span id="cb61-2163"><a href="#cb61-2163"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">bytesremaining</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb61-2164"><a href="#cb61-2164"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb61-2165"><a href="#cb61-2165"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb61-2166"><a href="#cb61-2166"></a>    <span class="fu">bytesremaining</span>(s, <span class="fu">TotalSize</span>(s), <span class="fu">Cursors</span>(s))</span>
<span id="cb61-2167"><a href="#cb61-2167"></a><span class="kw">end</span></span>
<span id="cb61-2168"><a href="#cb61-2168"></a></span>
<span id="cb61-2169"><a href="#cb61-2169"></a><span class="fu">bytesremaining</span>(s, <span class="op">::</span><span class="dt">TotalSize{:Zero}</span>, <span class="op">::</span><span class="dt">Any</span>) <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb61-2170"><a href="#cb61-2170"></a><span class="fu">bytesremaining</span>(s, <span class="op">::</span><span class="dt">TotalSize{:Unknown}</span>, <span class="op">::</span><span class="dt">Any</span>) <span class="op">=</span> <span class="cn">missing</span></span>
<span id="cb61-2171"><a href="#cb61-2171"></a><span class="fu">bytesremaining</span>(s, <span class="op">::</span><span class="dt">TotalSize{:Infinite}</span>, <span class="op">::</span><span class="dt">Any</span>) <span class="op">=</span> <span class="fu">typemax</span>(<span class="dt">UInt</span>)</span>
<span id="cb61-2172"><a href="#cb61-2172"></a></span>
<span id="cb61-2173"><a href="#cb61-2173"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">bytesremaining</span>(s, <span class="op">::</span><span class="dt">KnownTotalSize</span>, <span class="op">::</span><span class="dt">HasCursors</span>)</span>
<span id="cb61-2174"><a href="#cb61-2174"></a>    <span class="fu">length</span>(s) <span class="op">-</span> <span class="fu">position</span>(s)</span>
<span id="cb61-2175"><a href="#cb61-2175"></a><span class="kw">end</span></span>
<span id="cb61-2176"><a href="#cb61-2176"></a></span>
<span id="cb61-2177"><a href="#cb61-2177"></a><span class="co">#TODO: note about dispatch sequencing:</span></span></code></pre></div>
<h1 id="first-isproxyunwrap">- first isproxy/unwrap</h1>
<h1 id="then-apply-traits">- then apply traits</h1>
<div class="sourceCode" id="cb62" data-startFrom="2181"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2180;"><span id="cb62-2181"><a href="#cb62-2181"></a><span class="co">#Classes of method:</span></span></code></pre></div>
<h1 id="conveniance-interfcae-method">- Conveniance interfcae
method</h1>
<h1 id="transforms-inputs-implements-default-values">- transforms
inputs, implements default values</h1>
<h1 id="no-side-effects-other-than-calling-a-core-method">- no
side-effects other than calling a core method</h1>
<h1 id="main-interfcae-method">- Main interfcae method</h1>
<h1 id="checks-preconditions">- checks preconditions</h1>
<h1 id="does-not-call-other-methods-of-same-function">- does not call
other methods of same function</h1>
<h1 id="calls-main-imeplemetation-method">- calls Main imeplemetation
method</h1>
<h1 id="checks-postcondition">- checks postcondition</h1>
<h1 id="main-implementation-method">- Main implementation method</h1>
<h1 id="different-non-exported-name-to-interface-method">- different
non-exported name to interface method</h1>
<h1
id="implements-trait-based-fan-out-to-other-implenentation-methods">-
implements trait-based fan-out to other implenentation methods</h1>
<h1 id="section"></h1>
<p>FIXME<span
class="sidenote-wrapper"><label for="sn-24" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-24" class="margin-toggle"/><span
class="sidenote">⚠️ rename isfinished -&gt; isconnected ???<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb63" data-startFrom="2200"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2199;"><span id="cb63-2200"><a href="#cb63-2200"></a><span class="kw">mutable struct</span> IOEventCounts</span>
<span id="cb63-2201"><a href="#cb63-2201"></a>    not_connected_but_not_finished<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb63-2202"><a href="#cb63-2202"></a>    inefficient_byte_io<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb63-2203"><a href="#cb63-2203"></a>    <span class="fu">IOEventCounts</span>() <span class="op">=</span> <span class="fu">new</span>(<span class="fl">0</span>)</span>
<span id="cb63-2204"><a href="#cb63-2204"></a><span class="kw">end</span></span>
<span id="cb63-2205"><a href="#cb63-2205"></a></span>
<span id="cb63-2206"><a href="#cb63-2206"></a><span class="kw">function</span> <span class="fu">io_counts</span>(stream)</span>
<span id="cb63-2207"><a href="#cb63-2207"></a>    key <span class="op">=</span> <span class="op">:</span>IO_TRAITS_EVENT_COUNTS</span>
<span id="cb63-2208"><a href="#cb63-2208"></a>    counts_dict <span class="op">=</span> try</span>
<span id="cb63-2209"><a href="#cb63-2209"></a>        <span class="fu">task_local_storage</span>(key)</span>
<span id="cb63-2210"><a href="#cb63-2210"></a>    catch</span>
<span id="cb63-2211"><a href="#cb63-2211"></a>        <span class="fu">task_local_storage</span>(key, <span class="fu">Dict</span><span class="dt">{Stream,IOEventCounts}</span>())</span>
<span id="cb63-2212"><a href="#cb63-2212"></a>    <span class="kw">end</span></span>
<span id="cb63-2213"><a href="#cb63-2213"></a>    counts <span class="op">=</span> <span class="fu">get</span>(counts_dict, stream, <span class="cn">nothing</span>)</span>
<span id="cb63-2214"><a href="#cb63-2214"></a>    <span class="cf">if</span> counts <span class="op">==</span> <span class="cn">nothing</span></span>
<span id="cb63-2215"><a href="#cb63-2215"></a>        counts <span class="op">=</span> <span class="fu">IOEventCounts</span>()</span>
<span id="cb63-2216"><a href="#cb63-2216"></a>        counts_dict[stream] <span class="op">=</span> counts</span>
<span id="cb63-2217"><a href="#cb63-2217"></a>    <span class="cf">end</span></span>
<span id="cb63-2218"><a href="#cb63-2218"></a>    counts</span>
<span id="cb63-2219"><a href="#cb63-2219"></a><span class="kw">end</span></span>
<span id="cb63-2220"><a href="#cb63-2220"></a></span>
<span id="cb63-2221"><a href="#cb63-2221"></a></span>
<span id="cb63-2222"><a href="#cb63-2222"></a></span>
<span id="cb63-2223"><a href="#cb63-2223"></a><span class="kw">global</span> stats </span>
<span id="cb63-2224"><a href="#cb63-2224"></a></span>
<span id="cb63-2225"><a href="#cb63-2225"></a><span class="fu">isconnected</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">is_proxy</span>(s) ? <span class="fu">isconnected</span>(<span class="fu">unwrap</span>(s)) <span class="op">:</span> <span class="cn">true</span></span>
<span id="cb63-2226"><a href="#cb63-2226"></a></span>
<span id="cb63-2227"><a href="#cb63-2227"></a><span class="fu">warn_not_connected_but_not_finished</span>(s) <span class="op">=</span> </span>
<span id="cb63-2228"><a href="#cb63-2228"></a>    (<span class="fu">io_counts</span>(s).not_connected_but_not_finished <span class="op">+=</span> <span class="fl">1</span>) <span class="op">&lt;</span> <span class="fl">2</span> <span class="op">||</span></span>
<span id="cb63-2229"><a href="#cb63-2229"></a>    <span class="pp">@warn</span> <span class="st">&quot;Stream is disconnected but isfinished(</span><span class="sc">$</span>s<span class="st">) returned false because &quot;</span> <span class="op">*</span></span>
<span id="cb63-2230"><a href="#cb63-2230"></a>           <span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">bytesavailable</span>(s))<span class="st"> bytes are buffered.&quot;</span></span>
<span id="cb63-2231"><a href="#cb63-2231"></a></span>
<span id="cb63-2232"><a href="#cb63-2232"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">isfinished</span>(s<span class="op">::</span><span class="dt">Stream</span>)</span>
<span id="cb63-2233"><a href="#cb63-2233"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb63-2234"><a href="#cb63-2234"></a>    <span class="cf">if</span> <span class="fu">is_output</span>(s) <span class="op">||</span> !<span class="fu">length_is_known</span>(s)</span>
<span id="cb63-2235"><a href="#cb63-2235"></a>        <span class="pp">@db</span> <span class="cf">return</span> !<span class="fu">isconnected</span>(s)</span>
<span id="cb63-2236"><a href="#cb63-2236"></a>    <span class="cf">end</span></span>
<span id="cb63-2237"><a href="#cb63-2237"></a>    n_bytesavailable <span class="op">=</span> <span class="fu">bytesavailable</span>(s)</span>
<span id="cb63-2238"><a href="#cb63-2238"></a>    <span class="cf">if</span> <span class="fu">availability_is_known</span>(s) <span class="op">&amp;&amp;</span> n_bytesavailable <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb63-2239"><a href="#cb63-2239"></a>        <span class="fu">isconnected</span>(s) <span class="op">||</span> <span class="fu">warn_not_connected_but_not_finished</span>(s)</span>
<span id="cb63-2240"><a href="#cb63-2240"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="cn">false</span></span>
<span id="cb63-2241"><a href="#cb63-2241"></a>    <span class="cf">end</span></span>
<span id="cb63-2242"><a href="#cb63-2242"></a>    <span class="pp">@db</span> <span class="cf">return</span> n_bytesavailable <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb63-2243"><a href="#cb63-2243"></a><span class="kw">end</span></span></code></pre></div>
<p><code>readbyte</code> returns one byte (or <code>nothing</code> at
end of stream or if <code>deadline</code> expires).</p>
<p>Specialized based on Transfer Cost.</p>
<div class="sourceCode" id="cb64" data-startFrom="2252"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2251;"><span id="cb64-2252"><a href="#cb64-2252"></a><span class="kw">function</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">Stream</span>; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb64-2253"><a href="#cb64-2253"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb64-2254"><a href="#cb64-2254"></a>    <span class="fu">readbyte</span>(s, <span class="fu">TransferCost</span>(s); deadline)</span>
<span id="cb64-2255"><a href="#cb64-2255"></a><span class="kw">end</span></span>
<span id="cb64-2256"><a href="#cb64-2256"></a></span>
<span id="cb64-2257"><a href="#cb64-2257"></a><span class="kw">function</span> <span class="fu">readbyte</span>(s, <span class="op">::</span><span class="dt">HighTransferCost</span>; kw<span class="op">...</span>)</span>
<span id="cb64-2258"><a href="#cb64-2258"></a>    count <span class="op">=</span> (<span class="fu">io_counts</span>(s).inefficient_byte_io <span class="op">+=</span> <span class="fl">1</span>)</span>
<span id="cb64-2259"><a href="#cb64-2259"></a>    <span class="cf">if</span> (count <span class="op">∈</span> <span class="fl">10</span><span class="op">:</span><span class="fl">100</span> <span class="op">||</span> (count <span class="op">&gt;</span> <span class="fl">100</span> <span class="op">&amp;&amp;</span> count <span class="op">%</span> <span class="fl">100</span> <span class="op">==</span> <span class="fl">0</span>))</span>
<span id="cb64-2260"><a href="#cb64-2260"></a>        <span class="pp">@warn</span> <span class="st">&quot;readbyte(): </span><span class="sc">$</span>(<span class="fu">typeof</span>(s))<span class="st"> may be inefficient for byte I/O. &quot;</span>,</span>
<span id="cb64-2261"><a href="#cb64-2261"></a>              <span class="st">&quot;Consider using the `LazyBufferedInput` wrapper.&quot;</span></span>
<span id="cb64-2262"><a href="#cb64-2262"></a>    <span class="cf">end</span></span>
<span id="cb64-2263"><a href="#cb64-2263"></a>    <span class="pp">@invoke</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">Stream</span>, <span class="fu">LowTransferCost</span>()<span class="op">::</span><span class="dt">LowTransferCost</span>; kw<span class="op">...</span>)</span>
<span id="cb64-2264"><a href="#cb64-2264"></a><span class="kw">end</span></span></code></pre></div>
<p>Allow single byte read for interfaces with Low Transfer Cost, but
warn if a special Read Fragmentation trait is available.<span
class="sidenote-wrapper"><label for="sn-25" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-25" class="margin-toggle"/><span
class="sidenote">⚠️ FIXME: Warnings should be configurable via
Preferences.jl<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb65" data-startFrom="2273"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2272;"><span id="cb65-2273"><a href="#cb65-2273"></a><span class="kw">function</span> <span class="fu">readbyte</span>(stream, <span class="op">::</span><span class="dt">LowTransferCost</span>; deadline)</span>
<span id="cb65-2274"><a href="#cb65-2274"></a>    <span class="cf">if</span> <span class="fu">ReadUnit</span>(stream) <span class="op">==</span> <span class="fu">ReadUnit</span><span class="dt">{:Line}</span>()</span>
<span id="cb65-2275"><a href="#cb65-2275"></a>        <span class="pp">@warn</span> <span class="st">&quot;read(::</span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st">, UInt8): &quot;</span> <span class="op">*</span></span>
<span id="cb65-2276"><a href="#cb65-2276"></a>              <span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st"> implements `IOTraits.ReadUnit{:Line}`.&quot;</span> <span class="op">*</span></span>
<span id="cb65-2277"><a href="#cb65-2277"></a>              <span class="st">&quot;Reading one byte at a time may not be efficient.&quot;</span> <span class="op">*</span></span>
<span id="cb65-2278"><a href="#cb65-2278"></a>              <span class="st">&quot;Consider using `readline` instead.&quot;</span></span>
<span id="cb65-2279"><a href="#cb65-2279"></a>        <span class="pp">@db_not_tested</span></span>
<span id="cb65-2280"><a href="#cb65-2280"></a>    <span class="cf">end</span></span>
<span id="cb65-2281"><a href="#cb65-2281"></a>    x <span class="op">=</span> <span class="fu">Ref</span>(<span class="fu">UInt8</span>(<span class="fl">0</span>))</span>
<span id="cb65-2282"><a href="#cb65-2282"></a>    n <span class="op">=</span> <span class="fu">transfer!</span>(stream <span class="op">=&gt;</span> x, <span class="fl">1</span>; deadline)</span>
<span id="cb65-2283"><a href="#cb65-2283"></a>    n <span class="op">==</span> <span class="fl">1</span> <span class="op">||</span> <span class="cf">return</span> <span class="cn">nothing</span></span>
<span id="cb65-2284"><a href="#cb65-2284"></a>    <span class="cf">return</span> x[]</span>
<span id="cb65-2285"><a href="#cb65-2285"></a><span class="kw">end</span></span>
<span id="cb65-2286"><a href="#cb65-2286"></a></span>
<span id="cb65-2287"><a href="#cb65-2287"></a><span class="bu">Base</span>.<span class="fu">read</span>(s<span class="op">::</span><span class="dt">Stream</span>) <span class="op">=</span> <span class="fu">readall!</span>(s)</span>
<span id="cb65-2288"><a href="#cb65-2288"></a></span>
<span id="cb65-2289"><a href="#cb65-2289"></a><span class="bu">Base</span>.<span class="fu">read</span>(s<span class="op">::</span><span class="dt">Stream</span>, <span class="op">::</span><span class="dt">Type{T}</span>; kw<span class="op">...</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">read</span>(<span class="fu">BaseIO</span>(s), T; kw<span class="op">...</span>)</span>
<span id="cb65-2290"><a href="#cb65-2290"></a></span>
<span id="cb65-2291"><a href="#cb65-2291"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(s<span class="op">::</span><span class="dt">Stream</span>, n<span class="op">::</span><span class="dt">Integer</span>; kw<span class="op">...</span>)</span>
<span id="cb65-2292"><a href="#cb65-2292"></a>    v <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb65-2293"><a href="#cb65-2293"></a>    <span class="fu">transfer!</span>(s <span class="op">=&gt;</span> v)</span>
<span id="cb65-2294"><a href="#cb65-2294"></a>    v</span>
<span id="cb65-2295"><a href="#cb65-2295"></a><span class="kw">end</span></span></code></pre></div>
<p><code>readall!</code> reads until the end of <code>stream</code> (or
until <code>timeout</code> expires) and returns
<code>Vector{UInt8}</code>.</p>
<p>Specialise on Total Size and Cursor Support.</p>
<div class="sourceCode" id="cb66" data-startFrom="2304"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2303;"><span id="cb66-2304"><a href="#cb66-2304"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">readall!</span>(s<span class="op">::</span><span class="dt">Stream</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb66-2305"><a href="#cb66-2305"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb66-2306"><a href="#cb66-2306"></a>    <span class="pp">@require</span> <span class="fu">TotalSize</span>(s) <span class="op">!=</span> <span class="fu">TotalSize</span><span class="dt">{:Infinite}</span>() <span class="op">||</span> timeout <span class="op">&lt;</span> <span class="cn">Inf</span></span>
<span id="cb66-2307"><a href="#cb66-2307"></a>    <span class="fu">_readall!</span>(s, <span class="fu">TotalSize</span>(s), <span class="fu">Cursors</span>(s), timeout)</span>
<span id="cb66-2308"><a href="#cb66-2308"></a><span class="kw">end</span></span>
<span id="cb66-2309"><a href="#cb66-2309"></a></span>
<span id="cb66-2310"><a href="#cb66-2310"></a></span>
<span id="cb66-2311"><a href="#cb66-2311"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_readall!</span>(stream, <span class="op">::</span><span class="dt">TotalSize{:Unknown}</span>, <span class="op">::</span><span class="dt">Cursors{Missing}</span>, timeout)</span>
<span id="cb66-2312"><a href="#cb66-2312"></a>    n <span class="op">=</span> <span class="fu">default_buffer_size</span>(stream)</span>
<span id="cb66-2313"><a href="#cb66-2313"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb66-2314"><a href="#cb66-2314"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(stream; timeout)</span>
<span id="cb66-2315"><a href="#cb66-2315"></a>    n <span class="op">=</span> <span class="fu">_readbytes!</span>(stream, buf, <span class="fu">typemax</span>(<span class="dt">UInt</span>))</span>
<span id="cb66-2316"><a href="#cb66-2316"></a>    <span class="pp">@assert</span> n <span class="op">&lt;=</span> <span class="fu">length</span>(buf)</span>
<span id="cb66-2317"><a href="#cb66-2317"></a>    <span class="fu">resize!</span>(buf, n)</span>
<span id="cb66-2318"><a href="#cb66-2318"></a>    <span class="pp">@db</span> <span class="cf">return</span> buf</span>
<span id="cb66-2319"><a href="#cb66-2319"></a><span class="kw">end</span></span>
<span id="cb66-2320"><a href="#cb66-2320"></a></span>
<span id="cb66-2321"><a href="#cb66-2321"></a></span>
<span id="cb66-2322"><a href="#cb66-2322"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_readall!</span>(stream, <span class="op">::</span><span class="dt">KnownTotalSize</span>, <span class="op">::</span><span class="dt">HasCursors</span>, timeout)</span>
<span id="cb66-2323"><a href="#cb66-2323"></a>    n <span class="op">=</span> <span class="fu">length</span>(stream) <span class="op">-</span> <span class="fu">position</span>(stream)</span>
<span id="cb66-2324"><a href="#cb66-2324"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb66-2325"><a href="#cb66-2325"></a>    <span class="fu">transferall!</span>(stream, buf, n; timeout)</span>
<span id="cb66-2326"><a href="#cb66-2326"></a>    <span class="pp">@db</span> <span class="cf">return</span> buf</span>
<span id="cb66-2327"><a href="#cb66-2327"></a><span class="kw">end</span></span>
<span id="cb66-2328"><a href="#cb66-2328"></a></span>
<span id="cb66-2329"><a href="#cb66-2329"></a></span>
<span id="cb66-2330"><a href="#cb66-2330"></a><span class="fu">readall!</span>(x<span class="op">::</span><span class="dt">Union{Cmd,URI}</span>; kw<span class="op">...</span>) <span class="op">=</span> <span class="fu">openread</span>(<span class="fu">s-&gt;readall!</span>(s; kw<span class="op">...</span>), x)</span>
<span id="cb66-2331"><a href="#cb66-2331"></a><span class="fu">readall!</span>(uri<span class="op">::</span><span class="dt">AbstractString</span>; kw<span class="op">...</span>) <span class="op">=</span> <span class="fu">readall!</span>(<span class="fu">URI</span>(uri); kw<span class="op">...</span>)</span></code></pre></div>
<p>Transfer <code>n</code> items between <code>stream</code> and
<code>buf</code>.</p>
<p>Call <code>transfer</code> repeatedly until all <code>n</code> items
have been Transferred, stopping only if end of file is reached.</p>
<p>Return the number of items transferred.</p>
<div class="sourceCode" id="cb67" data-startFrom="2342"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2341;"><span id="cb67-2342"><a href="#cb67-2342"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transferall!</span>(stream, buf, n<span class="op">=</span><span class="cn">missing</span>; stream_i<span class="op">=</span><span class="cn">missing</span>, buffer_i<span class="op">=</span><span class="cn">missing</span>, deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb67-2343"><a href="#cb67-2343"></a>    <span class="pp">@require</span> deadline <span class="op">==</span> <span class="cn">Inf</span> <span class="op">||</span> timeout <span class="op">==</span> <span class="cn">Inf</span></span>
<span id="cb67-2344"><a href="#cb67-2344"></a>    <span class="pp">@require</span> <span class="fu">TotalSize</span>(stream) <span class="op">!=</span> <span class="fu">TotalSize</span><span class="dt">{:Infinite}</span>() <span class="op">||</span> (deadline <span class="op">+</span> timeout <span class="op">&lt;</span> <span class="cn">Inf</span>)</span>
<span id="cb67-2345"><a href="#cb67-2345"></a>    <span class="co"># FIXME deadline requirement for infinite stream might make sense for input streams, but makes not sense for outputs</span></span>
<span id="cb67-2346"><a href="#cb67-2346"></a>    <span class="co"># Even for inputs, no deadline is ok if `n` is finine.</span></span>
<span id="cb67-2347"><a href="#cb67-2347"></a>    <span class="co">#</span></span>
<span id="cb67-2348"><a href="#cb67-2348"></a>    <span class="co"># FIXME `n=length(buf)` makes no sense for ToStream, ToPush, ToPut...</span></span>
<span id="cb67-2349"><a href="#cb67-2349"></a>    <span class="co"># FIXME `n=length(buf)` ... or ncodeunits(buf)??</span></span>
<span id="cb67-2350"><a href="#cb67-2350"></a></span>
<span id="cb67-2351"><a href="#cb67-2351"></a>    <span class="cf">if</span> <span class="fu">ismissing</span>(buffer_i) <span class="op">&amp;&amp;</span> <span class="fu">buffer_is_indexed</span>(stream, buf)</span>
<span id="cb67-2352"><a href="#cb67-2352"></a>        buffer_i <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb67-2353"><a href="#cb67-2353"></a>    <span class="cf">end</span></span>
<span id="cb67-2354"><a href="#cb67-2354"></a>    <span class="cf">if</span> <span class="fu">ismissing</span>(n) <span class="op">&amp;&amp;</span> <span class="fu">buffer_is_indexed</span>(stream, buf)</span>
<span id="cb67-2355"><a href="#cb67-2355"></a>        n <span class="op">=</span> <span class="fu">length</span>(buf) <span class="co"># FIXME ??</span></span>
<span id="cb67-2356"><a href="#cb67-2356"></a>    <span class="cf">end</span></span>
<span id="cb67-2357"><a href="#cb67-2357"></a></span>
<span id="cb67-2358"><a href="#cb67-2358"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(stream; timeout, deadline)</span>
<span id="cb67-2359"><a href="#cb67-2359"></a>    ntransferred<span class="op">::</span><span class="dt">UInt </span><span class="op">=</span> <span class="fl">0</span></span>
<span id="cb67-2360"><a href="#cb67-2360"></a>    <span class="cf">while</span> (<span class="fu">ismissing</span>(n) <span class="op">&amp;&amp;</span> !<span class="fu">isfinished</span>(stream)) <span class="op">||</span> (!<span class="fu">ismissing</span>(n) <span class="op">&amp;&amp;</span> ntransferred <span class="op">&lt;</span> n)</span>
<span id="cb67-2361"><a href="#cb67-2361"></a>        r <span class="op">=</span> <span class="fu">transfer!</span>(stream, buf, n <span class="op">-</span> ntransferred; stream_i, buffer_i)</span>
<span id="cb67-2362"><a href="#cb67-2362"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb67-2363"><a href="#cb67-2363"></a>            <span class="cf">break</span></span>
<span id="cb67-2364"><a href="#cb67-2364"></a>        <span class="cf">end</span></span>
<span id="cb67-2365"><a href="#cb67-2365"></a>        ntransferred <span class="op">+=</span> r</span>
<span id="cb67-2366"><a href="#cb67-2366"></a>        stream_i <span class="op">+=</span> r</span>
<span id="cb67-2367"><a href="#cb67-2367"></a>        buffer_i <span class="op">+=</span> r</span>
<span id="cb67-2368"><a href="#cb67-2368"></a>    <span class="cf">end</span></span>
<span id="cb67-2369"><a href="#cb67-2369"></a>    <span class="pp">@ensure</span> ntransferred isa <span class="dt">UInt</span></span>
<span id="cb67-2370"><a href="#cb67-2370"></a>    <span class="pp">@db</span> <span class="cf">return</span> ntransferred</span>
<span id="cb67-2371"><a href="#cb67-2371"></a><span class="kw">end</span></span>
<span id="cb67-2372"><a href="#cb67-2372"></a></span>
<span id="cb67-2373"><a href="#cb67-2373"></a><span class="fu">openread</span>(uri<span class="op">::</span><span class="dt">URI</span>) <span class="op">=</span> <span class="fu">openread</span>(uri.uri)</span>
<span id="cb67-2374"><a href="#cb67-2374"></a><span class="fu">openwrite</span>(uri<span class="op">::</span><span class="dt">URI</span>) <span class="op">=</span> <span class="fu">openwrite</span>(uri.uri)</span>
<span id="cb67-2375"><a href="#cb67-2375"></a></span>
<span id="cb67-2376"><a href="#cb67-2376"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">openread</span>(f<span class="op">::</span><span class="dt">Function</span>, x)</span>
<span id="cb67-2377"><a href="#cb67-2377"></a>    s <span class="op">=</span> <span class="fu">openread</span>(x)</span>
<span id="cb67-2378"><a href="#cb67-2378"></a>    try</span>
<span id="cb67-2379"><a href="#cb67-2379"></a>        <span class="fu">f</span>(s)</span>
<span id="cb67-2380"><a href="#cb67-2380"></a>    finally</span>
<span id="cb67-2381"><a href="#cb67-2381"></a>        <span class="fu">close</span>(s)</span>
<span id="cb67-2382"><a href="#cb67-2382"></a>    <span class="kw">end</span></span>
<span id="cb67-2383"><a href="#cb67-2383"></a><span class="kw">end</span></span>
<span id="cb67-2384"><a href="#cb67-2384"></a></span>
<span id="cb67-2385"><a href="#cb67-2385"></a></span>
<span id="cb67-2386"><a href="#cb67-2386"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">openwrite</span>(f<span class="op">::</span><span class="dt">Function</span>, x)</span>
<span id="cb67-2387"><a href="#cb67-2387"></a>    s <span class="op">=</span> <span class="fu">openwrite</span>(x)</span>
<span id="cb67-2388"><a href="#cb67-2388"></a>    try</span>
<span id="cb67-2389"><a href="#cb67-2389"></a>        <span class="fu">f</span>(s)</span>
<span id="cb67-2390"><a href="#cb67-2390"></a>    finally</span>
<span id="cb67-2391"><a href="#cb67-2391"></a>        <span class="fu">close</span>(s)</span>
<span id="cb67-2392"><a href="#cb67-2392"></a>    <span class="kw">end</span></span>
<span id="cb67-2393"><a href="#cb67-2393"></a><span class="kw">end</span></span>
<span id="cb67-2394"><a href="#cb67-2394"></a></span>
<span id="cb67-2395"><a href="#cb67-2395"></a></span>
<span id="cb67-2396"><a href="#cb67-2396"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">transferall!</span>((a,b)<span class="op">::</span><span class="dt">Pair{&lt;:Any,&lt;:Any}</span>, args<span class="op">...</span>;</span>
<span id="cb67-2397"><a href="#cb67-2397"></a>                          start<span class="op">::</span><span class="dt">Pair</span>=(<span class="cn">missing</span> <span class="op">=&gt;</span> <span class="cn">missing</span>), kw<span class="op">...</span>)</span>
<span id="cb67-2398"><a href="#cb67-2398"></a>    ai, bi <span class="op">=</span> start</span>
<span id="cb67-2399"><a href="#cb67-2399"></a></span>
<span id="cb67-2400"><a href="#cb67-2400"></a>    <span class="pp">@require</span> a isa Stream <span class="op">||</span> b isa Stream</span>
<span id="cb67-2401"><a href="#cb67-2401"></a>    <span class="pp">@require</span> !(a isa Stream) <span class="op">||</span> <span class="fu">TransferDirection</span>(a) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb67-2402"><a href="#cb67-2402"></a>    <span class="pp">@require</span> !(b isa Stream) <span class="op">||</span> <span class="fu">TransferDirection</span>(b) <span class="op">==</span> <span class="fu">Out</span>()</span>
<span id="cb67-2403"><a href="#cb67-2403"></a></span>
<span id="cb67-2404"><a href="#cb67-2404"></a>    <span class="cf">if</span> a isa Stream</span>
<span id="cb67-2405"><a href="#cb67-2405"></a>        <span class="fu">transferall!</span>(a, b, args<span class="op">...</span>; stream_i<span class="op">=</span>ai, buffer_i<span class="op">=</span>bi, kw<span class="op">...</span>)</span>
<span id="cb67-2406"><a href="#cb67-2406"></a>    <span class="cf">else</span></span>
<span id="cb67-2407"><a href="#cb67-2407"></a>        <span class="fu">transferall!</span>(b, a, args<span class="op">...</span>; stream_i<span class="op">=</span>bi, buffer_i<span class="op">=</span>ai, kw<span class="op">...</span>)</span>
<span id="cb67-2408"><a href="#cb67-2408"></a>    <span class="cf">end</span></span>
<span id="cb67-2409"><a href="#cb67-2409"></a><span class="kw">end</span></span>
<span id="cb67-2410"><a href="#cb67-2410"></a></span>
<span id="cb67-2411"><a href="#cb67-2411"></a></span>
<span id="cb67-2412"><a href="#cb67-2412"></a><span class="kw">function</span> <span class="fu">transferall!</span>((a,b)<span class="op">::</span><span class="dt">Pair{&lt;:Union{URI,Cmd},&lt;:Any}</span>, args<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb67-2413"><a href="#cb67-2413"></a>    <span class="fu">openread</span>(a) <span class="cf">do</span> s</span>
<span id="cb67-2414"><a href="#cb67-2414"></a>        <span class="fu">transferall!</span>(s<span class="op">=&gt;</span>b, args<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb67-2415"><a href="#cb67-2415"></a>    <span class="cf">end</span></span>
<span id="cb67-2416"><a href="#cb67-2416"></a><span class="kw">end</span></span>
<span id="cb67-2417"><a href="#cb67-2417"></a></span>
<span id="cb67-2418"><a href="#cb67-2418"></a></span>
<span id="cb67-2419"><a href="#cb67-2419"></a><span class="kw">function</span> <span class="fu">transferall!</span>((a,b)<span class="op">::</span><span class="dt">Pair{&lt;:Any,&lt;:Union{URI,Cmd}}</span>, args<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb67-2420"><a href="#cb67-2420"></a>    <span class="fu">openwrite</span>(b) <span class="cf">do</span> s</span>
<span id="cb67-2421"><a href="#cb67-2421"></a>        <span class="fu">transferall!</span>(a<span class="op">=&gt;</span>s, args<span class="op">...</span>; kw<span class="op">...</span>)</span>
<span id="cb67-2422"><a href="#cb67-2422"></a>    <span class="cf">end</span></span>
<span id="cb67-2423"><a href="#cb67-2423"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="null-streams">Null Streams</h1>
<p><code>NullIn()</code> is an input stream that does nothing. It is
intended to be used for testing Delegate Streams.</p>
<div class="sourceCode" id="cb68" data-startFrom="2433"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2432;"><span id="cb68-2433"><a href="#cb68-2433"></a><span class="kw">struct</span> NullIn <span class="op">&lt;:</span><span class="dt"> Stream </span><span class="kw">end</span></span>
<span id="cb68-2434"><a href="#cb68-2434"></a></span>
<span id="cb68-2435"><a href="#cb68-2435"></a><span class="fu">TransferDirection</span>(<span class="op">::</span><span class="dt">Type{NullIn}</span>) <span class="op">=</span> <span class="fu">In</span>()</span>
<span id="cb68-2436"><a href="#cb68-2436"></a></span>
<span id="cb68-2437"><a href="#cb68-2437"></a><span class="fu">transfer!</span>(io<span class="op">::</span><span class="dt">NullIn</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, n; kw<span class="op">...</span>) <span class="op">=</span> n</span>
<span id="cb68-2438"><a href="#cb68-2438"></a></span>
<span id="cb68-2439"><a href="#cb68-2439"></a></span>
<span id="cb68-2440"><a href="#cb68-2440"></a><span class="co">#=</span></span>
<span id="cb68-2441"><a href="#cb68-2441"></a><span class="co">FIXME</span></span>
<span id="cb68-2442"><a href="#cb68-2442"></a><span class="co">include(&quot;wrap.jl&quot;)</span></span></code></pre></div>
<p><code>@delegate_io f</code> creates wrapper methods for function
<code>f</code>. A separate method is created with a specific 2nd
argument type for each 2nd argument type used in pre-existing methods of
<code>f</code> (to avoid method selection ambiguity). e.g.</p>
<pre><code>f(io::IODelegate; kw...) = f(unwrap(io); kw...)
f(io::IODelegate, a2::T, a...; kw...) = f(unwrap(io), a2, a...; kw...)</code></pre>
<div class="sourceCode" id="cb70" data-startFrom="2453"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2452;"><span id="cb70-2453"><a href="#cb70-2453"></a><span class="kw">macro</span> <span class="fu">delegate_io</span>(f, <span class="co">#= FIXME ---&gt; =#</span> D<span class="op">=</span>FullInDelegate, u<span class="op">=</span>unwrap)</span>
<span id="cb70-2454"><a href="#cb70-2454"></a>    methods <span class="op">=</span> [</span>
<span id="cb70-2455"><a href="#cb70-2455"></a>      <span class="fu">esc</span>(<span class="op">:</span>(( <span class="op">$</span><span class="fu">f</span>(io<span class="op">::</span><span class="dt">$D              </span>; k<span class="op">...</span>) <span class="op">=</span> <span class="op">$</span><span class="fu">f</span>(<span class="op">$</span><span class="fu">u</span>(io)          ; k<span class="op">...</span>)   ))),</span>
<span id="cb70-2456"><a href="#cb70-2456"></a>    ( <span class="fu">esc</span>(<span class="op">:</span>(( <span class="op">$</span><span class="fu">f</span>(io<span class="op">::</span><span class="dt">$D</span>, a<span class="op">::</span><span class="dt">$T</span>, aa<span class="op">...</span>; k<span class="op">...</span>) <span class="op">=</span> <span class="op">$</span><span class="fu">f</span>(<span class="op">$</span><span class="fu">u</span>(io), a, aa<span class="op">...</span>; k<span class="op">...</span>)   )))</span>
<span id="cb70-2457"><a href="#cb70-2457"></a>                         for T <span class="kw">in</span> <span class="fu">arg2_types</span>(<span class="bu">Main</span>.<span class="fu">eval</span>(<span class="op">:</span>(<span class="op">$</span>f)))</span>
<span id="cb70-2458"><a href="#cb70-2458"></a>    )<span class="op">...</span>]</span>
<span id="cb70-2459"><a href="#cb70-2459"></a>    (m<span class="op">-&gt;</span><span class="pp">@debug</span> m).(methods)</span>
<span id="cb70-2460"><a href="#cb70-2460"></a>    <span class="fu">Expr</span>(<span class="op">:</span>block, methods<span class="op">...</span>)</span>
<span id="cb70-2461"><a href="#cb70-2461"></a><span class="kw">end</span></span>
<span id="cb70-2462"><a href="#cb70-2462"></a></span>
<span id="cb70-2463"><a href="#cb70-2463"></a></span>
<span id="cb70-2464"><a href="#cb70-2464"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.read!</span>
<span id="cb70-2465"><a href="#cb70-2465"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readuntil</span>
<span id="cb70-2466"><a href="#cb70-2466"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readline</span>
<span id="cb70-2467"><a href="#cb70-2467"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.countlines</span>
<span id="cb70-2468"><a href="#cb70-2468"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.eachline</span>
<span id="cb70-2469"><a href="#cb70-2469"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readeach</span>
<span id="cb70-2470"><a href="#cb70-2470"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.unsafe_read</span>
<span id="cb70-2471"><a href="#cb70-2471"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.peek</span>
<span id="cb70-2472"><a href="#cb70-2472"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.readavailable</span>
<span id="cb70-2473"><a href="#cb70-2473"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.mark</span>
<span id="cb70-2474"><a href="#cb70-2474"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.ismarked</span>
<span id="cb70-2475"><a href="#cb70-2475"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.unmark</span>
<span id="cb70-2476"><a href="#cb70-2476"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.reset</span>
<span id="cb70-2477"><a href="#cb70-2477"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.seek</span>
<span id="cb70-2478"><a href="#cb70-2478"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.position</span>
<span id="cb70-2479"><a href="#cb70-2479"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.seekend</span>
<span id="cb70-2480"><a href="#cb70-2480"></a><span class="pp">@delegate_io</span> <span class="bu">Base</span>.seekstart</span>
<span id="cb70-2481"><a href="#cb70-2481"></a><span class="op">=</span><span class="co">#</span></span></code></pre></div>
<h1 id="buffered-streams">Buffered Streams</h1>
<p>Generic type for Buffered Input Wrappers.</p>
<p>See concrete types <code>BufferedInput</code> and
<code>LazyBufferedInput</code> below.</p>
<div class="sourceCode" id="cb71" data-startFrom="2492"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2491;"><span id="cb71-2492"><a href="#cb71-2492"></a><span class="kw">abstract type</span> GenericBufferedInput{T} <span class="op">&lt;:</span><span class="dt"> Stream </span><span class="kw">end</span></span>
<span id="cb71-2493"><a href="#cb71-2493"></a></span>
<span id="cb71-2494"><a href="#cb71-2494"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">show</span>(io<span class="op">::</span><span class="dt">IO</span>, s<span class="op">::</span><span class="dt">GenericBufferedInput{T}</span>) <span class="kw">where</span> T</span>
<span id="cb71-2495"><a href="#cb71-2495"></a>    <span class="fu">print</span>(io, <span class="st">&quot;GenericBufferedInput{&quot;</span>, T, <span class="st">&quot;}(&quot;</span>, <span class="fu">bytesavailable</span>(s.buffer), <span class="st">&quot;)&quot;</span>)</span>
<span id="cb71-2496"><a href="#cb71-2496"></a><span class="kw">end</span></span>
<span id="cb71-2497"><a href="#cb71-2497"></a></span>
<span id="cb71-2498"><a href="#cb71-2498"></a><span class="fu">StreamDelegation</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">DelegatedToSubStream</span>()</span>
<span id="cb71-2499"><a href="#cb71-2499"></a></span>
<span id="cb71-2500"><a href="#cb71-2500"></a><span class="fu">TransferCost</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">LowTransferCost</span>()</span>
<span id="cb71-2501"><a href="#cb71-2501"></a></span>
<span id="cb71-2502"><a href="#cb71-2502"></a><span class="fu">ReadUnit</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">ReadUnit</span><span class="dt">{:Byte}</span>()</span>
<span id="cb71-2503"><a href="#cb71-2503"></a></span>
<span id="cb71-2504"><a href="#cb71-2504"></a><span class="fu">PeekSupport</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">Peekable</span>()</span>
<span id="cb71-2505"><a href="#cb71-2505"></a></span>
<span id="cb71-2506"><a href="#cb71-2506"></a><span class="fu">Availability</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">Availability</span><span class="dt">{:Partial}</span>()</span>
<span id="cb71-2507"><a href="#cb71-2507"></a></span>
<span id="cb71-2508"><a href="#cb71-2508"></a><span class="fu">StreamIndexing</span>(<span class="op">::</span><span class="dt">Type{&lt;:GenericBufferedInput}</span>) <span class="op">=</span> <span class="fu">NotIndexable</span>()</span>
<span id="cb71-2509"><a href="#cb71-2509"></a></span>
<span id="cb71-2510"><a href="#cb71-2510"></a><span class="kw">function</span> <span class="fu">buffered_in_warning</span>(stream)</span>
<span id="cb71-2511"><a href="#cb71-2511"></a>    <span class="cf">if</span> <span class="fu">ReadUnit</span>(stream) <span class="op">!=</span> <span class="fu">ReadUnit</span><span class="dt">{:Byte}</span>()</span>
<span id="cb71-2512"><a href="#cb71-2512"></a>        <span class="pp">@warn</span> <span class="st">&quot;Wrapping </span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st"> with `BufferedInput` causes &quot;</span> <span class="op">*</span></span>
<span id="cb71-2513"><a href="#cb71-2513"></a>              <span class="st">&quot;the </span><span class="sc">$</span>(<span class="fu">ReadUnit</span>(stream))<span class="st"> trait to be ignored!&quot;</span></span>
<span id="cb71-2514"><a href="#cb71-2514"></a>    <span class="cf">end</span></span>
<span id="cb71-2515"><a href="#cb71-2515"></a>    <span class="cf">if</span> <span class="fu">TransferCost</span>(stream) <span class="op">==</span> <span class="fu">LowTransferCost</span>()</span>
<span id="cb71-2516"><a href="#cb71-2516"></a>        <span class="pp">@warn</span> <span class="st">&quot;</span><span class="sc">$</span>(<span class="fu">typeof</span>(stream))<span class="st"> already has LowTransfterCost. &quot;</span> <span class="op">*</span></span>
<span id="cb71-2517"><a href="#cb71-2517"></a>              <span class="st">&quot;Wrapping with `BufferedInput` may degrade performance.&quot;</span></span>
<span id="cb71-2518"><a href="#cb71-2518"></a>    <span class="cf">end</span></span>
<span id="cb71-2519"><a href="#cb71-2519"></a><span class="kw">end</span></span>
<span id="cb71-2520"><a href="#cb71-2520"></a></span>
<span id="cb71-2521"><a href="#cb71-2521"></a></span>
<span id="cb71-2522"><a href="#cb71-2522"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">close</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>)</span>
<span id="cb71-2523"><a href="#cb71-2523"></a>    <span class="fu">take!</span>(s.buffer)</span>
<span id="cb71-2524"><a href="#cb71-2524"></a>    <span class="bu">Base</span>.<span class="fu">close</span>(s.stream)</span>
<span id="cb71-2525"><a href="#cb71-2525"></a><span class="kw">end</span></span></code></pre></div>
<p>Size of the internal buffer.</p>
<div class="sourceCode" id="cb72" data-startFrom="2531"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2530;"><span id="cb72-2531"><a href="#cb72-2531"></a><span class="fu">buffer_size</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>) <span class="op">=</span> s.buffer_size</span></code></pre></div>
<p>Buffer ~1 second of data by default.</p>
<div class="sourceCode" id="cb73" data-startFrom="2537"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2536;"><span id="cb73-2537"><a href="#cb73-2537"></a><span class="fu">default_buffer_size</span>(stream) <span class="op">=</span> <span class="fu">DataRate</span>(stream)</span></code></pre></div>
<p>Transfer bytes from the wrapped IO to the internal buffer.</p>
<div class="sourceCode" id="cb74" data-startFrom="2543"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2542;"><span id="cb74-2543"><a href="#cb74-2543"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">refill_internal_buffer</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>,</span>
<span id="cb74-2544"><a href="#cb74-2544"></a>                                    n<span class="op">=</span>s.buffer_size; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb74-2545"><a href="#cb74-2545"></a>    <span class="co"># If needed, expand the buffer.</span></span>
<span id="cb74-2546"><a href="#cb74-2546"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb74-2547"><a href="#cb74-2547"></a>    <span class="pp">@assert</span> sbuf.append</span>
<span id="cb74-2548"><a href="#cb74-2548"></a>    <span class="bu">Base</span>.<span class="fu">ensureroom</span>(sbuf, n)</span>
<span id="cb74-2549"><a href="#cb74-2549"></a>    <span class="fu">checkbounds</span>(sbuf.data, sbuf.size<span class="op">+</span>n)</span>
<span id="cb74-2550"><a href="#cb74-2550"></a></span>
<span id="cb74-2551"><a href="#cb74-2551"></a>    <span class="co"># Transfer from the stream to the buffer.</span></span>
<span id="cb74-2552"><a href="#cb74-2552"></a>    p <span class="op">=</span> <span class="fu">pointer</span>(sbuf.data, sbuf.size<span class="op">+</span><span class="fl">1</span>)</span>
<span id="cb74-2553"><a href="#cb74-2553"></a>    n <span class="op">=</span> GC.<span class="pp">@preserve</span> sbuf <span class="fu">transfer!</span>(s.stream, p, n; deadline)</span>
<span id="cb74-2554"><a href="#cb74-2554"></a>    sbuf.size <span class="op">+=</span> n</span>
<span id="cb74-2555"><a href="#cb74-2555"></a>    <span class="cn">nothing</span></span>
<span id="cb74-2556"><a href="#cb74-2556"></a><span class="kw">end</span></span>
<span id="cb74-2557"><a href="#cb74-2557"></a></span>
<span id="cb74-2558"><a href="#cb74-2558"></a></span>
<span id="cb74-2559"><a href="#cb74-2559"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">pump!</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb74-2560"><a href="#cb74-2560"></a>    <span class="fu">refill_internal_buffer</span>(s; deadline)</span>
<span id="cb74-2561"><a href="#cb74-2561"></a><span class="kw">end</span></span>
<span id="cb74-2562"><a href="#cb74-2562"></a></span>
<span id="cb74-2563"><a href="#cb74-2563"></a></span>
<span id="cb74-2564"><a href="#cb74-2564"></a><span class="kw">function</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb74-2565"><a href="#cb74-2565"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb74-2566"><a href="#cb74-2566"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(sbuf) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb74-2567"><a href="#cb74-2567"></a>        <span class="fu">refill_internal_buffer</span>(s; deadline)</span>
<span id="cb74-2568"><a href="#cb74-2568"></a>    <span class="cf">end</span></span>
<span id="cb74-2569"><a href="#cb74-2569"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(sbuf) <span class="op">!=</span> <span class="fl">0</span></span>
<span id="cb74-2570"><a href="#cb74-2570"></a>        <span class="cf">return</span> <span class="fu">read</span>(sbuf, <span class="dt">UInt8</span>)</span>
<span id="cb74-2571"><a href="#cb74-2571"></a>    <span class="cf">end</span></span>
<span id="cb74-2572"><a href="#cb74-2572"></a>    <span class="pp">@invoke</span> <span class="fu">readbyte</span>(s<span class="op">::</span><span class="dt">Stream</span>; deadline)</span>
<span id="cb74-2573"><a href="#cb74-2573"></a><span class="kw">end</span></span>
<span id="cb74-2574"><a href="#cb74-2574"></a></span>
<span id="cb74-2575"><a href="#cb74-2575"></a></span>
<span id="cb74-2576"><a href="#cb74-2576"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">peek</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>, <span class="op">::</span><span class="dt">Type{T}</span>; timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="kw">where</span> T</span>
<span id="cb74-2577"><a href="#cb74-2577"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb74-2578"><a href="#cb74-2578"></a>    <span class="fu">wait_for_n_bytes</span>(<span class="fu">sizeof</span>(T); timeout)</span>
<span id="cb74-2579"><a href="#cb74-2579"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&lt;</span> <span class="fu">sizeof</span>(T)</span>
<span id="cb74-2580"><a href="#cb74-2580"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="cn">nothing</span></span>
<span id="cb74-2581"><a href="#cb74-2581"></a>    <span class="cf">end</span></span>
<span id="cb74-2582"><a href="#cb74-2582"></a>    <span class="fu">peek</span>(s.buffer, T)</span>
<span id="cb74-2583"><a href="#cb74-2583"></a><span class="kw">end</span></span>
<span id="cb74-2584"><a href="#cb74-2584"></a></span>
<span id="cb74-2585"><a href="#cb74-2585"></a></span>
<span id="cb74-2586"><a href="#cb74-2586"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">position</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>)</span>
<span id="cb74-2587"><a href="#cb74-2587"></a>    <span class="fu">position</span>(s.stream) <span class="op">-</span> <span class="fu">bytesavailable</span>(s.buffer)</span>
<span id="cb74-2588"><a href="#cb74-2588"></a><span class="kw">end</span></span>
<span id="cb74-2589"><a href="#cb74-2589"></a></span>
<span id="cb74-2590"><a href="#cb74-2590"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readline</span>(s<span class="op">::</span><span class="dt">GenericBufferedInput</span>; keep<span class="op">=</span><span class="cn">false</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb74-2591"><a href="#cb74-2591"></a>    <span class="fu">_readline</span>(s, <span class="fu">ReadUnit</span><span class="dt">{:Byte}</span>(); keep, timeout)</span>
<span id="cb74-2592"><a href="#cb74-2592"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="buffered-input">Buffered Input</h2>
<pre><code>BufferedInput(stream; [buffer_size]) -&gt; Stream</code></pre>
<p>Create a wrapper around <code>stream</code> to buffer input
transfers.</p>
<p>The wrapper will try to read <code>buffer_size</code> bytes into its
buffer every time it transfers data from <code>stream</code>.</p>
<p>The default <code>buffer_size</code> depends on
<code>IOTratis.DataRate(stream)</code>.</p>
<p><code>stream</code> must not be used directly after the wrapper is
created.</p>
<div class="sourceCode" id="cb76" data-startFrom="2609"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2608;"><span id="cb76-2609"><a href="#cb76-2609"></a><span class="kw">struct</span> BufferedInput{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> GenericBufferedInput{T}</span></span>
<span id="cb76-2610"><a href="#cb76-2610"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb76-2611"><a href="#cb76-2611"></a>    buffer<span class="op">::</span><span class="dt">IOBuffer</span></span>
<span id="cb76-2612"><a href="#cb76-2612"></a>    buffer_size<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb76-2613"><a href="#cb76-2613"></a>    <span class="kw">function</span> <span class="fu">BufferedInput</span>(stream<span class="op">::</span><span class="dt">T</span>; buffer_size<span class="op">=</span><span class="fu">default_buffer_size</span>(stream)) <span class="kw">where</span> T</span>
<span id="cb76-2614"><a href="#cb76-2614"></a>        <span class="pp">@db_not_tested</span></span>
<span id="cb76-2615"><a href="#cb76-2615"></a>        <span class="pp">@require</span> <span class="fu">TransferDirection</span>(stream) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb76-2616"><a href="#cb76-2616"></a>        <span class="fu">buffered_in_warning</span>(stream)</span>
<span id="cb76-2617"><a href="#cb76-2617"></a>        <span class="fu">new</span><span class="dt">{T}</span>(stream, <span class="fu">PipeBuffer</span>(), buffer_size)</span>
<span id="cb76-2618"><a href="#cb76-2618"></a>    <span class="kw">end</span></span>
<span id="cb76-2619"><a href="#cb76-2619"></a><span class="kw">end</span></span>
<span id="cb76-2620"><a href="#cb76-2620"></a></span>
<span id="cb76-2621"><a href="#cb76-2621"></a><span class="fu">TransferSize</span>(<span class="op">::</span><span class="dt">Type{BufferedInput{T}}</span>) <span class="kw">where</span> T <span class="op">=</span> <span class="fu">TransferSize</span><span class="dt">{:Limited}</span>()</span>
<span id="cb76-2622"><a href="#cb76-2622"></a></span>
<span id="cb76-2623"><a href="#cb76-2623"></a><span class="fu">Cursors</span>(<span class="op">::</span><span class="dt">Type{&lt;:BufferedInput}</span>) <span class="op">=</span> <span class="fu">Cursors</span><span class="dt">{Missing}</span>()</span>
<span id="cb76-2624"><a href="#cb76-2624"></a></span>
<span id="cb76-2625"><a href="#cb76-2625"></a><span class="fu">max_transfer_size</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>) <span class="op">=</span> s.buffer_size</span></code></pre></div>
<p>The non-buffered method returns zero if there are not enough bytes
available to transfer a whole item (<code>ioelsize</code>). This method
refills the internal buffer if there are less than <code>ioelsize</code>
bytes available. Note that <code>refill_internal_buffer</code> may still
not yield enough bytes. However, calling it here ensures that the
enclosing retry loop will eventually get the data it needs.</p>
<div class="sourceCode" id="cb77" data-startFrom="2636"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2635;"><span id="cb77-2636"><a href="#cb77-2636"></a><span class="pp">@db</span> <span class="fl">2</span> <span class="kw">function</span> <span class="fu">_attempt_transfer</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>,</span>
<span id="cb77-2637"><a href="#cb77-2637"></a>                                 buf, interface<span class="op">::</span><span class="dt">IsItemPtr</span>,</span>
<span id="cb77-2638"><a href="#cb77-2638"></a>                                 stream_i, buffer_i<span class="op">::</span><span class="dt">UInt</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb77-2639"><a href="#cb77-2639"></a>    <span class="pp">@assert</span> <span class="fu">ioelsize</span>(buf) <span class="op">&gt;</span> <span class="fl">1</span></span>
<span id="cb77-2640"><a href="#cb77-2640"></a>    <span class="pp">@assert</span> <span class="fu">ioelsize</span>(buf) <span class="op">&lt;</span> s.buffer_size</span>
<span id="cb77-2641"><a href="#cb77-2641"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb77-2642"><a href="#cb77-2642"></a></span>
<span id="cb77-2643"><a href="#cb77-2643"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&lt;</span> <span class="fu">ioelsize</span>(buf)</span>
<span id="cb77-2644"><a href="#cb77-2644"></a>        <span class="pp">@db_not_tested</span></span>
<span id="cb77-2645"><a href="#cb77-2645"></a>        <span class="fu">refill_internal_buffer</span>(s; deadline<span class="op">=</span><span class="fl">0</span>) <span class="co"># FIXME ?)</span></span>
<span id="cb77-2646"><a href="#cb77-2646"></a>    <span class="cf">end</span></span>
<span id="cb77-2647"><a href="#cb77-2647"></a></span>
<span id="cb77-2648"><a href="#cb77-2648"></a>    <span class="pp">@invoke</span> <span class="fu">_attempt_transfer</span>(s<span class="op">::</span><span class="dt">Stream</span>,</span>
<span id="cb77-2649"><a href="#cb77-2649"></a>                              buf, interface<span class="op">::</span><span class="dt">IsItemPtr</span>,</span>
<span id="cb77-2650"><a href="#cb77-2650"></a>                              stream_i, buffer_i<span class="op">::</span><span class="dt">UInt</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb77-2651"><a href="#cb77-2651"></a><span class="kw">end</span></span>
<span id="cb77-2652"><a href="#cb77-2652"></a></span>
<span id="cb77-2653"><a href="#cb77-2653"></a></span>
<span id="cb77-2654"><a href="#cb77-2654"></a></span>
<span id="cb77-2655"><a href="#cb77-2655"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">bytesavailable</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>) </span>
<span id="cb77-2656"><a href="#cb77-2656"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb77-2657"><a href="#cb77-2657"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb77-2658"><a href="#cb77-2658"></a>    <span class="pp">@db</span> <span class="cf">return</span> <span class="fu">bytesavailable</span>(s.buffer) </span>
<span id="cb77-2659"><a href="#cb77-2659"></a><span class="kw">end</span></span>
<span id="cb77-2660"><a href="#cb77-2660"></a></span>
<span id="cb77-2661"><a href="#cb77-2661"></a></span>
<span id="cb77-2662"><a href="#cb77-2662"></a></span>
<span id="cb77-2663"><a href="#cb77-2663"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">unsafe_transfer!</span>(s<span class="op">::</span><span class="dt">BufferedInput</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>,</span>
<span id="cb77-2664"><a href="#cb77-2664"></a>                              stream_offset<span class="op">::</span><span class="dt">Missing</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb77-2665"><a href="#cb77-2665"></a></span>
<span id="cb77-2666"><a href="#cb77-2666"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb77-2667"><a href="#cb77-2667"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb77-2668"><a href="#cb77-2668"></a>    <span class="co"># If there are not enough bytes in `sbuf`, read more from the wrapped stream.</span></span>
<span id="cb77-2669"><a href="#cb77-2669"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(sbuf) <span class="op">&lt;</span> n</span>
<span id="cb77-2670"><a href="#cb77-2670"></a>        <span class="pp">@db_not_tested</span></span>
<span id="cb77-2671"><a href="#cb77-2671"></a>        <span class="fu">refill_internal_buffer</span>(s)</span>
<span id="cb77-2672"><a href="#cb77-2672"></a>    <span class="cf">end</span></span>
<span id="cb77-2673"><a href="#cb77-2673"></a></span>
<span id="cb77-2674"><a href="#cb77-2674"></a>    <span class="co"># Read available bytes from `sbuf` into the caller&#39;s `buffer`.</span></span>
<span id="cb77-2675"><a href="#cb77-2675"></a>    n <span class="op">=</span> <span class="fu">min</span>(n, <span class="fu">bytesavailable</span>(sbuf))</span>
<span id="cb77-2676"><a href="#cb77-2676"></a>    <span class="fu">unsafe_read</span>(sbuf, buf, n)</span>
<span id="cb77-2677"><a href="#cb77-2677"></a>    <span class="pp">@db</span> <span class="cf">return</span> n</span>
<span id="cb77-2678"><a href="#cb77-2678"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="lazy-buffered-input">Lazy Buffered Input</h2>
<pre><code>LazyBufferedInput(stream; [buffer_size]) -&gt; Stream</code></pre>
<p>Create a wrapper around <code>stream</code> to buffer input
transfers.</p>
<p>The internal buffer is only used when a small transfer is attempted
or if <code>peek</code> is called. Most reads are fulfilled directly
from the underling stream. This avoids the overhead of double buffering
in situations where there is an occasional need to read one byte at a
time (e.g. <code>readuntil()</code>) but most reads are already of a
reasonable size.</p>
<p>The default <code>buffer_size</code> depends on
<code>IOTratis.DataRate(io)</code>.</p>
<p><code>stream</code> must not be used directly after the wrapper is
created.</p>
<div class="sourceCode" id="cb79" data-startFrom="2700"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2699;"><span id="cb79-2700"><a href="#cb79-2700"></a><span class="kw">struct</span> LazyBufferedInput{T<span class="op">&lt;:</span><span class="dt">Stream</span>} <span class="op">&lt;:</span><span class="dt"> GenericBufferedInput{T}</span></span>
<span id="cb79-2701"><a href="#cb79-2701"></a>    stream<span class="op">::</span><span class="dt">T</span></span>
<span id="cb79-2702"><a href="#cb79-2702"></a>    buffer<span class="op">::</span><span class="dt">IOBuffer</span></span>
<span id="cb79-2703"><a href="#cb79-2703"></a>    buffer_size<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb79-2704"><a href="#cb79-2704"></a>    <span class="kw">function</span> <span class="fu">LazyBufferedInput</span>(s<span class="op">::</span><span class="dt">T</span>; buffer_size<span class="op">=</span><span class="fu">default_buffer_size</span>(s)) <span class="kw">where</span> T</span>
<span id="cb79-2705"><a href="#cb79-2705"></a>        <span class="pp">@require</span> <span class="fu">TransferDirection</span>(s) <span class="op">==</span> <span class="fu">In</span>()</span>
<span id="cb79-2706"><a href="#cb79-2706"></a>        <span class="fu">buffered_in_warning</span>(s)</span>
<span id="cb79-2707"><a href="#cb79-2707"></a>        <span class="fu">new</span><span class="dt">{T}</span>(s, <span class="fu">PipeBuffer</span>(), buffer_size)</span>
<span id="cb79-2708"><a href="#cb79-2708"></a>    <span class="kw">end</span></span>
<span id="cb79-2709"><a href="#cb79-2709"></a><span class="kw">end</span></span>
<span id="cb79-2710"><a href="#cb79-2710"></a></span>
<span id="cb79-2711"><a href="#cb79-2711"></a></span>
<span id="cb79-2712"><a href="#cb79-2712"></a></span>
<span id="cb79-2713"><a href="#cb79-2713"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">bytesavailable</span>(s<span class="op">::</span><span class="dt">LazyBufferedInput</span>)</span>
<span id="cb79-2714"><a href="#cb79-2714"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb79-2715"><a href="#cb79-2715"></a>    n <span class="op">=</span> <span class="fu">bytesavailable</span>(s.buffer)</span>
<span id="cb79-2716"><a href="#cb79-2716"></a>    <span class="cf">if</span> <span class="fu">availability_is_known</span>(s.stream)</span>
<span id="cb79-2717"><a href="#cb79-2717"></a>        n <span class="op">+=</span> <span class="fu">bytesavailable</span>(s.stream)</span>
<span id="cb79-2718"><a href="#cb79-2718"></a>    <span class="cf">end</span></span>
<span id="cb79-2719"><a href="#cb79-2719"></a>    <span class="pp">@db</span> <span class="cf">return</span> n</span>
<span id="cb79-2720"><a href="#cb79-2720"></a><span class="kw">end</span></span>
<span id="cb79-2721"><a href="#cb79-2721"></a></span>
<span id="cb79-2722"><a href="#cb79-2722"></a></span>
<span id="cb79-2723"><a href="#cb79-2723"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">unsafe_transfer!</span>(s<span class="op">::</span><span class="dt">LazyBufferedInput</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>,</span>
<span id="cb79-2724"><a href="#cb79-2724"></a>                              stream_offset<span class="op">::</span><span class="dt">Missing</span>, n<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb79-2725"><a href="#cb79-2725"></a></span>
<span id="cb79-2726"><a href="#cb79-2726"></a>    <span class="co"># First take bytes from the buffer.</span></span>
<span id="cb79-2727"><a href="#cb79-2727"></a>    sbuf <span class="op">=</span> s.buffer</span>
<span id="cb79-2728"><a href="#cb79-2728"></a>    count <span class="op">=</span> <span class="fu">bytesavailable</span>(sbuf)</span>
<span id="cb79-2729"><a href="#cb79-2729"></a>    <span class="cf">if</span> count <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb79-2730"><a href="#cb79-2730"></a>        count <span class="op">=</span> <span class="fu">min</span>(count, n)</span>
<span id="cb79-2731"><a href="#cb79-2731"></a>        <span class="fu">unsafe_read</span>(sbuf, buf, count)</span>
<span id="cb79-2732"><a href="#cb79-2732"></a>    <span class="cf">end</span></span>
<span id="cb79-2733"><a href="#cb79-2733"></a></span>
<span id="cb79-2734"><a href="#cb79-2734"></a>    <span class="co"># Then read from the wrapped IO.</span></span>
<span id="cb79-2735"><a href="#cb79-2735"></a>    <span class="cf">if</span> n <span class="op">&gt;</span> count</span>
<span id="cb79-2736"><a href="#cb79-2736"></a>        count <span class="op">+=</span> <span class="fu">unsafe_transfer!</span>(s.stream, buf <span class="op">+</span> count, stream_offset, n <span class="op">-</span> count)</span>
<span id="cb79-2737"><a href="#cb79-2737"></a>    <span class="cf">end</span></span>
<span id="cb79-2738"><a href="#cb79-2738"></a></span>
<span id="cb79-2739"><a href="#cb79-2739"></a>    <span class="pp">@ensure</span> count <span class="op">&lt;=</span> n</span>
<span id="cb79-2740"><a href="#cb79-2740"></a>    <span class="pp">@db</span> <span class="cf">return</span> count</span>
<span id="cb79-2741"><a href="#cb79-2741"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="base.io-interface">Base.IO Interface</h1>
<div class="sourceCode" id="cb80" data-startFrom="2747"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2746;"><span id="cb80-2747"><a href="#cb80-2747"></a><span class="bu">Base</span>.<span class="fu">isreadable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb80-2748"><a href="#cb80-2748"></a><span class="bu">Base</span>.<span class="fu">iswritable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">is_output</span>(io.stream)</span>
<span id="cb80-2749"><a href="#cb80-2749"></a><span class="bu">Base</span>.<span class="fu">isopen</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">isopen</span>(io.stream)</span>
<span id="cb80-2750"><a href="#cb80-2750"></a><span class="bu">Base</span>.<span class="fu">close</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">close</span>(io.stream)</span>
<span id="cb80-2751"><a href="#cb80-2751"></a><span class="bu">Base</span>.<span class="fu">bytesavailable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">bytesavailable</span>(io.stream)</span>
<span id="cb80-2752"><a href="#cb80-2752"></a><span class="bu">Base</span>.<span class="fu">position</span>(io<span class="op">::</span><span class="dt">BaseIO</span>) <span class="op">=</span> <span class="fu">position</span>(io.stream)</span>
<span id="cb80-2753"><a href="#cb80-2753"></a><span class="bu">Base</span>.<span class="fu">eof</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span></span>
<span id="cb80-2754"><a href="#cb80-2754"></a>    <span class="fu">eof</span>(io.stream; deadline, timeout)</span></code></pre></div>
<h2 id="function-eof">Function <code>eof</code></h2>
<p><code>eof</code> is specialised on Total Size.</p>
<div class="sourceCode" id="cb81" data-startFrom="2762"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2761;"><span id="cb81-2762"><a href="#cb81-2762"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">eof</span>(s<span class="op">::</span><span class="dt">Stream</span>; deadline<span class="op">=</span><span class="cn">Inf</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb81-2763"><a href="#cb81-2763"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb81-2764"><a href="#cb81-2764"></a>    <span class="cf">if</span> !<span class="fu">isopen</span>(s)</span>
<span id="cb81-2765"><a href="#cb81-2765"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="cn">true</span></span>
<span id="cb81-2766"><a href="#cb81-2766"></a>    <span class="cf">end</span></span>
<span id="cb81-2767"><a href="#cb81-2767"></a>    deadline <span class="op">=</span> <span class="fu">deadline_or_timeout</span>(deadline, timeout)</span>
<span id="cb81-2768"><a href="#cb81-2768"></a>    <span class="fu">_eof</span>(s, <span class="fu">Availability</span>(s); deadline)</span>
<span id="cb81-2769"><a href="#cb81-2769"></a><span class="kw">end</span></span>
<span id="cb81-2770"><a href="#cb81-2770"></a></span>
<span id="cb81-2771"><a href="#cb81-2771"></a></span>
<span id="cb81-2772"><a href="#cb81-2772"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_eof</span>(s, <span class="op">::</span><span class="dt">Availability{:Unknown}</span>; deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb81-2773"><a href="#cb81-2773"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb81-2774"><a href="#cb81-2774"></a>    <span class="pp">@dblock</span> s <span class="fu">wait</span>(s; deadline)</span>
<span id="cb81-2775"><a href="#cb81-2775"></a>    <span class="cf">return</span> <span class="cn">false</span></span>
<span id="cb81-2776"><a href="#cb81-2776"></a><span class="kw">end</span></span>
<span id="cb81-2777"><a href="#cb81-2777"></a></span>
<span id="cb81-2778"><a href="#cb81-2778"></a></span>
<span id="cb81-2779"><a href="#cb81-2779"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_eof</span>(s, <span class="op">::</span><span class="dt">AnyAvailability</span>; deadline<span class="op">::</span><span class="dt">Float64</span>)</span>
<span id="cb81-2780"><a href="#cb81-2780"></a>    <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb81-2781"><a href="#cb81-2781"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="cn">false</span></span>
<span id="cb81-2782"><a href="#cb81-2782"></a>    <span class="cf">end</span></span>
<span id="cb81-2783"><a href="#cb81-2783"></a>    <span class="pp">@db</span> deadline</span>
<span id="cb81-2784"><a href="#cb81-2784"></a>    <span class="co"># VV handled by isfinished ?</span></span></code></pre></div>
<h1 id="if-length_is_knowns-bytesremainings-0">if length_is_known(s)
&amp;&amp; bytesremaining(s) == 0</h1>
<h1 id="db-return-true"><span class="citation"
data-cites="db">@db</span> return true</h1>
<h1 id="end">end</h1>
<div class="sourceCode" id="cb82" data-startFrom="2788"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2787;"><span id="cb82-2788"><a href="#cb82-2788"></a>    <span class="cf">while</span> <span class="fu">isopen</span>(s) <span class="op">&amp;&amp;</span> !<span class="fu">isfinished</span>(s) <span class="op">&amp;&amp;</span> <span class="fu">time</span>() <span class="op">&lt;</span> deadline</span>
<span id="cb82-2789"><a href="#cb82-2789"></a>        <span class="fu">pump!</span>(s; deadline)</span>
<span id="cb82-2790"><a href="#cb82-2790"></a>        <span class="pp">@dblock</span> s <span class="cf">begin</span></span>
<span id="cb82-2791"><a href="#cb82-2791"></a>            <span class="cf">if</span> <span class="fu">bytesavailable</span>(s) <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb82-2792"><a href="#cb82-2792"></a>                <span class="pp">@db</span> <span class="cf">return</span> <span class="cn">false</span></span>
<span id="cb82-2793"><a href="#cb82-2793"></a>            <span class="cf">end</span></span>
<span id="cb82-2794"><a href="#cb82-2794"></a>            <span class="fu">wait</span>(s; deadline)</span>
<span id="cb82-2795"><a href="#cb82-2795"></a>        <span class="cf">end</span></span>
<span id="cb82-2796"><a href="#cb82-2796"></a>    <span class="cf">end</span></span>
<span id="cb82-2797"><a href="#cb82-2797"></a>    <span class="pp">@db</span> <span class="cf">return</span> <span class="cn">true</span></span>
<span id="cb82-2798"><a href="#cb82-2798"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readio-t">Function <code>read(io, T)</code></h2>
<div class="sourceCode" id="cb83" data-startFrom="2802"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2801;"><span id="cb83-2802"><a href="#cb83-2802"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, <span class="op">::</span><span class="dt">Type{UInt8}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb83-2803"><a href="#cb83-2803"></a>    x <span class="op">=</span> <span class="fu">readbyte</span>(io.stream; deadline)</span>
<span id="cb83-2804"><a href="#cb83-2804"></a>    x <span class="op">!=</span> <span class="cn">nothing</span> <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">EOFError</span>())</span>
<span id="cb83-2805"><a href="#cb83-2805"></a>    <span class="cf">return</span> x</span>
<span id="cb83-2806"><a href="#cb83-2806"></a><span class="kw">end</span></span>
<span id="cb83-2807"><a href="#cb83-2807"></a></span>
<span id="cb83-2808"><a href="#cb83-2808"></a><span class="co">#Base.read(io::BaseIO, ::Type{T}; timeout) where T =</span></span></code></pre></div>
<h1 id="readio-a-deadline-time-timeout">read(io, a…; deadline = time() +
timeout)</h1>
<p>Read as String.<br />
Wrap with <code>TimeoutStream</code> if timeout is requested.</p>
<div class="sourceCode" id="cb84" data-startFrom="2816"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2815;"><span id="cb84-2816"><a href="#cb84-2816"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, <span class="op">::</span><span class="dt">Type{String}</span>; deadline<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb84-2817"><a href="#cb84-2817"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb84-2818"><a href="#cb84-2818"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; deadline)</span>
<span id="cb84-2819"><a href="#cb84-2819"></a>    <span class="fu">String</span>(<span class="fu">readall!</span>(stream))</span>
<span id="cb84-2820"><a href="#cb84-2820"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readbytes">Function <code>readbytes!</code></h2>
<div class="sourceCode" id="cb85" data-startFrom="2826"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2825;"><span id="cb85-2826"><a href="#cb85-2826"></a><span class="bu">Base</span>.<span class="fu">readbytes!</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Vector{UInt8}</span>, nbytes<span class="op">=</span><span class="fu">length</span>(buf); kw<span class="op">...</span>) <span class="op">=</span></span>
<span id="cb85-2827"><a href="#cb85-2827"></a>    <span class="fu">readbytes!</span>(io, buf, <span class="fu">UInt</span>(nbytes); kw<span class="op">...</span>)</span>
<span id="cb85-2828"><a href="#cb85-2828"></a></span>
<span id="cb85-2829"><a href="#cb85-2829"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readbytes!</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Vector{UInt8}</span>, nbytes<span class="op">::</span><span class="dt">UInt</span>;</span>
<span id="cb85-2830"><a href="#cb85-2830"></a>                         all<span class="op">::</span><span class="dt">Bool</span>=<span class="cn">true</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb85-2831"><a href="#cb85-2831"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb85-2832"><a href="#cb85-2832"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb85-2833"><a href="#cb85-2833"></a>    <span class="fu">_readbytes!</span>(stream, buf, nbytes; all)</span>
<span id="cb85-2834"><a href="#cb85-2834"></a><span class="kw">end</span></span>
<span id="cb85-2835"><a href="#cb85-2835"></a></span>
<span id="cb85-2836"><a href="#cb85-2836"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_readbytes!</span>(stream, buf, nbytes; all<span class="op">=</span><span class="cn">true</span>)</span>
<span id="cb85-2837"><a href="#cb85-2837"></a>    lb<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fu">length</span>(buf)</span>
<span id="cb85-2838"><a href="#cb85-2838"></a>    nread <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb85-2839"><a href="#cb85-2839"></a>    <span class="cf">while</span> nread <span class="op">&lt;</span> nbytes</span>
<span id="cb85-2840"><a href="#cb85-2840"></a>        <span class="pp">@assert</span> nread <span class="op">&lt;=</span> lb</span>
<span id="cb85-2841"><a href="#cb85-2841"></a>        <span class="cf">if</span> (lb <span class="op">-</span> nread) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb85-2842"><a href="#cb85-2842"></a>            lb <span class="op">=</span> lb <span class="op">==</span> <span class="fl">0</span> ? nbytes <span class="op">:</span> <span class="fu">min</span>(lb <span class="op">*</span> <span class="fl">10</span>, nbytes)</span>
<span id="cb85-2843"><a href="#cb85-2843"></a>            <span class="fu">resize!</span>(buf, lb)</span>
<span id="cb85-2844"><a href="#cb85-2844"></a>        <span class="cf">end</span></span>
<span id="cb85-2845"><a href="#cb85-2845"></a>        <span class="pp">@assert</span> lb <span class="op">&gt;</span> nread</span>
<span id="cb85-2846"><a href="#cb85-2846"></a>        n <span class="op">=</span> <span class="fu">transfer!</span>(stream <span class="op">=&gt;</span> buf, lb <span class="op">-</span> nread; buffer_i <span class="op">=</span> nread <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb85-2847"><a href="#cb85-2847"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span> <span class="op">||</span> !all</span>
<span id="cb85-2848"><a href="#cb85-2848"></a>            <span class="cf">break</span></span>
<span id="cb85-2849"><a href="#cb85-2849"></a>        <span class="cf">end</span></span>
<span id="cb85-2850"><a href="#cb85-2850"></a>        nread <span class="op">+=</span> n</span>
<span id="cb85-2851"><a href="#cb85-2851"></a>    <span class="cf">end</span></span>
<span id="cb85-2852"><a href="#cb85-2852"></a>    <span class="pp">@ensure</span> nread <span class="op">&lt;=</span> nbytes</span>
<span id="cb85-2853"><a href="#cb85-2853"></a>    <span class="pp">@db</span> <span class="cf">return</span> nread</span>
<span id="cb85-2854"><a href="#cb85-2854"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readstream">Function <code>read(stream)</code></h2>
<div class="sourceCode" id="cb86" data-startFrom="2860"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2859;"><span id="cb86-2860"><a href="#cb86-2860"></a><span class="bu">Base</span>.<span class="fu">read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; timeout<span class="op">=</span><span class="cn">Inf</span>) <span class="op">=</span> <span class="fu">readall!</span>(io.stream; timeout)</span></code></pre></div>
<h2 id="function-readstream-n">Function
<code>read(stream, n)</code></h2>
<div class="sourceCode" id="cb87" data-startFrom="2867"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2866;"><span id="cb87-2867"><a href="#cb87-2867"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, n<span class="op">::</span><span class="dt">Integer</span>; timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb87-2868"><a href="#cb87-2868"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb87-2869"><a href="#cb87-2869"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb87-2870"><a href="#cb87-2870"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb87-2871"><a href="#cb87-2871"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb87-2872"><a href="#cb87-2872"></a>    <span class="fu">transfer_n</span>(stream, buf, n)</span>
<span id="cb87-2873"><a href="#cb87-2873"></a>    <span class="cf">return</span> buf</span>
<span id="cb87-2874"><a href="#cb87-2874"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-unsafe_read">Function <code>unsafe_read</code></h2>
<p><code>unsafe_read</code> must keep trying until <code>nbytes</code>
nave been transferred.</p>
<div class="sourceCode" id="cb88" data-startFrom="2882"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2881;"><span id="cb88-2882"><a href="#cb88-2882"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">unsafe_read</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, nbytes<span class="op">::</span><span class="dt">UInt</span>;</span>
<span id="cb88-2883"><a href="#cb88-2883"></a>                          timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb88-2884"><a href="#cb88-2884"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb88-2885"><a href="#cb88-2885"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb88-2886"><a href="#cb88-2886"></a>    nread <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb88-2887"><a href="#cb88-2887"></a>    <span class="pp">@debug</span> <span class="st">&quot;Base.unsafe_read(io::BaseIO, buf::Ptr{UInt8}, nbytes::UInt)&quot;</span></span>
<span id="cb88-2888"><a href="#cb88-2888"></a>    <span class="cf">while</span> nread <span class="op">&lt;</span> nbytes</span>
<span id="cb88-2889"><a href="#cb88-2889"></a>        n <span class="op">=</span> <span class="fu">transfer!</span>(stream <span class="op">=&gt;</span> (buf <span class="op">+</span> nread), nbytes <span class="op">-</span> nread)</span>
<span id="cb88-2890"><a href="#cb88-2890"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb88-2891"><a href="#cb88-2891"></a>            <span class="pp">@db_not_tested</span></span>
<span id="cb88-2892"><a href="#cb88-2892"></a>            <span class="fu">throw</span>(<span class="fu">EOFError</span>())</span>
<span id="cb88-2893"><a href="#cb88-2893"></a>        <span class="cf">end</span></span>
<span id="cb88-2894"><a href="#cb88-2894"></a>        nread <span class="op">+=</span> n</span>
<span id="cb88-2895"><a href="#cb88-2895"></a>    <span class="cf">end</span></span>
<span id="cb88-2896"><a href="#cb88-2896"></a>    <span class="pp">@ensure</span> nread <span class="op">==</span> nbytes</span>
<span id="cb88-2897"><a href="#cb88-2897"></a>    <span class="cn">nothing</span></span>
<span id="cb88-2898"><a href="#cb88-2898"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-readavailable">Function <code>readavailable</code></h2>
<pre><code>readavailable(stream::BaseIO; [timeout=0]) -&gt; Vector{UInt8}</code></pre>
<p>Read immediately available data from a stream.</p>
<p>If <code>Availability(stream)</code> is
<code>Availability{:Unknown}()</code> the only way to know how much data
is available is to attempt a transfer.</p>
<p>Otherwise, the amount of data immediately available can be queried
using the <code>bytesavailable</code> function.</p>
<div class="sourceCode" id="cb90" data-startFrom="2915"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2914;"><span id="cb90-2915"><a href="#cb90-2915"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readavailable</span>(s<span class="op">::</span><span class="dt">Stream</span>; timeout<span class="op">=</span><span class="fl">0</span>)</span>
<span id="cb90-2916"><a href="#cb90-2916"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(s)</span>
<span id="cb90-2917"><a href="#cb90-2917"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(s)</span>
<span id="cb90-2918"><a href="#cb90-2918"></a>    <span class="cf">if</span> <span class="fu">Availability</span>(s) <span class="op">==</span> <span class="fu">Availability</span><span class="dt">{:Unknown}</span>()</span>
<span id="cb90-2919"><a href="#cb90-2919"></a>        n <span class="op">=</span> <span class="fu">default_buffer_size</span>(s)</span>
<span id="cb90-2920"><a href="#cb90-2920"></a>    <span class="cf">else</span></span>
<span id="cb90-2921"><a href="#cb90-2921"></a>        n <span class="op">=</span> <span class="fu">bytesavailable</span>(s)</span>
<span id="cb90-2922"><a href="#cb90-2922"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb90-2923"><a href="#cb90-2923"></a>            <span class="pp">@db</span> <span class="cf">return</span> <span class="dt">UInt8</span>[]</span>
<span id="cb90-2924"><a href="#cb90-2924"></a>        <span class="cf">end</span></span>
<span id="cb90-2925"><a href="#cb90-2925"></a>    <span class="cf">end</span></span>
<span id="cb90-2926"><a href="#cb90-2926"></a>    buf <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{UInt8}</span>(<span class="cn">undef</span>, n)</span>
<span id="cb90-2927"><a href="#cb90-2927"></a>    n <span class="op">=</span> <span class="fu">transfer!</span>(s, buf, n; timeout)</span>
<span id="cb90-2928"><a href="#cb90-2928"></a>    <span class="fu">resize!</span>(buf, n)</span>
<span id="cb90-2929"><a href="#cb90-2929"></a><span class="kw">end</span></span>
<span id="cb90-2930"><a href="#cb90-2930"></a></span>
<span id="cb90-2931"><a href="#cb90-2931"></a><span class="bu">Base</span>.<span class="fu">readavailable</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; timeout<span class="op">=</span><span class="fl">0</span>) <span class="op">=</span> <span class="fu">readavailable</span>(io.stream; timeout)</span></code></pre></div>
<h2 id="function-readline">Function <code>readline</code></h2>
<p><code>readline</code> is specialised based on the Read Fragmentation
trait.</p>
<div class="sourceCode" id="cb91" data-startFrom="2940"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2939;"><span id="cb91-2940"><a href="#cb91-2940"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readline</span>(io<span class="op">::</span><span class="dt">BaseIO</span>; keep<span class="op">=</span><span class="cn">false</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb91-2941"><a href="#cb91-2941"></a>    <span class="fu">readline</span>(io.stream; keep, timeout)</span>
<span id="cb91-2942"><a href="#cb91-2942"></a><span class="kw">end</span></span></code></pre></div>
<p>If there is no special Read Fragmentation method, invoke the default
<code>Base.IO</code> method.</p>
<div class="sourceCode" id="cb92" data-startFrom="2948"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2947;"><span id="cb92-2948"><a href="#cb92-2948"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_readline</span>(stream, <span class="op">::</span><span class="dt">AnyReadUnit</span>; keep<span class="op">=</span><span class="cn">false</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb92-2949"><a href="#cb92-2949"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(stream; timeout)                ;<span class="pp">@db</span> timeout stream</span>
<span id="cb92-2950"><a href="#cb92-2950"></a>    <span class="pp">@invoke</span> <span class="bu">Base</span>.<span class="fu">readline</span>(<span class="fu">BaseIO</span>(stream)<span class="op">::</span><span class="dt">IO</span>; keep)</span>
<span id="cb92-2951"><a href="#cb92-2951"></a><span class="kw">end</span></span></code></pre></div>
<p>If the Read Unit is <code>:Line</code> simply calling
<code>transfer</code> once will read one line.</p>
<p>Character or Terminal devices (<code>S_IFCHR</code>) are often used
in “canonical mode” (<code>ICANON</code>).</p>
<blockquote>
<p>“In canonical mode: Input is made available line by line.” <a
href="https://man7.org/linux/man-pages/man3/termios.3.html">termios(3)</a>.</p>
</blockquote>
<p>For these devices calling <code>read(2)</code> will usually return
exactly one line. It will only ever return an incomplete line if length
exceeded <code>MAX_CANON</code>. Note that in canonical mode a line can
be terminated by <code>CEOF</code> rather than “”, but
<code>read(2)</code> does not return the <code>CEOF</code> character
(e.g. when the shell sends a “bash$” prompt without a newline).</p>
<div class="sourceCode" id="cb93" data-startFrom="2971"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2970;"><span id="cb93-2971"><a href="#cb93-2971"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="fu">_readline</span>(stream, <span class="op">::</span><span class="dt">ReadUnit{:Line}</span>; keep<span class="op">::</span><span class="dt">Bool</span>=<span class="cn">false</span>, timeout<span class="op">=</span><span class="cn">Inf</span>)</span>
<span id="cb93-2972"><a href="#cb93-2972"></a></span>
<span id="cb93-2973"><a href="#cb93-2973"></a>    v <span class="op">=</span> <span class="bu">Base</span>.<span class="fu">StringVector</span>(max_line)</span>
<span id="cb93-2974"><a href="#cb93-2974"></a>    n <span class="op">=</span> <span class="fu">transfer!</span>(stream <span class="op">=&gt;</span> v; timeout)</span>
<span id="cb93-2975"><a href="#cb93-2975"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb93-2976"><a href="#cb93-2976"></a>        <span class="pp">@db_not_tested</span></span>
<span id="cb93-2977"><a href="#cb93-2977"></a>        <span class="pp">@db</span> <span class="cf">return</span> <span class="st">&quot;&quot;</span></span>
<span id="cb93-2978"><a href="#cb93-2978"></a>    <span class="cf">end</span></span>
<span id="cb93-2979"><a href="#cb93-2979"></a></span>
<span id="cb93-2980"><a href="#cb93-2980"></a>    <span class="co"># Trim end of line characters.</span></span>
<span id="cb93-2981"><a href="#cb93-2981"></a>    <span class="cf">while</span> !keep <span class="op">&amp;&amp;</span> n <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> (v[n] <span class="op">==</span> <span class="fu">UInt8</span>(<span class="ch">&#39;\r&#39;</span>) <span class="op">||</span></span>
<span id="cb93-2982"><a href="#cb93-2982"></a>                             v[n] <span class="op">==</span> <span class="fu">UInt8</span>(<span class="ch">&#39;\n&#39;</span>))</span>
<span id="cb93-2983"><a href="#cb93-2983"></a>        n <span class="op">-=</span> <span class="fl">1</span></span>
<span id="cb93-2984"><a href="#cb93-2984"></a>        <span class="pp">@db_not_tested</span></span>
<span id="cb93-2985"><a href="#cb93-2985"></a>    <span class="cf">end</span></span>
<span id="cb93-2986"><a href="#cb93-2986"></a></span>
<span id="cb93-2987"><a href="#cb93-2987"></a>    <span class="pp">@db</span> <span class="cf">return</span> <span class="fu">String</span>(<span class="fu">resize!</span>(v, n))</span>
<span id="cb93-2988"><a href="#cb93-2988"></a><span class="kw">end</span></span>
<span id="cb93-2989"><a href="#cb93-2989"></a></span>
<span id="cb93-2990"><a href="#cb93-2990"></a><span class="kw">const</span> max_line <span class="op">=</span> <span class="fl">1024</span> <span class="co"># UnixIO.C.MAX_CANON</span></span></code></pre></div>
<h2 id="function-readuntil">Function <code>readuntil</code></h2>
<div class="sourceCode" id="cb94" data-startFrom="2995"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 2994;"><span id="cb94-2995"><a href="#cb94-2995"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">readuntil</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, d<span class="op">::</span><span class="dt">AbstractChar</span>; timeout<span class="op">=</span><span class="cn">Inf</span>, kw<span class="op">...</span>)</span>
<span id="cb94-2996"><a href="#cb94-2996"></a>    <span class="pp">@db_not_tested</span></span>
<span id="cb94-2997"><a href="#cb94-2997"></a>    <span class="pp">@require</span> <span class="fu">is_input</span>(io.stream)</span>
<span id="cb94-2998"><a href="#cb94-2998"></a>    stream <span class="op">=</span> <span class="fu">timeout_stream</span>(io.stream; timeout)</span>
<span id="cb94-2999"><a href="#cb94-2999"></a>    <span class="pp">@invoke</span> <span class="bu">Base</span>.<span class="fu">readuntil</span>(<span class="fu">BaseIO</span>(stream)<span class="op">::</span><span class="dt">IO</span>, d; kw<span class="op">...</span>)</span>
<span id="cb94-3000"><a href="#cb94-3000"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="function-writestream-x">Function
<code>write(stream, x)</code></h2>
<div class="sourceCode" id="cb95" data-startFrom="3005"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 3004;"><span id="cb95-3005"><a href="#cb95-3005"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">unsafe_write</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, buf<span class="op">::</span><span class="dt">Ptr{UInt8}</span>, nbytes<span class="op">::</span><span class="dt">UInt</span>)</span>
<span id="cb95-3006"><a href="#cb95-3006"></a>    <span class="pp">@require</span> <span class="fu">is_output</span>(io.stream)</span>
<span id="cb95-3007"><a href="#cb95-3007"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(io.stream)</span>
<span id="cb95-3008"><a href="#cb95-3008"></a>    <span class="fu">transferall!</span>(io.stream, buf, nbytes)</span>
<span id="cb95-3009"><a href="#cb95-3009"></a><span class="kw">end</span></span>
<span id="cb95-3010"><a href="#cb95-3010"></a></span>
<span id="cb95-3011"><a href="#cb95-3011"></a></span>
<span id="cb95-3012"><a href="#cb95-3012"></a><span class="pp">@db</span> <span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">write</span>(io<span class="op">::</span><span class="dt">BaseIO</span>, x<span class="op">::</span><span class="dt">UInt8</span>)</span>
<span id="cb95-3013"><a href="#cb95-3013"></a>    <span class="pp">@require</span> <span class="fu">is_output</span>(io.stream)</span>
<span id="cb95-3014"><a href="#cb95-3014"></a>    <span class="pp">@require</span> <span class="fu">isopen</span>(io.stream)</span>
<span id="cb95-3015"><a href="#cb95-3015"></a>    <span class="fu">transfer!</span>(x <span class="op">=&gt;</span> io.stream)</span>
<span id="cb95-3016"><a href="#cb95-3016"></a><span class="kw">end</span></span></code></pre></div>
<h1 id="exports">Exports</h1>
<div class="sourceCode" id="cb96" data-startFrom="3022"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 3021;"><span id="cb96-3022"><a href="#cb96-3022"></a><span class="kw">export</span> TraitsIO, TransferDirection, transfer!, transferall!, readall!</span>
<span id="cb96-3023"><a href="#cb96-3023"></a></span>
<span id="cb96-3024"><a href="#cb96-3024"></a><span class="kw">export</span> BufferedInput, LazyBufferedInput</span>
<span id="cb96-3025"><a href="#cb96-3025"></a></span>
<span id="cb96-3026"><a href="#cb96-3026"></a><span class="kw">export</span> TotalSize</span>
<span id="cb96-3027"><a href="#cb96-3027"></a></span>
<span id="cb96-3028"><a href="#cb96-3028"></a><span class="kw">export</span> Availability</span>
<span id="cb96-3029"><a href="#cb96-3029"></a></span>
<span id="cb96-3030"><a href="#cb96-3030"></a><span class="kw">export</span> TransferSize</span>
<span id="cb96-3031"><a href="#cb96-3031"></a></span>
<span id="cb96-3032"><a href="#cb96-3032"></a><span class="kw">export</span> ReadUnit</span>
<span id="cb96-3033"><a href="#cb96-3033"></a></span>
<span id="cb96-3034"><a href="#cb96-3034"></a><span class="kw">export</span> TransferMode</span>
<span id="cb96-3035"><a href="#cb96-3035"></a></span>
<span id="cb96-3036"><a href="#cb96-3036"></a><span class="kw">export</span> TransferAPI, WaitAPI, LengthAPI, BlockSizeAPI, ReadSizeAPI</span>
<span id="cb96-3037"><a href="#cb96-3037"></a></span>
<span id="cb96-3038"><a href="#cb96-3038"></a><span class="kw">export</span> Cursors</span>
<span id="cb96-3039"><a href="#cb96-3039"></a></span>
<span id="cb96-3040"><a href="#cb96-3040"></a><span class="kw">export</span> StreamIndexing, NotIndexable, IndexableIO</span></code></pre></div>
<h2 id="possibly-related-issues">Possibly Related Issues</h2>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Issue</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/14747">14747</a></td>
<td>Intermittent deadlock in readbytes(open(echo $text)) on Linux ?</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/22832">22832</a></td>
<td>Deadlock in reading stdout from cmd.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/1970">1970</a></td>
<td>Serial Port support.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/2640">2640</a></td>
<td>Pseudo-tty support.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/10292">10292</a></td>
<td>write on IOBuffer with a maxsize</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/libuv/libuv/issues/484">484</a></td>
<td>add uv_device_t as stream on windows and Linux to handle device
IO</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/3887">3887</a></td>
<td>refactor I/O to do more buffering</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/28975">28975</a></td>
<td>readline not working for ls</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24440">24440</a></td>
<td>Spawning turns IO race into process hang</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/20812">20812</a></td>
<td>Redirected STDOUT on macOS is hanging when more than 512 bytes are
written at once</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24717">24717</a></td>
<td>Pipe objects have lost their asyncness</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/36639">36639</a></td>
<td>slow printing in terminals</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/39727">39727</a></td>
<td>Bi-directional IOStream seems to mix input and output “Things work
fine when I replace open/read/write with ccall to open/read/write,
i.e. when I bypass julia IO.”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/17070">17070</a></td>
<td>Keyword argument docs for read are misleading. (all=true)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/40793">40793</a></td>
<td>readbytes!: support the all keyword for all methods. “I’ve
encountered cases where it doesn’t seems block.”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24526">24526</a></td>
<td>Review of IO blocking behaviour</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/33799">33799</a></td>
<td>Don’t export position. Position is zero-based.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/36954">36954</a></td>
<td>Rename <code>position</code> to <code>streampos</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/40500">40500</a></td>
<td><code>peek</code> breaks <code>mark</code>. “…any plans to publish a
proper interface for io one day?”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/41291">41291</a></td>
<td>PR: added docs for IO interface</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/40966">40966</a></td>
<td>sendfile: operation not supported error</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/35907">35907</a></td>
<td>Slow disk IO on MacOS</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/30044">30044</a></td>
<td>massive slowdowns using stdin/stdout “It seems like PipeEndpoint is
just really, really slow.”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24810">24810</a></td>
<td>Improve documentation for process interaction using pipes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/JuliaLang/julia/issues/24242">24242</a></td>
<td>Add isseekable to Stream/IO interface?</td>
</tr>
</tbody>
</table>
<h2 id="errors">Errors</h2>
<div class="sourceCode" id="cb97" data-startFrom="3111"><pre
class="sourceCode numberSource julia numberLines lineAnchors"><code class="sourceCode julia" style="counter-reset: source-line 3110;"><span id="cb97-3111"><a href="#cb97-3111"></a><span class="kw">struct</span> IOTraitsError <span class="op">&lt;:</span><span class="dt"> Exception</span></span>
<span id="cb97-3112"><a href="#cb97-3112"></a>    stream<span class="op">::</span><span class="dt">Stream</span></span>
<span id="cb97-3113"><a href="#cb97-3113"></a>    message<span class="op">::</span><span class="dt">String</span></span>
<span id="cb97-3114"><a href="#cb97-3114"></a><span class="kw">end</span></span>
<span id="cb97-3115"><a href="#cb97-3115"></a></span>
<span id="cb97-3116"><a href="#cb97-3116"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="fu">show</span>(io<span class="op">::</span><span class="dt">IO</span>, <span class="cn">e</span><span class="op">::</span><span class="dt">IOTraitsError</span>)</span>
<span id="cb97-3117"><a href="#cb97-3117"></a>    <span class="fu">print</span>(io, <span class="st">&quot;IOTraitsError: &quot;</span>, <span class="cn">e</span>.message)</span>
<span id="cb97-3118"><a href="#cb97-3118"></a><span class="kw">end</span></span>
<span id="cb97-3119"><a href="#cb97-3119"></a></span>
<span id="cb97-3120"><a href="#cb97-3120"></a></span>
<span id="cb97-3121"><a href="#cb97-3121"></a></span>
<span id="cb97-3122"><a href="#cb97-3122"></a><span class="im">using</span> <span class="bu">ReadmeDocs</span></span>
<span id="cb97-3123"><a href="#cb97-3123"></a></span>
<span id="cb97-3124"><a href="#cb97-3124"></a><span class="fu">include</span>(<span class="st">&quot;ioinfo.jl&quot;</span>) <span class="co"># Generate Method Resolution Info</span></span>
<span id="cb97-3125"><a href="#cb97-3125"></a></span>
<span id="cb97-3126"><a href="#cb97-3126"></a><span class="kw">end</span> <span class="co"># module IOTraits</span></span></code></pre></div>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
